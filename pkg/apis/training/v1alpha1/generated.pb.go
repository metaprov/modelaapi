/**
*
* Copyright (C) 2017 modela authors
* For license information, see LICENSE.txt
 */ // Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/metaprov/modelaapi/pkg/apis/training/v1alpha1/generated.proto

package v1alpha1

import (
	encoding_binary "encoding/binary"
	fmt "fmt"

	io "io"

	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1 "github.com/metaprov/modelaapi/pkg/apis/catalog/v1alpha1"
	v1alpha1 "github.com/metaprov/modelaapi/pkg/apis/catalog/v1alpha1"
	v1alpha11 "github.com/metaprov/modelaapi/pkg/apis/data/v1alpha1"
	k8s_io_api_core_v1 "k8s.io/api/core/v1"
	v11 "k8s.io/api/core/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

func (m *AlgorithmSearchSpaceSpec) Reset()      { *m = AlgorithmSearchSpaceSpec{} }
func (*AlgorithmSearchSpaceSpec) ProtoMessage() {}
func (*AlgorithmSearchSpaceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{0}
}
func (m *AlgorithmSearchSpaceSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlgorithmSearchSpaceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AlgorithmSearchSpaceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlgorithmSearchSpaceSpec.Merge(m, src)
}
func (m *AlgorithmSearchSpaceSpec) XXX_Size() int {
	return m.Size()
}
func (m *AlgorithmSearchSpaceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AlgorithmSearchSpaceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AlgorithmSearchSpaceSpec proto.InternalMessageInfo

func (m *AudioPipelineSpec) Reset()      { *m = AudioPipelineSpec{} }
func (*AudioPipelineSpec) ProtoMessage() {}
func (*AudioPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{1}
}
func (m *AudioPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AudioPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AudioPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AudioPipelineSpec.Merge(m, src)
}
func (m *AudioPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *AudioPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AudioPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AudioPipelineSpec proto.InternalMessageInfo

func (m *BacktestSpec) Reset()      { *m = BacktestSpec{} }
func (*BacktestSpec) ProtoMessage() {}
func (*BacktestSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{2}
}
func (m *BacktestSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BacktestSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BacktestSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BacktestSpec.Merge(m, src)
}
func (m *BacktestSpec) XXX_Size() int {
	return m.Size()
}
func (m *BacktestSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BacktestSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BacktestSpec proto.InternalMessageInfo

func (m *CapacityStageSpec) Reset()      { *m = CapacityStageSpec{} }
func (*CapacityStageSpec) ProtoMessage() {}
func (*CapacityStageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{3}
}
func (m *CapacityStageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CapacityStageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CapacityStageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapacityStageSpec.Merge(m, src)
}
func (m *CapacityStageSpec) XXX_Size() int {
	return m.Size()
}
func (m *CapacityStageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CapacityStageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CapacityStageSpec proto.InternalMessageInfo

func (m *ChangePointSpec) Reset()      { *m = ChangePointSpec{} }
func (*ChangePointSpec) ProtoMessage() {}
func (*ChangePointSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{4}
}
func (m *ChangePointSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePointSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChangePointSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePointSpec.Merge(m, src)
}
func (m *ChangePointSpec) XXX_Size() int {
	return m.Size()
}
func (m *ChangePointSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePointSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePointSpec proto.InternalMessageInfo

func (m *ChatbotEstimatorSpec) Reset()      { *m = ChatbotEstimatorSpec{} }
func (*ChatbotEstimatorSpec) ProtoMessage() {}
func (*ChatbotEstimatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{5}
}
func (m *ChatbotEstimatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatbotEstimatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChatbotEstimatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatbotEstimatorSpec.Merge(m, src)
}
func (m *ChatbotEstimatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *ChatbotEstimatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatbotEstimatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ChatbotEstimatorSpec proto.InternalMessageInfo

func (m *ClassicalEstimatorSpec) Reset()      { *m = ClassicalEstimatorSpec{} }
func (*ClassicalEstimatorSpec) ProtoMessage() {}
func (*ClassicalEstimatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{6}
}
func (m *ClassicalEstimatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassicalEstimatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClassicalEstimatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassicalEstimatorSpec.Merge(m, src)
}
func (m *ClassicalEstimatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *ClassicalEstimatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassicalEstimatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ClassicalEstimatorSpec proto.InternalMessageInfo

func (m *CronReport) Reset()      { *m = CronReport{} }
func (*CronReport) ProtoMessage() {}
func (*CronReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{7}
}
func (m *CronReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CronReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronReport.Merge(m, src)
}
func (m *CronReport) XXX_Size() int {
	return m.Size()
}
func (m *CronReport) XXX_DiscardUnknown() {
	xxx_messageInfo_CronReport.DiscardUnknown(m)
}

var xxx_messageInfo_CronReport proto.InternalMessageInfo

func (m *CronReportCondition) Reset()      { *m = CronReportCondition{} }
func (*CronReportCondition) ProtoMessage() {}
func (*CronReportCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{8}
}
func (m *CronReportCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronReportCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CronReportCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronReportCondition.Merge(m, src)
}
func (m *CronReportCondition) XXX_Size() int {
	return m.Size()
}
func (m *CronReportCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_CronReportCondition.DiscardUnknown(m)
}

var xxx_messageInfo_CronReportCondition proto.InternalMessageInfo

func (m *CronReportList) Reset()      { *m = CronReportList{} }
func (*CronReportList) ProtoMessage() {}
func (*CronReportList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{9}
}
func (m *CronReportList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronReportList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CronReportList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronReportList.Merge(m, src)
}
func (m *CronReportList) XXX_Size() int {
	return m.Size()
}
func (m *CronReportList) XXX_DiscardUnknown() {
	xxx_messageInfo_CronReportList.DiscardUnknown(m)
}

var xxx_messageInfo_CronReportList proto.InternalMessageInfo

func (m *CronReportSpec) Reset()      { *m = CronReportSpec{} }
func (*CronReportSpec) ProtoMessage() {}
func (*CronReportSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{10}
}
func (m *CronReportSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronReportSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CronReportSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronReportSpec.Merge(m, src)
}
func (m *CronReportSpec) XXX_Size() int {
	return m.Size()
}
func (m *CronReportSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CronReportSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CronReportSpec proto.InternalMessageInfo

func (m *CronReportStatus) Reset()      { *m = CronReportStatus{} }
func (*CronReportStatus) ProtoMessage() {}
func (*CronReportStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{11}
}
func (m *CronReportStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronReportStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CronReportStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronReportStatus.Merge(m, src)
}
func (m *CronReportStatus) XXX_Size() int {
	return m.Size()
}
func (m *CronReportStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_CronReportStatus.DiscardUnknown(m)
}

var xxx_messageInfo_CronReportStatus proto.InternalMessageInfo

func (m *CustomReportBarChart) Reset()      { *m = CustomReportBarChart{} }
func (*CustomReportBarChart) ProtoMessage() {}
func (*CustomReportBarChart) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{12}
}
func (m *CustomReportBarChart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomReportBarChart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CustomReportBarChart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomReportBarChart.Merge(m, src)
}
func (m *CustomReportBarChart) XXX_Size() int {
	return m.Size()
}
func (m *CustomReportBarChart) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomReportBarChart.DiscardUnknown(m)
}

var xxx_messageInfo_CustomReportBarChart proto.InternalMessageInfo

func (m *CustomReportHistogram) Reset()      { *m = CustomReportHistogram{} }
func (*CustomReportHistogram) ProtoMessage() {}
func (*CustomReportHistogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{13}
}
func (m *CustomReportHistogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomReportHistogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CustomReportHistogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomReportHistogram.Merge(m, src)
}
func (m *CustomReportHistogram) XXX_Size() int {
	return m.Size()
}
func (m *CustomReportHistogram) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomReportHistogram.DiscardUnknown(m)
}

var xxx_messageInfo_CustomReportHistogram proto.InternalMessageInfo

func (m *CustomReportLineChart) Reset()      { *m = CustomReportLineChart{} }
func (*CustomReportLineChart) ProtoMessage() {}
func (*CustomReportLineChart) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{14}
}
func (m *CustomReportLineChart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomReportLineChart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CustomReportLineChart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomReportLineChart.Merge(m, src)
}
func (m *CustomReportLineChart) XXX_Size() int {
	return m.Size()
}
func (m *CustomReportLineChart) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomReportLineChart.DiscardUnknown(m)
}

var xxx_messageInfo_CustomReportLineChart proto.InternalMessageInfo

func (m *CustomReportScatterPlot) Reset()      { *m = CustomReportScatterPlot{} }
func (*CustomReportScatterPlot) ProtoMessage() {}
func (*CustomReportScatterPlot) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{15}
}
func (m *CustomReportScatterPlot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomReportScatterPlot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CustomReportScatterPlot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomReportScatterPlot.Merge(m, src)
}
func (m *CustomReportScatterPlot) XXX_Size() int {
	return m.Size()
}
func (m *CustomReportScatterPlot) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomReportScatterPlot.DiscardUnknown(m)
}

var xxx_messageInfo_CustomReportScatterPlot proto.InternalMessageInfo

func (m *CustomReportSpec) Reset()      { *m = CustomReportSpec{} }
func (*CustomReportSpec) ProtoMessage() {}
func (*CustomReportSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{16}
}
func (m *CustomReportSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomReportSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CustomReportSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomReportSpec.Merge(m, src)
}
func (m *CustomReportSpec) XXX_Size() int {
	return m.Size()
}
func (m *CustomReportSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomReportSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CustomReportSpec proto.InternalMessageInfo

func (m *CustomReportTable) Reset()      { *m = CustomReportTable{} }
func (*CustomReportTable) ProtoMessage() {}
func (*CustomReportTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{17}
}
func (m *CustomReportTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomReportTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CustomReportTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomReportTable.Merge(m, src)
}
func (m *CustomReportTable) XXX_Size() int {
	return m.Size()
}
func (m *CustomReportTable) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomReportTable.DiscardUnknown(m)
}

var xxx_messageInfo_CustomReportTable proto.InternalMessageInfo

func (m *CustomReportValue) Reset()      { *m = CustomReportValue{} }
func (*CustomReportValue) ProtoMessage() {}
func (*CustomReportValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{18}
}
func (m *CustomReportValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomReportValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CustomReportValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomReportValue.Merge(m, src)
}
func (m *CustomReportValue) XXX_Size() int {
	return m.Size()
}
func (m *CustomReportValue) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomReportValue.DiscardUnknown(m)
}

var xxx_messageInfo_CustomReportValue proto.InternalMessageInfo

func (m *CustomSeasonalitySpec) Reset()      { *m = CustomSeasonalitySpec{} }
func (*CustomSeasonalitySpec) ProtoMessage() {}
func (*CustomSeasonalitySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{19}
}
func (m *CustomSeasonalitySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomSeasonalitySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CustomSeasonalitySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomSeasonalitySpec.Merge(m, src)
}
func (m *CustomSeasonalitySpec) XXX_Size() int {
	return m.Size()
}
func (m *CustomSeasonalitySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomSeasonalitySpec.DiscardUnknown(m)
}

var xxx_messageInfo_CustomSeasonalitySpec proto.InternalMessageInfo

func (m *DataHashes) Reset()      { *m = DataHashes{} }
func (*DataHashes) ProtoMessage() {}
func (*DataHashes) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{20}
}
func (m *DataHashes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataHashes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataHashes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataHashes.Merge(m, src)
}
func (m *DataHashes) XXX_Size() int {
	return m.Size()
}
func (m *DataHashes) XXX_DiscardUnknown() {
	xxx_messageInfo_DataHashes.DiscardUnknown(m)
}

var xxx_messageInfo_DataHashes proto.InternalMessageInfo

func (m *DataSplit) Reset()      { *m = DataSplit{} }
func (*DataSplit) ProtoMessage() {}
func (*DataSplit) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{21}
}
func (m *DataSplit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSplit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataSplit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSplit.Merge(m, src)
}
func (m *DataSplit) XXX_Size() int {
	return m.Size()
}
func (m *DataSplit) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSplit.DiscardUnknown(m)
}

var xxx_messageInfo_DataSplit proto.InternalMessageInfo

func (m *DataStageSpec) Reset()      { *m = DataStageSpec{} }
func (*DataStageSpec) ProtoMessage() {}
func (*DataStageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{22}
}
func (m *DataStageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataStageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataStageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataStageSpec.Merge(m, src)
}
func (m *DataStageSpec) XXX_Size() int {
	return m.Size()
}
func (m *DataStageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DataStageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DataStageSpec proto.InternalMessageInfo

func (m *DeepEstimatorLayer) Reset()      { *m = DeepEstimatorLayer{} }
func (*DeepEstimatorLayer) ProtoMessage() {}
func (*DeepEstimatorLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{23}
}
func (m *DeepEstimatorLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeepEstimatorLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeepEstimatorLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeepEstimatorLayer.Merge(m, src)
}
func (m *DeepEstimatorLayer) XXX_Size() int {
	return m.Size()
}
func (m *DeepEstimatorLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_DeepEstimatorLayer.DiscardUnknown(m)
}

var xxx_messageInfo_DeepEstimatorLayer proto.InternalMessageInfo

func (m *DeepEstimatorSpec) Reset()      { *m = DeepEstimatorSpec{} }
func (*DeepEstimatorSpec) ProtoMessage() {}
func (*DeepEstimatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{24}
}
func (m *DeepEstimatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeepEstimatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeepEstimatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeepEstimatorSpec.Merge(m, src)
}
func (m *DeepEstimatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *DeepEstimatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DeepEstimatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DeepEstimatorSpec proto.InternalMessageInfo

func (m *DeploymentStageSpec) Reset()      { *m = DeploymentStageSpec{} }
func (*DeploymentStageSpec) ProtoMessage() {}
func (*DeploymentStageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{25}
}
func (m *DeploymentStageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentStageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeploymentStageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentStageSpec.Merge(m, src)
}
func (m *DeploymentStageSpec) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentStageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentStageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentStageSpec proto.InternalMessageInfo

func (m *EnsembleRules) Reset()      { *m = EnsembleRules{} }
func (*EnsembleRules) ProtoMessage() {}
func (*EnsembleRules) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{26}
}
func (m *EnsembleRules) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnsembleRules) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnsembleRules) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnsembleRules.Merge(m, src)
}
func (m *EnsembleRules) XXX_Size() int {
	return m.Size()
}
func (m *EnsembleRules) XXX_DiscardUnknown() {
	xxx_messageInfo_EnsembleRules.DiscardUnknown(m)
}

var xxx_messageInfo_EnsembleRules proto.InternalMessageInfo

func (m *EnsembleSpec) Reset()      { *m = EnsembleSpec{} }
func (*EnsembleSpec) ProtoMessage() {}
func (*EnsembleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{27}
}
func (m *EnsembleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnsembleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnsembleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnsembleSpec.Merge(m, src)
}
func (m *EnsembleSpec) XXX_Size() int {
	return m.Size()
}
func (m *EnsembleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_EnsembleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_EnsembleSpec proto.InternalMessageInfo

func (m *FeatureEngineeringPipeline) Reset()      { *m = FeatureEngineeringPipeline{} }
func (*FeatureEngineeringPipeline) ProtoMessage() {}
func (*FeatureEngineeringPipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{28}
}
func (m *FeatureEngineeringPipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureEngineeringPipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureEngineeringPipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureEngineeringPipeline.Merge(m, src)
}
func (m *FeatureEngineeringPipeline) XXX_Size() int {
	return m.Size()
}
func (m *FeatureEngineeringPipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureEngineeringPipeline.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureEngineeringPipeline proto.InternalMessageInfo

func (m *FeatureEngineeringSpec) Reset()      { *m = FeatureEngineeringSpec{} }
func (*FeatureEngineeringSpec) ProtoMessage() {}
func (*FeatureEngineeringSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{29}
}
func (m *FeatureEngineeringSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureEngineeringSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureEngineeringSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureEngineeringSpec.Merge(m, src)
}
func (m *FeatureEngineeringSpec) XXX_Size() int {
	return m.Size()
}
func (m *FeatureEngineeringSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureEngineeringSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureEngineeringSpec proto.InternalMessageInfo

func (m *FeatureEngineeringStatus) Reset()      { *m = FeatureEngineeringStatus{} }
func (*FeatureEngineeringStatus) ProtoMessage() {}
func (*FeatureEngineeringStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{30}
}
func (m *FeatureEngineeringStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureEngineeringStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureEngineeringStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureEngineeringStatus.Merge(m, src)
}
func (m *FeatureEngineeringStatus) XXX_Size() int {
	return m.Size()
}
func (m *FeatureEngineeringStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureEngineeringStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureEngineeringStatus proto.InternalMessageInfo

func (m *FeatureImportance) Reset()      { *m = FeatureImportance{} }
func (*FeatureImportance) ProtoMessage() {}
func (*FeatureImportance) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{31}
}
func (m *FeatureImportance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureImportance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureImportance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureImportance.Merge(m, src)
}
func (m *FeatureImportance) XXX_Size() int {
	return m.Size()
}
func (m *FeatureImportance) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureImportance.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureImportance proto.InternalMessageInfo

func (m *FeatureInfo) Reset()      { *m = FeatureInfo{} }
func (*FeatureInfo) ProtoMessage() {}
func (*FeatureInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{32}
}
func (m *FeatureInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureInfo.Merge(m, src)
}
func (m *FeatureInfo) XXX_Size() int {
	return m.Size()
}
func (m *FeatureInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureInfo proto.InternalMessageInfo

func (m *FeatureSelectionSpec) Reset()      { *m = FeatureSelectionSpec{} }
func (*FeatureSelectionSpec) ProtoMessage() {}
func (*FeatureSelectionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{33}
}
func (m *FeatureSelectionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureSelectionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureSelectionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureSelectionSpec.Merge(m, src)
}
func (m *FeatureSelectionSpec) XXX_Size() int {
	return m.Size()
}
func (m *FeatureSelectionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureSelectionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureSelectionSpec proto.InternalMessageInfo

func (m *ForecastObj) Reset()      { *m = ForecastObj{} }
func (*ForecastObj) ProtoMessage() {}
func (*ForecastObj) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{34}
}
func (m *ForecastObj) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForecastObj) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForecastObj) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForecastObj.Merge(m, src)
}
func (m *ForecastObj) XXX_Size() int {
	return m.Size()
}
func (m *ForecastObj) XXX_DiscardUnknown() {
	xxx_messageInfo_ForecastObj.DiscardUnknown(m)
}

var xxx_messageInfo_ForecastObj proto.InternalMessageInfo

func (m *ForecastPostProcessingSpec) Reset()      { *m = ForecastPostProcessingSpec{} }
func (*ForecastPostProcessingSpec) ProtoMessage() {}
func (*ForecastPostProcessingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{35}
}
func (m *ForecastPostProcessingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForecastPostProcessingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForecastPostProcessingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForecastPostProcessingSpec.Merge(m, src)
}
func (m *ForecastPostProcessingSpec) XXX_Size() int {
	return m.Size()
}
func (m *ForecastPostProcessingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ForecastPostProcessingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ForecastPostProcessingSpec proto.InternalMessageInfo

func (m *ForecastSpec) Reset()      { *m = ForecastSpec{} }
func (*ForecastSpec) ProtoMessage() {}
func (*ForecastSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{36}
}
func (m *ForecastSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForecastSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForecastSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForecastSpec.Merge(m, src)
}
func (m *ForecastSpec) XXX_Size() int {
	return m.Size()
}
func (m *ForecastSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ForecastSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ForecastSpec proto.InternalMessageInfo

func (m *FormatSpec) Reset()      { *m = FormatSpec{} }
func (*FormatSpec) ProtoMessage() {}
func (*FormatSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{37}
}
func (m *FormatSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FormatSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FormatSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FormatSpec.Merge(m, src)
}
func (m *FormatSpec) XXX_Size() int {
	return m.Size()
}
func (m *FormatSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FormatSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FormatSpec proto.InternalMessageInfo

func (m *GeneratedColumnSpec) Reset()      { *m = GeneratedColumnSpec{} }
func (*GeneratedColumnSpec) ProtoMessage() {}
func (*GeneratedColumnSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{38}
}
func (m *GeneratedColumnSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeneratedColumnSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GeneratedColumnSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeneratedColumnSpec.Merge(m, src)
}
func (m *GeneratedColumnSpec) XXX_Size() int {
	return m.Size()
}
func (m *GeneratedColumnSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_GeneratedColumnSpec.DiscardUnknown(m)
}

var xxx_messageInfo_GeneratedColumnSpec proto.InternalMessageInfo

func (m *Hierarchy) Reset()      { *m = Hierarchy{} }
func (*Hierarchy) ProtoMessage() {}
func (*Hierarchy) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{39}
}
func (m *Hierarchy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Hierarchy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Hierarchy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Hierarchy.Merge(m, src)
}
func (m *Hierarchy) XXX_Size() int {
	return m.Size()
}
func (m *Hierarchy) XXX_DiscardUnknown() {
	xxx_messageInfo_Hierarchy.DiscardUnknown(m)
}

var xxx_messageInfo_Hierarchy proto.InternalMessageInfo

func (m *HolidaySpec) Reset()      { *m = HolidaySpec{} }
func (*HolidaySpec) ProtoMessage() {}
func (*HolidaySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{40}
}
func (m *HolidaySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HolidaySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HolidaySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HolidaySpec.Merge(m, src)
}
func (m *HolidaySpec) XXX_Size() int {
	return m.Size()
}
func (m *HolidaySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_HolidaySpec.DiscardUnknown(m)
}

var xxx_messageInfo_HolidaySpec proto.InternalMessageInfo

func (m *HyperParameterValue) Reset()      { *m = HyperParameterValue{} }
func (*HyperParameterValue) ProtoMessage() {}
func (*HyperParameterValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{41}
}
func (m *HyperParameterValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HyperParameterValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HyperParameterValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HyperParameterValue.Merge(m, src)
}
func (m *HyperParameterValue) XXX_Size() int {
	return m.Size()
}
func (m *HyperParameterValue) XXX_DiscardUnknown() {
	xxx_messageInfo_HyperParameterValue.DiscardUnknown(m)
}

var xxx_messageInfo_HyperParameterValue proto.InternalMessageInfo

func (m *ImagePipelineSpec) Reset()      { *m = ImagePipelineSpec{} }
func (*ImagePipelineSpec) ProtoMessage() {}
func (*ImagePipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{42}
}
func (m *ImagePipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImagePipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ImagePipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImagePipelineSpec.Merge(m, src)
}
func (m *ImagePipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *ImagePipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ImagePipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ImagePipelineSpec proto.InternalMessageInfo

func (m *Level) Reset()      { *m = Level{} }
func (*Level) ProtoMessage() {}
func (*Level) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{43}
}
func (m *Level) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Level) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Level) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Level.Merge(m, src)
}
func (m *Level) XXX_Size() int {
	return m.Size()
}
func (m *Level) XXX_DiscardUnknown() {
	xxx_messageInfo_Level.DiscardUnknown(m)
}

var xxx_messageInfo_Level proto.InternalMessageInfo

func (m *Model) Reset()      { *m = Model{} }
func (*Model) ProtoMessage() {}
func (*Model) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{44}
}
func (m *Model) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Model) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model.Merge(m, src)
}
func (m *Model) XXX_Size() int {
	return m.Size()
}
func (m *Model) XXX_DiscardUnknown() {
	xxx_messageInfo_Model.DiscardUnknown(m)
}

var xxx_messageInfo_Model proto.InternalMessageInfo

func (m *ModelAutobuilder) Reset()      { *m = ModelAutobuilder{} }
func (*ModelAutobuilder) ProtoMessage() {}
func (*ModelAutobuilder) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{45}
}
func (m *ModelAutobuilder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelAutobuilder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelAutobuilder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAutobuilder.Merge(m, src)
}
func (m *ModelAutobuilder) XXX_Size() int {
	return m.Size()
}
func (m *ModelAutobuilder) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAutobuilder.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAutobuilder proto.InternalMessageInfo

func (m *ModelAutobuilderCondition) Reset()      { *m = ModelAutobuilderCondition{} }
func (*ModelAutobuilderCondition) ProtoMessage() {}
func (*ModelAutobuilderCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{46}
}
func (m *ModelAutobuilderCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelAutobuilderCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelAutobuilderCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAutobuilderCondition.Merge(m, src)
}
func (m *ModelAutobuilderCondition) XXX_Size() int {
	return m.Size()
}
func (m *ModelAutobuilderCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAutobuilderCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAutobuilderCondition proto.InternalMessageInfo

func (m *ModelAutobuilderList) Reset()      { *m = ModelAutobuilderList{} }
func (*ModelAutobuilderList) ProtoMessage() {}
func (*ModelAutobuilderList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{47}
}
func (m *ModelAutobuilderList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelAutobuilderList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelAutobuilderList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAutobuilderList.Merge(m, src)
}
func (m *ModelAutobuilderList) XXX_Size() int {
	return m.Size()
}
func (m *ModelAutobuilderList) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAutobuilderList.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAutobuilderList proto.InternalMessageInfo

func (m *ModelAutobuilderSpec) Reset()      { *m = ModelAutobuilderSpec{} }
func (*ModelAutobuilderSpec) ProtoMessage() {}
func (*ModelAutobuilderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{48}
}
func (m *ModelAutobuilderSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelAutobuilderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelAutobuilderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAutobuilderSpec.Merge(m, src)
}
func (m *ModelAutobuilderSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelAutobuilderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAutobuilderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAutobuilderSpec proto.InternalMessageInfo

func (m *ModelAutobuilderStatus) Reset()      { *m = ModelAutobuilderStatus{} }
func (*ModelAutobuilderStatus) ProtoMessage() {}
func (*ModelAutobuilderStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{49}
}
func (m *ModelAutobuilderStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelAutobuilderStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelAutobuilderStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAutobuilderStatus.Merge(m, src)
}
func (m *ModelAutobuilderStatus) XXX_Size() int {
	return m.Size()
}
func (m *ModelAutobuilderStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAutobuilderStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAutobuilderStatus proto.InternalMessageInfo

func (m *ModelCompilerRun) Reset()      { *m = ModelCompilerRun{} }
func (*ModelCompilerRun) ProtoMessage() {}
func (*ModelCompilerRun) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{50}
}
func (m *ModelCompilerRun) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelCompilerRun) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelCompilerRun) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelCompilerRun.Merge(m, src)
}
func (m *ModelCompilerRun) XXX_Size() int {
	return m.Size()
}
func (m *ModelCompilerRun) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelCompilerRun.DiscardUnknown(m)
}

var xxx_messageInfo_ModelCompilerRun proto.InternalMessageInfo

func (m *ModelCompilerRunCondition) Reset()      { *m = ModelCompilerRunCondition{} }
func (*ModelCompilerRunCondition) ProtoMessage() {}
func (*ModelCompilerRunCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{51}
}
func (m *ModelCompilerRunCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelCompilerRunCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelCompilerRunCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelCompilerRunCondition.Merge(m, src)
}
func (m *ModelCompilerRunCondition) XXX_Size() int {
	return m.Size()
}
func (m *ModelCompilerRunCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelCompilerRunCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ModelCompilerRunCondition proto.InternalMessageInfo

func (m *ModelCompilerRunList) Reset()      { *m = ModelCompilerRunList{} }
func (*ModelCompilerRunList) ProtoMessage() {}
func (*ModelCompilerRunList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{52}
}
func (m *ModelCompilerRunList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelCompilerRunList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelCompilerRunList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelCompilerRunList.Merge(m, src)
}
func (m *ModelCompilerRunList) XXX_Size() int {
	return m.Size()
}
func (m *ModelCompilerRunList) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelCompilerRunList.DiscardUnknown(m)
}

var xxx_messageInfo_ModelCompilerRunList proto.InternalMessageInfo

func (m *ModelCompilerRunSpec) Reset()      { *m = ModelCompilerRunSpec{} }
func (*ModelCompilerRunSpec) ProtoMessage() {}
func (*ModelCompilerRunSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{53}
}
func (m *ModelCompilerRunSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelCompilerRunSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelCompilerRunSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelCompilerRunSpec.Merge(m, src)
}
func (m *ModelCompilerRunSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelCompilerRunSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelCompilerRunSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelCompilerRunSpec proto.InternalMessageInfo

func (m *ModelCompilerRunStatus) Reset()      { *m = ModelCompilerRunStatus{} }
func (*ModelCompilerRunStatus) ProtoMessage() {}
func (*ModelCompilerRunStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{54}
}
func (m *ModelCompilerRunStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelCompilerRunStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelCompilerRunStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelCompilerRunStatus.Merge(m, src)
}
func (m *ModelCompilerRunStatus) XXX_Size() int {
	return m.Size()
}
func (m *ModelCompilerRunStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelCompilerRunStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ModelCompilerRunStatus proto.InternalMessageInfo

func (m *ModelCondition) Reset()      { *m = ModelCondition{} }
func (*ModelCondition) ProtoMessage() {}
func (*ModelCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{55}
}
func (m *ModelCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelCondition.Merge(m, src)
}
func (m *ModelCondition) XXX_Size() int {
	return m.Size()
}
func (m *ModelCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ModelCondition proto.InternalMessageInfo

func (m *ModelImageSpec) Reset()      { *m = ModelImageSpec{} }
func (*ModelImageSpec) ProtoMessage() {}
func (*ModelImageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{56}
}
func (m *ModelImageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelImageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelImageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelImageSpec.Merge(m, src)
}
func (m *ModelImageSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelImageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelImageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelImageSpec proto.InternalMessageInfo

func (m *ModelList) Reset()      { *m = ModelList{} }
func (*ModelList) ProtoMessage() {}
func (*ModelList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{57}
}
func (m *ModelList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelList.Merge(m, src)
}
func (m *ModelList) XXX_Size() int {
	return m.Size()
}
func (m *ModelList) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelList.DiscardUnknown(m)
}

var xxx_messageInfo_ModelList proto.InternalMessageInfo

func (m *ModelPipeline) Reset()      { *m = ModelPipeline{} }
func (*ModelPipeline) ProtoMessage() {}
func (*ModelPipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{58}
}
func (m *ModelPipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipeline.Merge(m, src)
}
func (m *ModelPipeline) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipeline.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipeline proto.InternalMessageInfo

func (m *ModelPipelineCondition) Reset()      { *m = ModelPipelineCondition{} }
func (*ModelPipelineCondition) ProtoMessage() {}
func (*ModelPipelineCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{59}
}
func (m *ModelPipelineCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineCondition.Merge(m, src)
}
func (m *ModelPipelineCondition) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineCondition proto.InternalMessageInfo

func (m *ModelPipelineList) Reset()      { *m = ModelPipelineList{} }
func (*ModelPipelineList) ProtoMessage() {}
func (*ModelPipelineList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{60}
}
func (m *ModelPipelineList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineList.Merge(m, src)
}
func (m *ModelPipelineList) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineList) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineList.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineList proto.InternalMessageInfo

func (m *ModelPipelineRun) Reset()      { *m = ModelPipelineRun{} }
func (*ModelPipelineRun) ProtoMessage() {}
func (*ModelPipelineRun) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{61}
}
func (m *ModelPipelineRun) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineRun) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineRun) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineRun.Merge(m, src)
}
func (m *ModelPipelineRun) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineRun) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineRun.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineRun proto.InternalMessageInfo

func (m *ModelPipelineRunCondition) Reset()      { *m = ModelPipelineRunCondition{} }
func (*ModelPipelineRunCondition) ProtoMessage() {}
func (*ModelPipelineRunCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{62}
}
func (m *ModelPipelineRunCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineRunCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineRunCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineRunCondition.Merge(m, src)
}
func (m *ModelPipelineRunCondition) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineRunCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineRunCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineRunCondition proto.InternalMessageInfo

func (m *ModelPipelineRunList) Reset()      { *m = ModelPipelineRunList{} }
func (*ModelPipelineRunList) ProtoMessage() {}
func (*ModelPipelineRunList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{63}
}
func (m *ModelPipelineRunList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineRunList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineRunList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineRunList.Merge(m, src)
}
func (m *ModelPipelineRunList) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineRunList) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineRunList.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineRunList proto.InternalMessageInfo

func (m *ModelPipelineRunSpec) Reset()      { *m = ModelPipelineRunSpec{} }
func (*ModelPipelineRunSpec) ProtoMessage() {}
func (*ModelPipelineRunSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{64}
}
func (m *ModelPipelineRunSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineRunSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineRunSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineRunSpec.Merge(m, src)
}
func (m *ModelPipelineRunSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineRunSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineRunSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineRunSpec proto.InternalMessageInfo

func (m *ModelPipelineRunStageStatus) Reset()      { *m = ModelPipelineRunStageStatus{} }
func (*ModelPipelineRunStageStatus) ProtoMessage() {}
func (*ModelPipelineRunStageStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{65}
}
func (m *ModelPipelineRunStageStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineRunStageStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineRunStageStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineRunStageStatus.Merge(m, src)
}
func (m *ModelPipelineRunStageStatus) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineRunStageStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineRunStageStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineRunStageStatus proto.InternalMessageInfo

func (m *ModelPipelineRunStatus) Reset()      { *m = ModelPipelineRunStatus{} }
func (*ModelPipelineRunStatus) ProtoMessage() {}
func (*ModelPipelineRunStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{66}
}
func (m *ModelPipelineRunStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineRunStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineRunStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineRunStatus.Merge(m, src)
}
func (m *ModelPipelineRunStatus) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineRunStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineRunStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineRunStatus proto.InternalMessageInfo

func (m *ModelPipelineSpec) Reset()      { *m = ModelPipelineSpec{} }
func (*ModelPipelineSpec) ProtoMessage() {}
func (*ModelPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{67}
}
func (m *ModelPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineSpec.Merge(m, src)
}
func (m *ModelPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineSpec proto.InternalMessageInfo

func (m *ModelPipelineStatus) Reset()      { *m = ModelPipelineStatus{} }
func (*ModelPipelineStatus) ProtoMessage() {}
func (*ModelPipelineStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{68}
}
func (m *ModelPipelineStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineStatus.Merge(m, src)
}
func (m *ModelPipelineStatus) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineStatus proto.InternalMessageInfo

func (m *ModelResult) Reset()      { *m = ModelResult{} }
func (*ModelResult) ProtoMessage() {}
func (*ModelResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{69}
}
func (m *ModelResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelResult.Merge(m, src)
}
func (m *ModelResult) XXX_Size() int {
	return m.Size()
}
func (m *ModelResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelResult.DiscardUnknown(m)
}

var xxx_messageInfo_ModelResult proto.InternalMessageInfo

func (m *ModelSearchSpec) Reset()      { *m = ModelSearchSpec{} }
func (*ModelSearchSpec) ProtoMessage() {}
func (*ModelSearchSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{70}
}
func (m *ModelSearchSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelSearchSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelSearchSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelSearchSpec.Merge(m, src)
}
func (m *ModelSearchSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelSearchSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelSearchSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelSearchSpec proto.InternalMessageInfo

func (m *ModelSpec) Reset()      { *m = ModelSpec{} }
func (*ModelSpec) ProtoMessage() {}
func (*ModelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{71}
}
func (m *ModelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelSpec.Merge(m, src)
}
func (m *ModelSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelSpec proto.InternalMessageInfo

func (m *ModelStatus) Reset()      { *m = ModelStatus{} }
func (*ModelStatus) ProtoMessage() {}
func (*ModelStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{72}
}
func (m *ModelStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelStatus.Merge(m, src)
}
func (m *ModelStatus) XXX_Size() int {
	return m.Size()
}
func (m *ModelStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ModelStatus proto.InternalMessageInfo

func (m *ModelValidation) Reset()      { *m = ModelValidation{} }
func (*ModelValidation) ProtoMessage() {}
func (*ModelValidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{73}
}
func (m *ModelValidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelValidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelValidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelValidation.Merge(m, src)
}
func (m *ModelValidation) XXX_Size() int {
	return m.Size()
}
func (m *ModelValidation) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelValidation.DiscardUnknown(m)
}

var xxx_messageInfo_ModelValidation proto.InternalMessageInfo

func (m *ModelValidationResult) Reset()      { *m = ModelValidationResult{} }
func (*ModelValidationResult) ProtoMessage() {}
func (*ModelValidationResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{74}
}
func (m *ModelValidationResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelValidationResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelValidationResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelValidationResult.Merge(m, src)
}
func (m *ModelValidationResult) XXX_Size() int {
	return m.Size()
}
func (m *ModelValidationResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelValidationResult.DiscardUnknown(m)
}

var xxx_messageInfo_ModelValidationResult proto.InternalMessageInfo

func (m *NLPEstimatorSpec) Reset()      { *m = NLPEstimatorSpec{} }
func (*NLPEstimatorSpec) ProtoMessage() {}
func (*NLPEstimatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{75}
}
func (m *NLPEstimatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NLPEstimatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NLPEstimatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NLPEstimatorSpec.Merge(m, src)
}
func (m *NLPEstimatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *NLPEstimatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NLPEstimatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NLPEstimatorSpec proto.InternalMessageInfo

func (m *NNLayerParameter) Reset()      { *m = NNLayerParameter{} }
func (*NNLayerParameter) ProtoMessage() {}
func (*NNLayerParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{76}
}
func (m *NNLayerParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NNLayerParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NNLayerParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NNLayerParameter.Merge(m, src)
}
func (m *NNLayerParameter) XXX_Size() int {
	return m.Size()
}
func (m *NNLayerParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_NNLayerParameter.DiscardUnknown(m)
}

var xxx_messageInfo_NNLayerParameter proto.InternalMessageInfo

func (m *Notebook) Reset()      { *m = Notebook{} }
func (*Notebook) ProtoMessage() {}
func (*Notebook) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{77}
}
func (m *Notebook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notebook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Notebook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notebook.Merge(m, src)
}
func (m *Notebook) XXX_Size() int {
	return m.Size()
}
func (m *Notebook) XXX_DiscardUnknown() {
	xxx_messageInfo_Notebook.DiscardUnknown(m)
}

var xxx_messageInfo_Notebook proto.InternalMessageInfo

func (m *NotebookCondition) Reset()      { *m = NotebookCondition{} }
func (*NotebookCondition) ProtoMessage() {}
func (*NotebookCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{78}
}
func (m *NotebookCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookCondition.Merge(m, src)
}
func (m *NotebookCondition) XXX_Size() int {
	return m.Size()
}
func (m *NotebookCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookCondition.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookCondition proto.InternalMessageInfo

func (m *NotebookList) Reset()      { *m = NotebookList{} }
func (*NotebookList) ProtoMessage() {}
func (*NotebookList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{79}
}
func (m *NotebookList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookList.Merge(m, src)
}
func (m *NotebookList) XXX_Size() int {
	return m.Size()
}
func (m *NotebookList) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookList.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookList proto.InternalMessageInfo

func (m *NotebookRun) Reset()      { *m = NotebookRun{} }
func (*NotebookRun) ProtoMessage() {}
func (*NotebookRun) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{80}
}
func (m *NotebookRun) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookRun) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookRun) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookRun.Merge(m, src)
}
func (m *NotebookRun) XXX_Size() int {
	return m.Size()
}
func (m *NotebookRun) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookRun.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookRun proto.InternalMessageInfo

func (m *NotebookRunCondition) Reset()      { *m = NotebookRunCondition{} }
func (*NotebookRunCondition) ProtoMessage() {}
func (*NotebookRunCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{81}
}
func (m *NotebookRunCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookRunCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookRunCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookRunCondition.Merge(m, src)
}
func (m *NotebookRunCondition) XXX_Size() int {
	return m.Size()
}
func (m *NotebookRunCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookRunCondition.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookRunCondition proto.InternalMessageInfo

func (m *NotebookRunList) Reset()      { *m = NotebookRunList{} }
func (*NotebookRunList) ProtoMessage() {}
func (*NotebookRunList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{82}
}
func (m *NotebookRunList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookRunList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookRunList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookRunList.Merge(m, src)
}
func (m *NotebookRunList) XXX_Size() int {
	return m.Size()
}
func (m *NotebookRunList) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookRunList.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookRunList proto.InternalMessageInfo

func (m *NotebookRunSpec) Reset()      { *m = NotebookRunSpec{} }
func (*NotebookRunSpec) ProtoMessage() {}
func (*NotebookRunSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{83}
}
func (m *NotebookRunSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookRunSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookRunSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookRunSpec.Merge(m, src)
}
func (m *NotebookRunSpec) XXX_Size() int {
	return m.Size()
}
func (m *NotebookRunSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookRunSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookRunSpec proto.InternalMessageInfo

func (m *NotebookRunStatus) Reset()      { *m = NotebookRunStatus{} }
func (*NotebookRunStatus) ProtoMessage() {}
func (*NotebookRunStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{84}
}
func (m *NotebookRunStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookRunStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookRunStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookRunStatus.Merge(m, src)
}
func (m *NotebookRunStatus) XXX_Size() int {
	return m.Size()
}
func (m *NotebookRunStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookRunStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookRunStatus proto.InternalMessageInfo

func (m *NotebookSpec) Reset()      { *m = NotebookSpec{} }
func (*NotebookSpec) ProtoMessage() {}
func (*NotebookSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{85}
}
func (m *NotebookSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookSpec.Merge(m, src)
}
func (m *NotebookSpec) XXX_Size() int {
	return m.Size()
}
func (m *NotebookSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookSpec proto.InternalMessageInfo

func (m *NotebookStatus) Reset()      { *m = NotebookStatus{} }
func (*NotebookStatus) ProtoMessage() {}
func (*NotebookStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{86}
}
func (m *NotebookStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookStatus.Merge(m, src)
}
func (m *NotebookStatus) XXX_Size() int {
	return m.Size()
}
func (m *NotebookStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookStatus proto.InternalMessageInfo

func (m *NotebookVarValue) Reset()      { *m = NotebookVarValue{} }
func (*NotebookVarValue) ProtoMessage() {}
func (*NotebookVarValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{87}
}
func (m *NotebookVarValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookVarValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookVarValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookVarValue.Merge(m, src)
}
func (m *NotebookVarValue) XXX_Size() int {
	return m.Size()
}
func (m *NotebookVarValue) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookVarValue.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookVarValue proto.InternalMessageInfo

func (m *PeriodSeasonalitySpec) Reset()      { *m = PeriodSeasonalitySpec{} }
func (*PeriodSeasonalitySpec) ProtoMessage() {}
func (*PeriodSeasonalitySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{88}
}
func (m *PeriodSeasonalitySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeriodSeasonalitySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PeriodSeasonalitySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeriodSeasonalitySpec.Merge(m, src)
}
func (m *PeriodSeasonalitySpec) XXX_Size() int {
	return m.Size()
}
func (m *PeriodSeasonalitySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PeriodSeasonalitySpec.DiscardUnknown(m)
}

var xxx_messageInfo_PeriodSeasonalitySpec proto.InternalMessageInfo

func (m *PeriodSpec) Reset()      { *m = PeriodSpec{} }
func (*PeriodSpec) ProtoMessage() {}
func (*PeriodSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{89}
}
func (m *PeriodSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeriodSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PeriodSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeriodSpec.Merge(m, src)
}
func (m *PeriodSpec) XXX_Size() int {
	return m.Size()
}
func (m *PeriodSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PeriodSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PeriodSpec proto.InternalMessageInfo

func (m *PrunerSpec) Reset()      { *m = PrunerSpec{} }
func (*PrunerSpec) ProtoMessage() {}
func (*PrunerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{90}
}
func (m *PrunerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrunerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PrunerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrunerSpec.Merge(m, src)
}
func (m *PrunerSpec) XXX_Size() int {
	return m.Size()
}
func (m *PrunerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PrunerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PrunerSpec proto.InternalMessageInfo

func (m *RegressorSpec) Reset()      { *m = RegressorSpec{} }
func (*RegressorSpec) ProtoMessage() {}
func (*RegressorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{91}
}
func (m *RegressorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegressorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RegressorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegressorSpec.Merge(m, src)
}
func (m *RegressorSpec) XXX_Size() int {
	return m.Size()
}
func (m *RegressorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RegressorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RegressorSpec proto.InternalMessageInfo

func (m *ReleaseStageSpec) Reset()      { *m = ReleaseStageSpec{} }
func (*ReleaseStageSpec) ProtoMessage() {}
func (*ReleaseStageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{92}
}
func (m *ReleaseStageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReleaseStageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReleaseStageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReleaseStageSpec.Merge(m, src)
}
func (m *ReleaseStageSpec) XXX_Size() int {
	return m.Size()
}
func (m *ReleaseStageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ReleaseStageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ReleaseStageSpec proto.InternalMessageInfo

func (m *Report) Reset()      { *m = Report{} }
func (*Report) ProtoMessage() {}
func (*Report) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{93}
}
func (m *Report) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Report) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Report) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Report.Merge(m, src)
}
func (m *Report) XXX_Size() int {
	return m.Size()
}
func (m *Report) XXX_DiscardUnknown() {
	xxx_messageInfo_Report.DiscardUnknown(m)
}

var xxx_messageInfo_Report proto.InternalMessageInfo

func (m *ReportCondition) Reset()      { *m = ReportCondition{} }
func (*ReportCondition) ProtoMessage() {}
func (*ReportCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{94}
}
func (m *ReportCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReportCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportCondition.Merge(m, src)
}
func (m *ReportCondition) XXX_Size() int {
	return m.Size()
}
func (m *ReportCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ReportCondition proto.InternalMessageInfo

func (m *ReportList) Reset()      { *m = ReportList{} }
func (*ReportList) ProtoMessage() {}
func (*ReportList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{95}
}
func (m *ReportList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReportList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportList.Merge(m, src)
}
func (m *ReportList) XXX_Size() int {
	return m.Size()
}
func (m *ReportList) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportList.DiscardUnknown(m)
}

var xxx_messageInfo_ReportList proto.InternalMessageInfo

func (m *ReportSpec) Reset()      { *m = ReportSpec{} }
func (*ReportSpec) ProtoMessage() {}
func (*ReportSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{96}
}
func (m *ReportSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReportSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportSpec.Merge(m, src)
}
func (m *ReportSpec) XXX_Size() int {
	return m.Size()
}
func (m *ReportSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ReportSpec proto.InternalMessageInfo

func (m *ReportStatus) Reset()      { *m = ReportStatus{} }
func (*ReportStatus) ProtoMessage() {}
func (*ReportStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{97}
}
func (m *ReportStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReportStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportStatus.Merge(m, src)
}
func (m *ReportStatus) XXX_Size() int {
	return m.Size()
}
func (m *ReportStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ReportStatus proto.InternalMessageInfo

func (m *ReportTemplate) Reset()      { *m = ReportTemplate{} }
func (*ReportTemplate) ProtoMessage() {}
func (*ReportTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{98}
}
func (m *ReportTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReportTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportTemplate.Merge(m, src)
}
func (m *ReportTemplate) XXX_Size() int {
	return m.Size()
}
func (m *ReportTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_ReportTemplate proto.InternalMessageInfo

func (m *ResourceConsumption) Reset()      { *m = ResourceConsumption{} }
func (*ResourceConsumption) ProtoMessage() {}
func (*ResourceConsumption) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{99}
}
func (m *ResourceConsumption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceConsumption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResourceConsumption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceConsumption.Merge(m, src)
}
func (m *ResourceConsumption) XXX_Size() int {
	return m.Size()
}
func (m *ResourceConsumption) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceConsumption.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceConsumption proto.InternalMessageInfo

func (m *Study) Reset()      { *m = Study{} }
func (*Study) ProtoMessage() {}
func (*Study) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{100}
}
func (m *Study) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Study) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Study) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Study.Merge(m, src)
}
func (m *Study) XXX_Size() int {
	return m.Size()
}
func (m *Study) XXX_DiscardUnknown() {
	xxx_messageInfo_Study.DiscardUnknown(m)
}

var xxx_messageInfo_Study proto.InternalMessageInfo

func (m *StudyCondition) Reset()      { *m = StudyCondition{} }
func (*StudyCondition) ProtoMessage() {}
func (*StudyCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{101}
}
func (m *StudyCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StudyCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StudyCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StudyCondition.Merge(m, src)
}
func (m *StudyCondition) XXX_Size() int {
	return m.Size()
}
func (m *StudyCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_StudyCondition.DiscardUnknown(m)
}

var xxx_messageInfo_StudyCondition proto.InternalMessageInfo

func (m *StudyForecastSpec) Reset()      { *m = StudyForecastSpec{} }
func (*StudyForecastSpec) ProtoMessage() {}
func (*StudyForecastSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{102}
}
func (m *StudyForecastSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StudyForecastSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StudyForecastSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StudyForecastSpec.Merge(m, src)
}
func (m *StudyForecastSpec) XXX_Size() int {
	return m.Size()
}
func (m *StudyForecastSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StudyForecastSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StudyForecastSpec proto.InternalMessageInfo

func (m *StudyList) Reset()      { *m = StudyList{} }
func (*StudyList) ProtoMessage() {}
func (*StudyList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{103}
}
func (m *StudyList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StudyList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StudyList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StudyList.Merge(m, src)
}
func (m *StudyList) XXX_Size() int {
	return m.Size()
}
func (m *StudyList) XXX_DiscardUnknown() {
	xxx_messageInfo_StudyList.DiscardUnknown(m)
}

var xxx_messageInfo_StudyList proto.InternalMessageInfo

func (m *StudyScheduleSpec) Reset()      { *m = StudyScheduleSpec{} }
func (*StudyScheduleSpec) ProtoMessage() {}
func (*StudyScheduleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{104}
}
func (m *StudyScheduleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StudyScheduleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StudyScheduleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StudyScheduleSpec.Merge(m, src)
}
func (m *StudyScheduleSpec) XXX_Size() int {
	return m.Size()
}
func (m *StudyScheduleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StudyScheduleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StudyScheduleSpec proto.InternalMessageInfo

func (m *StudySpec) Reset()      { *m = StudySpec{} }
func (*StudySpec) ProtoMessage() {}
func (*StudySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{105}
}
func (m *StudySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StudySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StudySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StudySpec.Merge(m, src)
}
func (m *StudySpec) XXX_Size() int {
	return m.Size()
}
func (m *StudySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StudySpec.DiscardUnknown(m)
}

var xxx_messageInfo_StudySpec proto.InternalMessageInfo

func (m *StudyStatus) Reset()      { *m = StudyStatus{} }
func (*StudyStatus) ProtoMessage() {}
func (*StudyStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{106}
}
func (m *StudyStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StudyStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StudyStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StudyStatus.Merge(m, src)
}
func (m *StudyStatus) XXX_Size() int {
	return m.Size()
}
func (m *StudyStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_StudyStatus.DiscardUnknown(m)
}

var xxx_messageInfo_StudyStatus proto.InternalMessageInfo

func (m *SuccessiveHalvingOptions) Reset()      { *m = SuccessiveHalvingOptions{} }
func (*SuccessiveHalvingOptions) ProtoMessage() {}
func (*SuccessiveHalvingOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{107}
}
func (m *SuccessiveHalvingOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuccessiveHalvingOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SuccessiveHalvingOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuccessiveHalvingOptions.Merge(m, src)
}
func (m *SuccessiveHalvingOptions) XXX_Size() int {
	return m.Size()
}
func (m *SuccessiveHalvingOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SuccessiveHalvingOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SuccessiveHalvingOptions proto.InternalMessageInfo

func (m *SuccessiveHalvingSpec) Reset()      { *m = SuccessiveHalvingSpec{} }
func (*SuccessiveHalvingSpec) ProtoMessage() {}
func (*SuccessiveHalvingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{108}
}
func (m *SuccessiveHalvingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuccessiveHalvingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SuccessiveHalvingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuccessiveHalvingSpec.Merge(m, src)
}
func (m *SuccessiveHalvingSpec) XXX_Size() int {
	return m.Size()
}
func (m *SuccessiveHalvingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SuccessiveHalvingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SuccessiveHalvingSpec proto.InternalMessageInfo

func (m *TextPipelineSpec) Reset()      { *m = TextPipelineSpec{} }
func (*TextPipelineSpec) ProtoMessage() {}
func (*TextPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{109}
}
func (m *TextPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TextPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TextPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextPipelineSpec.Merge(m, src)
}
func (m *TextPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *TextPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TextPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TextPipelineSpec proto.InternalMessageInfo

func (m *TimeSeriesDataSpec) Reset()      { *m = TimeSeriesDataSpec{} }
func (*TimeSeriesDataSpec) ProtoMessage() {}
func (*TimeSeriesDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{110}
}
func (m *TimeSeriesDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeSeriesDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TimeSeriesDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeSeriesDataSpec.Merge(m, src)
}
func (m *TimeSeriesDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *TimeSeriesDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeSeriesDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TimeSeriesDataSpec proto.InternalMessageInfo

func (m *TrainingSpec) Reset()      { *m = TrainingSpec{} }
func (*TrainingSpec) ProtoMessage() {}
func (*TrainingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{111}
}
func (m *TrainingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrainingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TrainingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrainingSpec.Merge(m, src)
}
func (m *TrainingSpec) XXX_Size() int {
	return m.Size()
}
func (m *TrainingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TrainingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TrainingSpec proto.InternalMessageInfo

func (m *TrainingStageSpec) Reset()      { *m = TrainingStageSpec{} }
func (*TrainingStageSpec) ProtoMessage() {}
func (*TrainingStageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{112}
}
func (m *TrainingStageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrainingStageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TrainingStageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrainingStageSpec.Merge(m, src)
}
func (m *TrainingStageSpec) XXX_Size() int {
	return m.Size()
}
func (m *TrainingStageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TrainingStageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TrainingStageSpec proto.InternalMessageInfo

func (m *UATStageSpec) Reset()      { *m = UATStageSpec{} }
func (*UATStageSpec) ProtoMessage() {}
func (*UATStageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{113}
}
func (m *UATStageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UATStageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UATStageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UATStageSpec.Merge(m, src)
}
func (m *UATStageSpec) XXX_Size() int {
	return m.Size()
}
func (m *UATStageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_UATStageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_UATStageSpec proto.InternalMessageInfo

func (m *VideoPipelineSpec) Reset()      { *m = VideoPipelineSpec{} }
func (*VideoPipelineSpec) ProtoMessage() {}
func (*VideoPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b06c1c430b441be9, []int{114}
}
func (m *VideoPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VideoPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoPipelineSpec.Merge(m, src)
}
func (m *VideoPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *VideoPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VideoPipelineSpec proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AlgorithmSearchSpaceSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.AlgorithmSearchSpaceSpec")
	proto.RegisterType((*AudioPipelineSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.AudioPipelineSpec")
	proto.RegisterType((*BacktestSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.BacktestSpec")
	proto.RegisterType((*CapacityStageSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CapacityStageSpec")
	proto.RegisterType((*ChangePointSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ChangePointSpec")
	proto.RegisterType((*ChatbotEstimatorSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ChatbotEstimatorSpec")
	proto.RegisterType((*ClassicalEstimatorSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ClassicalEstimatorSpec")
	proto.RegisterType((*CronReport)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CronReport")
	proto.RegisterType((*CronReportCondition)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CronReportCondition")
	proto.RegisterType((*CronReportList)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CronReportList")
	proto.RegisterType((*CronReportSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CronReportSpec")
	proto.RegisterType((*CronReportStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CronReportStatus")
	proto.RegisterType((*CustomReportBarChart)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CustomReportBarChart")
	proto.RegisterType((*CustomReportHistogram)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CustomReportHistogram")
	proto.RegisterType((*CustomReportLineChart)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CustomReportLineChart")
	proto.RegisterType((*CustomReportScatterPlot)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CustomReportScatterPlot")
	proto.RegisterType((*CustomReportSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CustomReportSpec")
	proto.RegisterType((*CustomReportTable)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CustomReportTable")
	proto.RegisterType((*CustomReportValue)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CustomReportValue")
	proto.RegisterType((*CustomSeasonalitySpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.CustomSeasonalitySpec")
	proto.RegisterType((*DataHashes)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.DataHashes")
	proto.RegisterType((*DataSplit)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.DataSplit")
	proto.RegisterType((*DataStageSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.DataStageSpec")
	proto.RegisterType((*DeepEstimatorLayer)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.DeepEstimatorLayer")
	proto.RegisterType((*DeepEstimatorSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.DeepEstimatorSpec")
	proto.RegisterType((*DeploymentStageSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.DeploymentStageSpec")
	proto.RegisterType((*EnsembleRules)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.EnsembleRules")
	proto.RegisterType((*EnsembleSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.EnsembleSpec")
	proto.RegisterType((*FeatureEngineeringPipeline)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.FeatureEngineeringPipeline")
	proto.RegisterType((*FeatureEngineeringSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.FeatureEngineeringSpec")
	proto.RegisterType((*FeatureEngineeringStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.FeatureEngineeringStatus")
	proto.RegisterType((*FeatureImportance)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.FeatureImportance")
	proto.RegisterType((*FeatureInfo)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.FeatureInfo")
	proto.RegisterType((*FeatureSelectionSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.FeatureSelectionSpec")
	proto.RegisterType((*ForecastObj)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ForecastObj")
	proto.RegisterType((*ForecastPostProcessingSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ForecastPostProcessingSpec")
	proto.RegisterType((*ForecastSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ForecastSpec")
	proto.RegisterType((*FormatSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.FormatSpec")
	proto.RegisterType((*GeneratedColumnSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.GeneratedColumnSpec")
	proto.RegisterType((*Hierarchy)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.Hierarchy")
	proto.RegisterType((*HolidaySpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.HolidaySpec")
	proto.RegisterType((*HyperParameterValue)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.HyperParameterValue")
	proto.RegisterType((*ImagePipelineSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ImagePipelineSpec")
	proto.RegisterType((*Level)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.Level")
	proto.RegisterType((*Model)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.Model")
	proto.RegisterType((*ModelAutobuilder)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelAutobuilder")
	proto.RegisterType((*ModelAutobuilderCondition)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelAutobuilderCondition")
	proto.RegisterType((*ModelAutobuilderList)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelAutobuilderList")
	proto.RegisterType((*ModelAutobuilderSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelAutobuilderSpec")
	proto.RegisterType((*ModelAutobuilderStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelAutobuilderStatus")
	proto.RegisterType((*ModelCompilerRun)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelCompilerRun")
	proto.RegisterType((*ModelCompilerRunCondition)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelCompilerRunCondition")
	proto.RegisterType((*ModelCompilerRunList)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelCompilerRunList")
	proto.RegisterType((*ModelCompilerRunSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelCompilerRunSpec")
	proto.RegisterType((*ModelCompilerRunStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelCompilerRunStatus")
	proto.RegisterType((*ModelCondition)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelCondition")
	proto.RegisterType((*ModelImageSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelImageSpec")
	proto.RegisterType((*ModelList)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelList")
	proto.RegisterType((*ModelPipeline)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelPipeline")
	proto.RegisterType((*ModelPipelineCondition)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelPipelineCondition")
	proto.RegisterType((*ModelPipelineList)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelPipelineList")
	proto.RegisterType((*ModelPipelineRun)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelPipelineRun")
	proto.RegisterType((*ModelPipelineRunCondition)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelPipelineRunCondition")
	proto.RegisterType((*ModelPipelineRunList)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelPipelineRunList")
	proto.RegisterType((*ModelPipelineRunSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelPipelineRunSpec")
	proto.RegisterType((*ModelPipelineRunStageStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelPipelineRunStageStatus")
	proto.RegisterType((*ModelPipelineRunStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelPipelineRunStatus")
	proto.RegisterType((*ModelPipelineSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelPipelineSpec")
	proto.RegisterMapType((map[string]string)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelPipelineSpec.DatasetSelectorEntry")
	proto.RegisterType((*ModelPipelineStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelPipelineStatus")
	proto.RegisterType((*ModelResult)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelResult")
	proto.RegisterType((*ModelSearchSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelSearchSpec")
	proto.RegisterType((*ModelSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelSpec")
	proto.RegisterType((*ModelStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelStatus")
	proto.RegisterMapType((map[string]string)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelStatus.PythonPackagesEntry")
	proto.RegisterType((*ModelValidation)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelValidation")
	proto.RegisterType((*ModelValidationResult)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ModelValidationResult")
	proto.RegisterType((*NLPEstimatorSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.NLPEstimatorSpec")
	proto.RegisterType((*NNLayerParameter)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.NNLayerParameter")
	proto.RegisterType((*Notebook)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.Notebook")
	proto.RegisterType((*NotebookCondition)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.NotebookCondition")
	proto.RegisterType((*NotebookList)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.NotebookList")
	proto.RegisterType((*NotebookRun)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.NotebookRun")
	proto.RegisterType((*NotebookRunCondition)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.NotebookRunCondition")
	proto.RegisterType((*NotebookRunList)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.NotebookRunList")
	proto.RegisterType((*NotebookRunSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.NotebookRunSpec")
	proto.RegisterType((*NotebookRunStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.NotebookRunStatus")
	proto.RegisterType((*NotebookSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.NotebookSpec")
	proto.RegisterType((*NotebookStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.NotebookStatus")
	proto.RegisterType((*NotebookVarValue)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.NotebookVarValue")
	proto.RegisterType((*PeriodSeasonalitySpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.PeriodSeasonalitySpec")
	proto.RegisterType((*PeriodSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.PeriodSpec")
	proto.RegisterType((*PrunerSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.PrunerSpec")
	proto.RegisterType((*RegressorSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.RegressorSpec")
	proto.RegisterType((*ReleaseStageSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ReleaseStageSpec")
	proto.RegisterType((*Report)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.Report")
	proto.RegisterType((*ReportCondition)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ReportCondition")
	proto.RegisterType((*ReportList)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ReportList")
	proto.RegisterType((*ReportSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ReportSpec")
	proto.RegisterType((*ReportStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ReportStatus")
	proto.RegisterType((*ReportTemplate)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ReportTemplate")
	proto.RegisterType((*ResourceConsumption)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.ResourceConsumption")
	proto.RegisterType((*Study)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.Study")
	proto.RegisterType((*StudyCondition)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.StudyCondition")
	proto.RegisterType((*StudyForecastSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.StudyForecastSpec")
	proto.RegisterType((*StudyList)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.StudyList")
	proto.RegisterType((*StudyScheduleSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.StudyScheduleSpec")
	proto.RegisterType((*StudySpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.StudySpec")
	proto.RegisterType((*StudyStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.StudyStatus")
	proto.RegisterType((*SuccessiveHalvingOptions)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.SuccessiveHalvingOptions")
	proto.RegisterType((*SuccessiveHalvingSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.SuccessiveHalvingSpec")
	proto.RegisterType((*TextPipelineSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.TextPipelineSpec")
	proto.RegisterType((*TimeSeriesDataSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.TimeSeriesDataSpec")
	proto.RegisterType((*TrainingSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.TrainingSpec")
	proto.RegisterType((*TrainingStageSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.TrainingStageSpec")
	proto.RegisterType((*UATStageSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.UATStageSpec")
	proto.RegisterType((*VideoPipelineSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.training.v1alpha1.VideoPipelineSpec")
}

func init() {
	proto.RegisterFile("github.com/metaprov/modelaapi/pkg/apis/training/v1alpha1/generated.proto", fileDescriptor_b06c1c430b441be9)
}

var fileDescriptor_b06c1c430b441be9 = []byte{
	// 11736 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0xbd, 0x7d, 0x8c, 0x24, 0xc7,
	0x75, 0x18, 0xae, 0x99, 0xfd, 0x9a, 0xad, 0xfd, 0xae, 0xbd, 0x3b, 0xce, 0x1d, 0xc9, 0x1b, 0x6a,
	0xf8, 0xa1, 0xa3, 0x28, 0xed, 0x89, 0xfc, 0x9d, 0x4c, 0x8a, 0x12, 0x25, 0xee, 0xe7, 0xdd, 0x89,
	0xbb, 0x77, 0xcb, 0x37, 0xc3, 0xe3, 0x8f, 0x8a, 0xac, 0xa8, 0x77, 0xa6, 0x76, 0xb6, 0x75, 0x3d,
	0xdd, 0xcd, 0xee, 0x9e, 0xbd, 0x5b, 0x4a, 0xb2, 0x64, 0x47, 0x51, 0x24, 0x27, 0x16, 0x14, 0xc7,
	0x76, 0x94, 0x04, 0xc9, 0x1f, 0xf9, 0x30, 0x10, 0x19, 0x09, 0x8c, 0x04, 0x01, 0xf2, 0x47, 0x02,
	0x23, 0xf9, 0x4b, 0x40, 0x00, 0xc5, 0x0e, 0x12, 0xc4, 0x86, 0xe3, 0x95, 0xb5, 0x8e, 0x11, 0xc4,
	0x40, 0x3e, 0xe0, 0x24, 0x40, 0x70, 0x40, 0xe0, 0xa0, 0x5e, 0x55, 0x75, 0x55, 0xf5, 0xcc, 0xec,
	0xcd, 0xce, 0xcc, 0x2e, 0xc5, 0x98, 0x7f, 0xed, 0xce, 0x7b, 0xaf, 0xde, 0xab, 0xae, 0xae, 0xae,
	0x7a, 0xef, 0xd5, 0x7b, 0xaf, 0xc8, 0x8d, 0x86, 0x9b, 0xec, 0xb5, 0x76, 0x96, 0x6a, 0x41, 0xf3,
	0x6a, 0x93, 0x25, 0x4e, 0x18, 0x05, 0xfb, 0x57, 0x9b, 0x41, 0x9d, 0x79, 0x8e, 0x13, 0xba, 0x57,
	0xc3, 0xbb, 0x8d, 0xab, 0x4e, 0xe8, 0xc6, 0x57, 0x93, 0xc8, 0x71, 0x7d, 0xd7, 0x6f, 0x5c, 0xdd,
	0x7f, 0xde, 0xf1, 0xc2, 0x3d, 0xe7, 0xf9, 0xab, 0x0d, 0xe6, 0xb3, 0xc8, 0x49, 0x58, 0x7d, 0x29,
	0x8c, 0x82, 0x24, 0xa0, 0x2f, 0x69, 0x4e, 0x4b, 0x8a, 0xd3, 0x52, 0xca, 0x69, 0x29, 0xbc, 0xdb,
	0x58, 0xe2, 0x9c, 0x96, 0x14, 0xa7, 0x25, 0xc5, 0xe9, 0xd2, 0x47, 0x8d, 0x3e, 0x34, 0x82, 0x46,
	0x70, 0x15, 0x19, 0xee, 0xb4, 0x76, 0xf1, 0x17, 0xfe, 0xc0, 0xff, 0x84, 0xa0, 0x4b, 0xd7, 0x7b,
	0xec, 0x72, 0xcd, 0x49, 0x1c, 0x2f, 0xe8, 0xde, 0xe3, 0x4b, 0x6b, 0x3d, 0x32, 0xaa, 0x3b, 0x89,
	0xd3, 0x9d, 0x4b, 0xf9, 0xee, 0x4b, 0xf1, 0x92, 0x1b, 0x70, 0xd2, 0xab, 0xb5, 0x20, 0x62, 0x57,
	0xf7, 0xdb, 0x69, 0xae, 0x69, 0x9a, 0xa6, 0x53, 0xdb, 0x73, 0x7d, 0x16, 0x1d, 0x68, 0xfe, 0x5c,
	0x76, 0xa7, 0x56, 0x57, 0xbb, 0xb5, 0x8a, 0x5a, 0x7e, 0xe2, 0x36, 0x59, 0x5b, 0x83, 0x9f, 0x7a,
	0x58, 0x83, 0xb8, 0xb6, 0xc7, 0x9a, 0x4e, 0xb6, 0x5d, 0xf9, 0xff, 0x8c, 0x90, 0xe2, 0xb2, 0xd7,
	0x08, 0x22, 0x37, 0xd9, 0x6b, 0x56, 0x98, 0x13, 0xd5, 0xf6, 0x2a, 0xa1, 0x53, 0x63, 0x95, 0x90,
	0xd5, 0xe8, 0x97, 0xc9, 0xa4, 0xe3, 0x79, 0xc1, 0x3d, 0xcf, 0x8d, 0x93, 0xe2, 0xf4, 0x13, 0x23,
	0x57, 0x26, 0x57, 0x7e, 0xfa, 0xe8, 0xb0, 0x34, 0xb9, 0xcc, 0x81, 0x9b, 0x6e, 0x9c, 0x3c, 0x38,
	0x2c, 0x6d, 0xf6, 0xf9, 0x4a, 0x96, 0x56, 0x3d, 0x27, 0x8e, 0xdd, 0xda, 0x7a, 0x9c, 0xb8, 0x4d,
	0x27, 0x09, 0xa2, 0x5b, 0x4e, 0x93, 0x81, 0x96, 0x47, 0x5f, 0x26, 0xb3, 0xfb, 0x41, 0xe2, 0xfa,
	0x8d, 0x75, 0x3f, 0x66, 0xcd, 0x1d, 0x8f, 0x15, 0x67, 0x9e, 0xc8, 0x5d, 0x29, 0xac, 0xd0, 0xa3,
	0xc3, 0xd2, 0xec, 0x1d, 0x0b, 0x03, 0x19, 0x4a, 0xfa, 0x2a, 0x99, 0x8f, 0x13, 0xa7, 0x76, 0xd7,
	0x6c, 0x3d, 0x8b, 0xad, 0xcf, 0x1d, 0x1d, 0x96, 0xe6, 0x2b, 0x19, 0x1c, 0xb4, 0x51, 0xd3, 0x15,
	0x32, 0xbe, 0xeb, 0x7a, 0x09, 0x8b, 0x8a, 0xf3, 0x4f, 0xe4, 0xae, 0x4c, 0xae, 0x7c, 0xf8, 0xe8,
	0xb0, 0x34, 0x97, 0x0e, 0xd4, 0x06, 0xa2, 0x1e, 0x1c, 0x96, 0x16, 0x33, 0x20, 0x7c, 0x08, 0xd9,
	0x92, 0x0f, 0xdf, 0x8e, 0x13, 0x33, 0xcf, 0xf5, 0x59, 0x5c, 0x5c, 0xd0, 0xc3, 0xb7, 0xa2, 0x80,
	0xc3, 0x1f, 0xbe, 0x54, 0x1e, 0x7d, 0x9a, 0x4c, 0x24, 0x2c, 0x4e, 0x96, 0x3d, 0xaf, 0x48, 0xf1,
	0xc9, 0xa7, 0x8e, 0x0e, 0x4b, 0x13, 0x55, 0x01, 0x02, 0x85, 0x2b, 0x7f, 0x27, 0x47, 0x16, 0x96,
	0x5b, 0x75, 0x37, 0xd8, 0x76, 0x43, 0x6c, 0x89, 0x2f, 0xfe, 0x80, 0x90, 0x5d, 0xe6, 0x24, 0xad,
	0xc8, 0x7d, 0x87, 0x45, 0xc5, 0x1c, 0x8e, 0xc0, 0x5b, 0x47, 0x87, 0x25, 0xb2, 0x91, 0x42, 0x1f,
	0x1c, 0x96, 0xfa, 0xfd, 0x1a, 0x97, 0x50, 0xa0, 0x66, 0x05, 0x86, 0xb0, 0xf2, 0xb7, 0xf2, 0x64,
	0x7a, 0xc5, 0xa9, 0xdd, 0xe5, 0x1d, 0xc4, 0xbe, 0x3c, 0x4d, 0x26, 0x62, 0xcf, 0xad, 0xbb, 0x7e,
	0x03, 0x3b, 0x22, 0x1f, 0xa4, 0x22, 0x40, 0xa0, 0x70, 0xf4, 0x06, 0x59, 0x54, 0xcb, 0xcb, 0x9b,
	0xae, 0x5f, 0x0f, 0xee, 0xc5, 0x15, 0xf7, 0x1d, 0x56, 0xcc, 0x3f, 0x91, 0xbb, 0x32, 0xb6, 0x72,
	0xe1, 0xe8, 0xb0, 0x44, 0xab, 0x16, 0x9a, 0x63, 0xa1, 0x53, 0x13, 0xfa, 0x3a, 0xb9, 0xb0, 0x1b,
	0x44, 0xac, 0xe6, 0xc4, 0x49, 0x86, 0xd9, 0x08, 0x32, 0xbb, 0x78, 0x74, 0x58, 0x3a, 0xbf, 0x91,
	0xa5, 0x40, 0x7e, 0x5d, 0x1a, 0xd2, 0x6b, 0x64, 0x5a, 0xf6, 0xb3, 0x92, 0xb0, 0x30, 0x2e, 0x8e,
	0x22, 0xa3, 0xf9, 0xa3, 0xc3, 0xd2, 0x74, 0xc5, 0x80, 0x83, 0x45, 0x55, 0xfe, 0x17, 0x79, 0xb2,
	0xb0, 0xea, 0x84, 0x4e, 0xcd, 0x4d, 0x0e, 0x2a, 0x89, 0xd3, 0x60, 0x6a, 0x3c, 0x98, 0xef, 0xec,
	0x78, 0xac, 0x6e, 0x8e, 0xc7, 0xba, 0x00, 0x81, 0xc2, 0xd1, 0x57, 0xc8, 0x5c, 0xcc, 0xa2, 0x7d,
	0xce, 0xcc, 0x4d, 0x18, 0x9f, 0x1d, 0x38, 0x16, 0x93, 0x2b, 0x8b, 0x7c, 0x26, 0x57, 0x6c, 0x14,
	0x64, 0x69, 0xe9, 0xd7, 0x73, 0x64, 0x6a, 0xdf, 0xf1, 0xdc, 0xba, 0x93, 0xb8, 0x81, 0x1f, 0x17,
	0x47, 0x9e, 0x18, 0xb9, 0x32, 0xf5, 0xc2, 0xcd, 0xa5, 0x7e, 0x57, 0xfa, 0xa5, 0x2d, 0x4e, 0x74,
	0x27, 0xe5, 0xb8, 0xb2, 0xf8, 0x83, 0xc3, 0xd2, 0x07, 0x8e, 0x0e, 0x4b, 0x53, 0x1a, 0x16, 0x83,
	0x29, 0x92, 0xae, 0x92, 0x85, 0x7b, 0x41, 0x74, 0xd7, 0x0b, 0x9c, 0x3a, 0x4e, 0x76, 0x7c, 0x86,
	0x31, 0x7c, 0x86, 0xf3, 0x47, 0x87, 0xa5, 0x85, 0x37, 0xb3, 0x48, 0x68, 0xa7, 0x2f, 0xbf, 0x4a,
	0xe6, 0x56, 0xf7, 0x1c, 0xbf, 0xc1, 0xb6, 0x03, 0xd7, 0x17, 0x13, 0x6a, 0x9a, 0xe4, 0x6e, 0xe1,
	0xd0, 0x8d, 0x41, 0xee, 0x16, 0x2d, 0x91, 0xb1, 0x88, 0xe3, 0x71, 0x74, 0x72, 0x2b, 0x93, 0x47,
	0x87, 0xa5, 0x31, 0xe0, 0x00, 0x10, 0xf0, 0xf2, 0x35, 0x72, 0x6e, 0x75, 0xcf, 0x49, 0x76, 0x82,
	0x24, 0xfd, 0xd6, 0x90, 0xcd, 0x63, 0x64, 0x94, 0x7f, 0x6d, 0xf2, 0xeb, 0x28, 0x1c, 0x1d, 0x96,
	0x46, 0xf9, 0x87, 0x0d, 0x08, 0x2d, 0xff, 0xf7, 0x1c, 0xb9, 0x20, 0x3f, 0x51, 0xc7, 0xb3, 0x1b,
	0x7e, 0x92, 0xcc, 0x38, 0x6a, 0xd5, 0xc0, 0x67, 0x12, 0x1c, 0xce, 0xcb, 0x01, 0x99, 0x59, 0x36,
	0x91, 0x60, 0xd3, 0xd2, 0xef, 0xe5, 0x08, 0x09, 0x9d, 0xc8, 0x69, 0xb2, 0x84, 0x45, 0x71, 0x31,
	0x8f, 0xaf, 0x65, 0xab, 0xff, 0xd7, 0x72, 0xe3, 0x20, 0x64, 0xd1, 0xb6, 0x62, 0x78, 0xc7, 0xf1,
	0x5a, 0x6c, 0xe5, 0x59, 0xd9, 0x13, 0x92, 0xc2, 0xf9, 0x4a, 0xb5, 0xd8, 0x81, 0x14, 0x8c, 0xbe,
	0x94, 0x7f, 0x98, 0x27, 0x64, 0x35, 0x0a, 0x7c, 0x60, 0x61, 0x10, 0x25, 0xf4, 0x8b, 0xa4, 0xc0,
	0xbb, 0xc2, 0x77, 0x50, 0x7c, 0xc2, 0xa9, 0x17, 0x3e, 0xb6, 0x24, 0x36, 0xa9, 0x25, 0x73, 0x93,
	0xd2, 0x9d, 0xe3, 0xd4, 0x4b, 0xfb, 0xcf, 0x2f, 0xdd, 0xde, 0xf9, 0x12, 0xab, 0x25, 0x5b, 0x2c,
	0x71, 0x56, 0xa8, 0xea, 0x89, 0x86, 0x41, 0xca, 0x95, 0x7e, 0x89, 0x8c, 0xc6, 0x21, 0xab, 0xe1,
	0x9b, 0x9b, 0x7a, 0xe1, 0x46, 0xff, 0x83, 0xa0, 0x7b, 0xcd, 0x5f, 0xd0, 0xca, 0xb4, 0x94, 0x3a,
	0xca, 0x7f, 0x01, 0xca, 0xa0, 0x11, 0x19, 0x8f, 0x13, 0x27, 0x69, 0xc5, 0xb8, 0x08, 0x4c, 0xbd,
	0xf0, 0xd9, 0xa1, 0x48, 0x43, 0x8e, 0x2b, 0xb3, 0x52, 0xde, 0xb8, 0xf8, 0x0d, 0x52, 0x52, 0xf9,
	0x3f, 0xe5, 0xc9, 0xa2, 0x26, 0x5e, 0x0d, 0xfc, 0xba, 0xcb, 0xbf, 0x0c, 0xfa, 0x49, 0x32, 0x9a,
	0x1c, 0x84, 0x6a, 0xde, 0x7c, 0x48, 0xf5, 0xb6, 0x7a, 0x10, 0xb2, 0x07, 0x87, 0xa5, 0x47, 0x3a,
	0x34, 0xe1, 0x28, 0xc0, 0x46, 0x74, 0x33, 0x7d, 0x10, 0xb1, 0x1c, 0x5c, 0xb3, 0x85, 0x3f, 0x38,
	0x2c, 0x75, 0xd0, 0x6a, 0x96, 0x52, 0x4e, 0x76, 0x17, 0x69, 0x44, 0xa8, 0xe7, 0xc4, 0x49, 0x35,
	0x72, 0xfc, 0x58, 0x48, 0x72, 0x9b, 0x4c, 0x0e, 0xd1, 0x87, 0x7b, 0x7b, 0xdd, 0xbc, 0x85, 0x58,
	0xa0, 0x37, 0xdb, 0x38, 0x41, 0x07, 0xee, 0xf4, 0x19, 0x32, 0x1e, 0x31, 0x27, 0x0e, 0x7c, 0x5c,
	0x46, 0x27, 0xf5, 0xf0, 0x01, 0x42, 0x41, 0x62, 0xe9, 0xb3, 0x64, 0xa2, 0xc9, 0xe2, 0xd8, 0x69,
	0xa8, 0x55, 0x63, 0x4e, 0x12, 0x4e, 0x6c, 0x09, 0x30, 0x28, 0x7c, 0xf9, 0x77, 0x72, 0x64, 0x56,
	0x0f, 0x1b, 0xd7, 0x6c, 0xe8, 0xe7, 0xdb, 0xa6, 0xef, 0x52, 0x6f, 0xcf, 0xc3, 0x5b, 0xe3, 0xe4,
	0x9d, 0x97, 0xe2, 0x0a, 0x0a, 0x62, 0x4c, 0x5d, 0x97, 0x8c, 0xb9, 0x09, 0x6b, 0xaa, 0x0f, 0x78,
	0x6d, 0x18, 0xb3, 0x69, 0x65, 0x46, 0x0a, 0x1c, 0xbb, 0xc9, 0x59, 0x83, 0x90, 0x50, 0xfe, 0xfe,
	0xa8, 0xf9, 0x6c, 0xb8, 0x02, 0x3d, 0x4f, 0xa6, 0xf6, 0x59, 0x14, 0xbb, 0x81, 0x6f, 0xac, 0x3f,
	0x73, 0xb8, 0x18, 0x6b, 0x30, 0x98, 0x34, 0x7c, 0x99, 0x0c, 0xee, 0xf9, 0x2c, 0x92, 0xb3, 0x06,
	0x97, 0xc9, 0xdb, 0x1c, 0x00, 0x02, 0x4e, 0x23, 0x52, 0xe0, 0x2a, 0x66, 0xbd, 0xe5, 0xa9, 0xf7,
	0xdf, 0xf3, 0x43, 0x49, 0xfd, 0x40, 0x3f, 0x13, 0xb4, 0xfc, 0x8a, 0xe4, 0xa5, 0x47, 0x51, 0x41,
	0x20, 0x95, 0x43, 0x97, 0xd4, 0xda, 0x2d, 0x26, 0x42, 0x31, 0x5d, 0xbb, 0x1f, 0x1c, 0x96, 0xa6,
	0xc4, 0xf3, 0x9a, 0x4b, 0x39, 0xdd, 0x27, 0x85, 0x84, 0x35, 0x43, 0xcf, 0x49, 0xc4, 0x94, 0x18,
	0x68, 0xd1, 0x10, 0xfc, 0xab, 0x92, 0x9f, 0xee, 0xa7, 0x82, 0x40, 0x2a, 0x8b, 0x96, 0xc9, 0x78,
	0xe8, 0xb4, 0x62, 0x56, 0x2f, 0x8e, 0xe3, 0x8e, 0x4d, 0xf8, 0x6c, 0xdd, 0x46, 0x08, 0x48, 0x0c,
	0xfd, 0x73, 0x39, 0x32, 0xed, 0x07, 0x89, 0xbb, 0xeb, 0xd6, 0x70, 0xff, 0x2b, 0x4e, 0x60, 0x07,
	0x6f, 0xf6, 0x3d, 0x88, 0xb7, 0x0c, 0x66, 0xb8, 0xac, 0x9d, 0x93, 0x3d, 0x9c, 0x36, 0x31, 0x60,
	0x09, 0x2d, 0xff, 0xd2, 0x08, 0x99, 0xcf, 0xae, 0x4f, 0xf4, 0x75, 0x32, 0xc1, 0x3f, 0x43, 0x68,
	0xf9, 0xf2, 0x4b, 0x38, 0xc9, 0x97, 0x8d, 0xda, 0xc9, 0xa6, 0x68, 0x0e, 0x8a, 0x0f, 0xfd, 0x69,
	0x32, 0xc5, 0xff, 0x7d, 0x23, 0xac, 0x73, 0x5b, 0x44, 0xae, 0xe0, 0x27, 0x61, 0x8b, 0xb3, 0x75,
	0x53, 0xb3, 0x00, 0x93, 0x1f, 0xfd, 0x2c, 0xa1, 0xc1, 0x0e, 0x57, 0x69, 0x58, 0xfd, 0xba, 0x30,
	0x78, 0xf8, 0x88, 0xf2, 0x69, 0x39, 0xb2, 0x72, 0x49, 0x0e, 0x03, 0xbd, 0xdd, 0x46, 0x01, 0x1d,
	0x5a, 0xd1, 0x9f, 0xcd, 0x11, 0x52, 0x53, 0xcb, 0x1f, 0x57, 0xdd, 0x06, 0xdc, 0x71, 0x3b, 0x2c,
	0xcf, 0x7a, 0x9f, 0x4b, 0x41, 0x31, 0x18, 0x42, 0xcb, 0xff, 0x24, 0x47, 0xce, 0xad, 0xb6, 0xe2,
	0x24, 0x68, 0xca, 0x4f, 0xdd, 0x89, 0x56, 0xf7, 0x9c, 0x28, 0xe1, 0x5f, 0x32, 0x5f, 0x4f, 0x62,
	0x96, 0x64, 0xbf, 0xe4, 0x35, 0x0d, 0x06, 0x93, 0x86, 0x2e, 0x92, 0xdc, 0x7d, 0xf9, 0x15, 0x8f,
	0x1d, 0x1d, 0x96, 0x72, 0xff, 0x3f, 0xe4, 0xee, 0x73, 0xe0, 0x01, 0x8e, 0x8f, 0x04, 0xbe, 0x05,
	0xb9, 0x03, 0x3e, 0x6d, 0x3d, 0xd6, 0x60, 0x7e, 0x1d, 0xbf, 0x2f, 0x39, 0x6d, 0x37, 0x11, 0x02,
	0x12, 0xc3, 0xb5, 0xa0, 0x38, 0x88, 0x12, 0xfc, 0x9c, 0x0a, 0x42, 0x0b, 0xaa, 0xf0, 0xcf, 0x0e,
	0xa1, 0xe5, 0xaf, 0x92, 0xf3, 0x66, 0xb7, 0x6f, 0xb8, 0x71, 0x12, 0x34, 0x22, 0xa7, 0x39, 0xb4,
	0x7e, 0x73, 0x25, 0xcc, 0xf5, 0x63, 0xa9, 0x99, 0x0b, 0x25, 0xcc, 0xf5, 0x63, 0x40, 0x68, 0xf9,
	0x7b, 0x39, 0x5b, 0xfe, 0xa6, 0xeb, 0xb3, 0x9f, 0x8c, 0x71, 0x2b, 0xef, 0x93, 0x47, 0xcc, 0x9e,
	0x55, 0x6a, 0x4e, 0x92, 0xb0, 0x68, 0xdb, 0x0b, 0x4e, 0xb7, 0x6f, 0xe5, 0xef, 0x8d, 0x93, 0x79,
	0x4b, 0x30, 0xdf, 0x0f, 0x62, 0x32, 0xbe, 0xcf, 0xd5, 0xb9, 0xb8, 0x98, 0xc3, 0xd9, 0xfd, 0xda,
	0x00, 0xb3, 0xdb, 0xe0, 0x2d, 0xb4, 0xc9, 0x74, 0x7b, 0xc6, 0x9f, 0x31, 0x48, 0x51, 0x5c, 0x68,
	0xc2, 0x4d, 0x15, 0xb5, 0x07, 0x0e, 0x49, 0x68, 0x95, 0xf3, 0xd4, 0x42, 0xf1, 0x67, 0x0c, 0x52,
	0x14, 0x5f, 0x65, 0x89, 0xa7, 0x66, 0x81, 0xb2, 0x6a, 0x6e, 0x0f, 0x47, 0x72, 0x3a, 0xbb, 0xf4,
	0xe7, 0x9c, 0x82, 0x62, 0x30, 0xc4, 0xd2, 0xaf, 0x91, 0xc9, 0x1d, 0xf9, 0x05, 0xab, 0x05, 0xe5,
	0xd6, 0x70, 0xfa, 0xa0, 0x16, 0x86, 0x95, 0x05, 0xd9, 0x85, 0x49, 0x05, 0x89, 0x41, 0xcb, 0xc4,
	0x61, 0xd8, 0x73, 0xe3, 0x44, 0x76, 0x61, 0x6c, 0x98, 0xc3, 0x90, 0x7e, 0xe4, 0x7a, 0x18, 0x6e,
	0xa4, 0xa2, 0xc0, 0x10, 0x4b, 0xff, 0x52, 0x8e, 0xcc, 0xc4, 0x62, 0xe2, 0xcb, 0x8e, 0x8c, 0x9f,
	0x4e, 0x47, 0x52, 0xd3, 0xaa, 0x62, 0x4a, 0x03, 0x5b, 0x78, 0xf9, 0xfb, 0xdc, 0xdc, 0xce, 0xce,
	0xa4, 0x7e, 0xbe, 0xc6, 0xa7, 0xc9, 0x44, 0x2d, 0xf0, 0x5a, 0x4d, 0x5f, 0x4c, 0xed, 0x49, 0xb1,
	0x07, 0xae, 0x0a, 0x10, 0x28, 0x1c, 0x27, 0x13, 0x8e, 0x22, 0x31, 0x0f, 0x25, 0x99, 0xf0, 0x23,
	0xc5, 0xa0, 0x70, 0x9c, 0xac, 0x11, 0x05, 0xad, 0x70, 0xe7, 0x00, 0xa7, 0x8a, 0x24, 0xbb, 0xce,
	0x41, 0x2b, 0x07, 0xa0, 0x70, 0x7c, 0x25, 0x8c, 0x82, 0x7b, 0x31, 0x2e, 0xc4, 0x72, 0x25, 0x84,
	0xe0, 0x5e, 0x0c, 0x08, 0xa5, 0xcf, 0x91, 0xc9, 0x78, 0x2f, 0xb8, 0x77, 0xd3, 0xaf, 0xb3, 0xfb,
	0x52, 0x09, 0x99, 0xe1, 0xb3, 0xa3, 0xa2, 0x80, 0xa0, 0xf1, 0x7c, 0xfd, 0xda, 0x09, 0xa2, 0x3a,
	0x8b, 0x50, 0x07, 0x91, 0xeb, 0xd7, 0x0a, 0x42, 0x40, 0x62, 0xca, 0x7f, 0x3f, 0x67, 0x0f, 0x16,
	0x7e, 0xdc, 0xfd, 0x0c, 0x56, 0x99, 0x8c, 0x8b, 0x01, 0x91, 0xeb, 0x17, 0x0a, 0x13, 0x63, 0x05,
	0x12, 0x43, 0x2f, 0x92, 0x91, 0x28, 0xb8, 0x27, 0x17, 0xf9, 0x89, 0xa3, 0xc3, 0xd2, 0x08, 0x04,
	0xf7, 0x80, 0xc3, 0x78, 0xf3, 0xb8, 0xe6, 0x78, 0x4e, 0x24, 0x75, 0x40, 0x6c, 0x5e, 0x41, 0x08,
	0x48, 0x4c, 0xf9, 0xaf, 0xa6, 0xdb, 0x40, 0x05, 0x2d, 0x03, 0xc7, 0x73, 0x93, 0x03, 0x5c, 0xf8,
	0x9e, 0x20, 0xa3, 0xbe, 0xee, 0x68, 0x6a, 0xf7, 0x61, 0x2f, 0x11, 0xc3, 0x8d, 0x8d, 0x90, 0x45,
	0x6e, 0x50, 0x97, 0xfe, 0x81, 0x74, 0x61, 0xd9, 0x46, 0x28, 0x48, 0x2c, 0xbd, 0x46, 0xa6, 0x77,
	0x83, 0x56, 0xe4, 0xb2, 0xe8, 0x36, 0x8e, 0xdc, 0x88, 0xf6, 0xf0, 0x6c, 0x18, 0x70, 0xb0, 0xa8,
	0xca, 0xbf, 0x96, 0x23, 0x84, 0x8f, 0xcc, 0x0d, 0x27, 0xde, 0x63, 0x31, 0x5d, 0x22, 0x93, 0x38,
	0xa5, 0xf9, 0x4f, 0xd9, 0x27, 0xe4, 0xa0, 0x3c, 0x57, 0x1c, 0x0e, 0x9a, 0x84, 0x0f, 0x77, 0xc2,
	0xd0, 0xd9, 0x84, 0x2d, 0xf2, 0x7a, 0xb8, 0xab, 0x1a, 0x0c, 0x26, 0x0d, 0x7a, 0x55, 0x53, 0x1f,
	0x0b, 0xb6, 0x12, 0x3b, 0x84, 0xf0, 0xaa, 0x5a, 0x18, 0xc8, 0x50, 0x96, 0x7f, 0x9c, 0x27, 0x93,
	0xbc, 0xb7, 0x95, 0xd0, 0x73, 0x13, 0x3e, 0xe1, 0x9c, 0x56, 0x12, 0x48, 0x27, 0x14, 0x4e, 0xb8,
	0xe5, 0x56, 0x12, 0x00, 0x42, 0xb9, 0xbd, 0x80, 0xfd, 0x94, 0x0e, 0x38, 0xb4, 0x17, 0xf0, 0x31,
	0x40, 0xc0, 0xe9, 0x12, 0x21, 0x9a, 0xbd, 0x1c, 0xae, 0x59, 0xbe, 0x58, 0xe8, 0x4e, 0x80, 0x41,
	0xc1, 0xc5, 0xf1, 0xe7, 0x90, 0xae, 0x33, 0x14, 0xc7, 0x1f, 0x12, 0x10, 0x4a, 0xf7, 0xc9, 0x54,
	0xcc, 0x7b, 0xb5, 0x1d, 0x78, 0x6e, 0xed, 0x40, 0xda, 0x7b, 0x55, 0x3e, 0x12, 0x15, 0x0d, 0x7e,
	0x70, 0x58, 0x5a, 0xee, 0xd7, 0x65, 0x89, 0x6c, 0xd0, 0x8c, 0x36, 0x05, 0xf1, 0x37, 0x80, 0x3f,
	0xc5, 0x84, 0xc5, 0x2f, 0x4b, 0xbe, 0x81, 0x8a, 0x06, 0x83, 0x49, 0x83, 0x1a, 0x13, 0x63, 0x75,
	0xfc, 0xb6, 0xe4, 0x83, 0x54, 0x18, 0xab, 0x03, 0x42, 0xcb, 0xdf, 0xc9, 0x93, 0x19, 0x1c, 0xe3,
	0x93, 0xfa, 0xfb, 0x9e, 0xe6, 0x4a, 0xfa, 0x8e, 0xe1, 0xe7, 0x93, 0x8a, 0x37, 0x82, 0x40, 0xe1,
	0xe8, 0xab, 0x64, 0x9e, 0x7f, 0x7d, 0xa1, 0xf4, 0xf6, 0x22, 0xbd, 0x98, 0x01, 0xe8, 0x19, 0xe7,
	0xa2, 0xb7, 0x0d, 0x1c, 0xb4, 0x51, 0xf3, 0x19, 0x84, 0xdf, 0x6f, 0xd0, 0x8a, 0x6a, 0xa2, 0xfd,
	0xa8, 0x9e, 0x41, 0x6b, 0x16, 0x06, 0x32, 0x94, 0xb8, 0x3e, 0x04, 0xb5, 0xbb, 0x2c, 0xba, 0xd9,
	0x34, 0xcc, 0x72, 0x5c, 0x1f, 0x34, 0x18, 0x4c, 0x9a, 0xf2, 0x5f, 0xcf, 0x13, 0xba, 0xc6, 0x58,
	0x98, 0xfa, 0xd0, 0x36, 0x9d, 0x03, 0x16, 0xf5, 0xf0, 0xe5, 0x5e, 0x95, 0x5e, 0x12, 0x31, 0x1a,
	0x8f, 0x66, 0xbc, 0x24, 0x53, 0xb7, 0x6e, 0x21, 0x23, 0xd1, 0x00, 0x3d, 0x23, 0x3f, 0x63, 0x79,
	0xd6, 0x84, 0x6a, 0x30, 0x80, 0x9b, 0x47, 0x0a, 0x48, 0x1d, 0x66, 0x7a, 0x3b, 0xd4, 0x6e, 0x35,
	0xd3, 0x7f, 0xc6, 0x07, 0xc7, 0xf5, 0xc3, 0x56, 0x82, 0xcd, 0x62, 0xb9, 0xd8, 0xe3, 0xe0, 0xdc,
	0xd4, 0x60, 0x30, 0x69, 0xca, 0x7f, 0x6f, 0x84, 0x2c, 0x58, 0x83, 0x83, 0x33, 0x26, 0x21, 0xe3,
	0x9e, 0xe0, 0x21, 0xd4, 0xb9, 0xcd, 0xfe, 0x1f, 0xa2, 0x7d, 0xe4, 0xf5, 0x0a, 0x28, 0x3b, 0x24,
	0x65, 0xd1, 0xe7, 0xac, 0xf1, 0x7e, 0xc4, 0x1c, 0xeb, 0xb5, 0x5b, 0xb7, 0xf8, 0xbf, 0xc6, 0x58,
	0x3f, 0xc7, 0x35, 0xa0, 0xa4, 0xb6, 0x67, 0xb8, 0xd5, 0x67, 0x84, 0xb6, 0x22, 0x81, 0xa0, 0xf1,
	0x7c, 0x8d, 0x67, 0x61, 0x50, 0xdb, 0x53, 0x7e, 0x73, 0x5c, 0xe3, 0xd7, 0x11, 0x02, 0x12, 0x43,
	0x5f, 0x21, 0x73, 0x7a, 0xb1, 0xc0, 0x6f, 0x4f, 0xee, 0x84, 0xe8, 0xee, 0xbe, 0x63, 0xa3, 0x20,
	0x4b, 0x4b, 0x1f, 0x27, 0x63, 0x6e, 0x5c, 0x61, 0x6f, 0xcb, 0xbd, 0x11, 0xf7, 0x98, 0x0a, 0x7b,
	0x1b, 0x04, 0x94, 0x7f, 0xb3, 0x8d, 0xb0, 0x15, 0x9b, 0xdf, 0xec, 0xf5, 0xb0, 0x15, 0x03, 0x42,
	0xf9, 0x5c, 0xf4, 0x82, 0x38, 0x2e, 0x16, 0xec, 0xb9, 0xb8, 0x19, 0xc4, 0x31, 0x20, 0xa6, 0xfc,
	0x27, 0x79, 0xb2, 0xb8, 0xc6, 0x42, 0x2f, 0x38, 0x68, 0x32, 0x3f, 0x39, 0x6b, 0x5f, 0xfe, 0xcb,
	0x64, 0xb6, 0xe9, 0xf8, 0x2d, 0xc7, 0x5b, 0x0e, 0xf9, 0x9b, 0x77, 0x3c, 0x1c, 0x71, 0x79, 0x92,
	0xb6, 0x65, 0x61, 0x20, 0x43, 0xd9, 0x76, 0x0e, 0x30, 0xfa, 0x1e, 0x3d, 0x07, 0x98, 0x23, 0x33,
	0xe9, 0x69, 0x5f, 0xcb, 0x63, 0x71, 0xf9, 0x23, 0x64, 0x5a, 0x01, 0x2c, 0x77, 0xbe, 0xd0, 0xd8,
	0xb2, 0xee, 0xfc, 0x6f, 0xcf, 0x91, 0x4b, 0xe2, 0xc0, 0x8a, 0xad, 0xfb, 0x0d, 0xd7, 0x67, 0x2c,
	0x72, 0xfd, 0x86, 0x5a, 0x29, 0x7b, 0x58, 0x8d, 0x42, 0x52, 0xe0, 0x6b, 0xa1, 0xf1, 0x85, 0x54,
	0x95, 0xc3, 0x88, 0xaf, 0x99, 0xf2, 0x4b, 0x79, 0xb5, 0xdf, 0xed, 0x49, 0xf1, 0x80, 0x54, 0x8a,
	0xa9, 0x85, 0x8e, 0x1c, 0xa3, 0x85, 0x26, 0x84, 0xb8, 0xcd, 0xb0, 0x95, 0x88, 0x7d, 0x78, 0x34,
	0xdd, 0x38, 0xc9, 0xcd, 0x14, 0xfa, 0xe0, 0xb0, 0xb4, 0xd2, 0x6f, 0xc7, 0x34, 0x17, 0x30, 0xe4,
	0xd0, 0x7b, 0xa4, 0xc0, 0xfc, 0x5a, 0x80, 0xa7, 0x7a, 0xe2, 0x55, 0xfe, 0x19, 0x3e, 0x14, 0xeb,
	0x12, 0xf6, 0xe0, 0xb0, 0xf4, 0x5a, 0xdf, 0x07, 0xa3, 0x4e, 0xc2, 0x1a, 0x41, 0x84, 0xe7, 0x2e,
	0x92, 0x1d, 0xa4, 0xc2, 0xe8, 0x1e, 0x99, 0xe0, 0x5a, 0x21, 0x97, 0x2b, 0x36, 0xeb, 0x5b, 0x78,
	0x9a, 0x28, 0x40, 0x0f, 0x0e, 0x4b, 0x9f, 0xe9, 0x5b, 0x41, 0x10, 0x2c, 0x40, 0xb1, 0xa7, 0xdf,
	0xc8, 0x91, 0xd9, 0xba, 0x1b, 0xd7, 0x22, 0x96, 0xb8, 0xb1, 0x76, 0xe9, 0x4d, 0xae, 0x7c, 0x1e,
	0x37, 0x4a, 0x0b, 0xf3, 0xe0, 0xb0, 0xb4, 0xd1, 0xf7, 0xab, 0xb7, 0x38, 0x41, 0x46, 0x26, 0xfd,
	0xbb, 0x39, 0x72, 0x61, 0xdf, 0x89, 0x5c, 0xbe, 0x92, 0xa0, 0x23, 0x7d, 0x37, 0x88, 0x9a, 0xa2,
	0x3b, 0x62, 0xbd, 0xf2, 0x8e, 0x0e, 0x4b, 0x17, 0xee, 0x74, 0xa4, 0x78, 0x70, 0x58, 0xba, 0xd5,
	0x6f, 0xb7, 0x3a, 0x73, 0x84, 0x2e, 0x7d, 0xa1, 0xdf, 0xca, 0x91, 0xb9, 0xa0, 0x95, 0x78, 0x2e,
	0x8b, 0x6e, 0x38, 0x7e, 0x1d, 0x5f, 0xd0, 0x24, 0xf6, 0xef, 0x0b, 0x7c, 0x8d, 0xbb, 0x6d, 0xa3,
	0x06, 0x39, 0x7c, 0xce, 0xb0, 0x82, 0xac, 0x58, 0x1c, 0xb1, 0xba, 0x93, 0xb0, 0xc4, 0x6d, 0x66,
	0x47, 0x8c, 0xe8, 0x11, 0x5b, 0xeb, 0x48, 0x31, 0xc8, 0x88, 0xf1, 0x6f, 0xb8, 0x9d, 0x23, 0x74,
	0xe9, 0x0b, 0xdd, 0xe3, 0x0a, 0xf1, 0xfd, 0xa4, 0x38, 0x35, 0xe8, 0x79, 0x54, 0x95, 0xdd, 0x4f,
	0xcc, 0xd3, 0x7f, 0xa5, 0x5c, 0xdf, 0x47, 0xe5, 0xfa, 0x7e, 0x42, 0x3d, 0x32, 0xe6, 0xa2, 0xbe,
	0x36, 0x8d, 0xa2, 0x06, 0x70, 0xd4, 0xa0, 0x4a, 0x67, 0xc9, 0x42, 0xc3, 0x40, 0xa8, 0x7d, 0x42,
	0x08, 0x97, 0xe6, 0xb4, 0xea, 0x6e, 0x80, 0xe1, 0x1e, 0x03, 0x49, 0x6b, 0x8b, 0x6b, 0x10, 0xd2,
	0x10, 0x0c, 0x42, 0x08, 0x97, 0xb6, 0xef, 0xd6, 0x59, 0x80, 0xe1, 0x21, 0x03, 0x49, 0xbb, 0xc3,
	0xd9, 0xb4, 0x4b, 0x43, 0x30, 0x08, 0x21, 0xf4, 0x67, 0xc8, 0x64, 0x1a, 0x80, 0x53, 0x9c, 0x1b,
	0xd4, 0x93, 0x7c, 0x5d, 0xb1, 0x12, 0x8b, 0x3a, 0xca, 0x4c, 0xfd, 0x3e, 0x88, 0x64, 0x09, 0xab,
	0x83, 0x16, 0x49, 0x5b, 0x64, 0xbc, 0x86, 0x86, 0x70, 0x71, 0xfe, 0x34, 0x84, 0xa7, 0xaa, 0xa1,
	0xf4, 0x0c, 0x48, 0x61, 0x7c, 0x6f, 0xad, 0x47, 0x41, 0x58, 0x5c, 0xd0, 0xa6, 0xe2, 0x5a, 0x14,
	0x84, 0x80, 0x50, 0x6e, 0x09, 0x86, 0x4e, 0x1c, 0x27, 0x51, 0xd0, 0x6a, 0xec, 0xc9, 0x60, 0x95,
	0x59, 0xa1, 0x27, 0x2b, 0x28, 0x18, 0x14, 0xe5, 0x6f, 0x8c, 0x91, 0x0b, 0xed, 0x7b, 0xf1, 0x49,
	0xf4, 0xa9, 0x3f, 0x9f, 0x23, 0x93, 0xca, 0xa6, 0x51, 0xee, 0xc7, 0x6a, 0xff, 0x43, 0xd1, 0x5d,
	0x31, 0xd0, 0xaf, 0x43, 0x41, 0x62, 0xd0, 0x92, 0xe9, 0x37, 0x73, 0x64, 0x32, 0x66, 0x1e, 0xab,
	0xa5, 0x36, 0xf0, 0x40, 0x8e, 0x40, 0xd9, 0x8f, 0x8a, 0xe2, 0x88, 0xef, 0xa4, 0x28, 0x7b, 0x30,
	0x9f, 0xc5, 0x82, 0x16, 0x4d, 0xbf, 0x4c, 0x26, 0x99, 0xd2, 0xf2, 0xa5, 0x0e, 0x80, 0x91, 0x4a,
	0xa9, 0xea, 0x3f, 0xfc, 0x48, 0xa5, 0x54, 0x1e, 0xb7, 0x05, 0x9a, 0xce, 0x7d, 0xd4, 0x0b, 0x95,
	0xfb, 0x0a, 0x6d, 0x81, 0x2d, 0x05, 0x04, 0x8d, 0xa7, 0x57, 0xc8, 0x44, 0xd3, 0xb9, 0x8f, 0xa7,
	0xcc, 0xe3, 0xda, 0x67, 0xb0, 0x25, 0x40, 0x15, 0x56, 0x03, 0x85, 0xe6, 0xe6, 0x14, 0xff, 0x97,
	0x8f, 0x12, 0x37, 0x85, 0x84, 0xea, 0x8e, 0xe6, 0xd4, 0x96, 0x06, 0x83, 0x49, 0x83, 0x5e, 0x32,
	0xa7, 0x19, 0x7a, 0x6c, 0xbb, 0x96, 0xe0, 0xee, 0x28, 0x7b, 0x52, 0x51, 0x40, 0xd0, 0xf8, 0xf2,
	0xaf, 0xe5, 0x48, 0xb1, 0xc3, 0x34, 0x14, 0x47, 0x66, 0xdf, 0xc9, 0x91, 0xe9, 0x1d, 0x16, 0xa7,
	0xeb, 0xaa, 0x3c, 0x38, 0x3b, 0x9d, 0x49, 0x96, 0x1e, 0xec, 0xad, 0x18, 0x12, 0xc1, 0x92, 0x5f,
	0x8e, 0xc8, 0x82, 0xe4, 0x70, 0xb3, 0x19, 0x06, 0x51, 0xe2, 0xf8, 0x35, 0x46, 0x9f, 0x25, 0x13,
	0x22, 0xf2, 0x2a, 0x75, 0xd5, 0xa9, 0x13, 0x72, 0x49, 0x0b, 0x0a, 0x4f, 0x5f, 0x40, 0x35, 0x51,
	0x36, 0x94, 0xbe, 0xb0, 0xd4, 0xa0, 0xd5, 0x2c, 0xc1, 0xa0, 0x2a, 0x7f, 0x85, 0x4c, 0x29, 0x99,
	0xfe, 0x6e, 0xd0, 0x9b, 0xb3, 0x4d, 0x9e, 0xec, 0xe7, 0x8f, 0x3d, 0xd9, 0x7f, 0x92, 0x8c, 0xe1,
	0x21, 0x02, 0x7e, 0x32, 0x39, 0x7d, 0xee, 0x2d, 0x62, 0x52, 0x04, 0xae, 0xfc, 0x87, 0x79, 0x72,
	0xae, 0xd3, 0x17, 0xd1, 0xeb, 0x22, 0xb1, 0x4e, 0x16, 0xbc, 0xe0, 0xde, 0x1d, 0x27, 0xaa, 0x46,
	0x2c, 0xde, 0x0b, 0xbc, 0x3a, 0x9f, 0x14, 0xc2, 0x9b, 0xc5, 0x8d, 0xdb, 0x45, 0x54, 0x70, 0xfc,
	0x1a, 0x33, 0xd0, 0xd0, 0xde, 0x82, 0x5e, 0x23, 0xd3, 0xb5, 0x20, 0x4a, 0x41, 0xa6, 0x63, 0x70,
	0xd5, 0x80, 0x83, 0x45, 0x85, 0xde, 0xae, 0x20, 0xbc, 0x65, 0x79, 0xbb, 0x82, 0xf0, 0x16, 0x20,
	0x94, 0x3a, 0xe4, 0xd1, 0x5a, 0xab, 0xd9, 0xf2, 0x9c, 0xc4, 0xdd, 0x37, 0xde, 0xe7, 0x76, 0xc4,
	0x6a, 0xcc, 0x57, 0x86, 0x6f, 0xe9, 0xe8, 0xb0, 0xf4, 0xe8, 0x6a, 0x77, 0x32, 0x38, 0x8e, 0x07,
	0xbd, 0x42, 0x0a, 0x11, 0x13, 0x67, 0xa1, 0xe8, 0x95, 0x9f, 0x5c, 0x99, 0xe6, 0x0a, 0x3a, 0x48,
	0x18, 0xa4, 0xd8, 0xf2, 0x17, 0xc9, 0x94, 0x0a, 0x86, 0xbb, 0xbd, 0xf3, 0x25, 0xfa, 0x38, 0x19,
	0xb9, 0xcb, 0x0e, 0xe4, 0x4b, 0x9e, 0x92, 0x6f, 0x66, 0xe4, 0x35, 0x76, 0x00, 0x1c, 0xce, 0xe7,
	0x91, 0xc7, 0xf6, 0x99, 0x27, 0x3c, 0xd1, 0x62, 0x38, 0xf5, 0x71, 0x49, 0x8a, 0x01, 0x83, 0xaa,
	0xfc, 0x73, 0x39, 0x72, 0x49, 0x89, 0xd8, 0x0e, 0xe2, 0x64, 0x3b, 0x0a, 0x6a, 0x2c, 0x8e, 0xd5,
	0xa2, 0xff, 0x32, 0x99, 0xad, 0x05, 0xbe, 0x2f, 0xde, 0xb0, 0xe1, 0x77, 0x46, 0xf3, 0x76, 0xd5,
	0xc2, 0x40, 0x86, 0x92, 0x3f, 0xa6, 0x0a, 0xd9, 0xc3, 0xce, 0x14, 0xc4, 0x63, 0x2a, 0x69, 0x90,
	0x62, 0xcb, 0xff, 0x78, 0x94, 0x4c, 0x2b, 0x30, 0x8a, 0xf5, 0xc9, 0xa8, 0x11, 0x1c, 0x32, 0x80,
	0x8f, 0x45, 0xac, 0x5c, 0x91, 0xcb, 0x62, 0xe1, 0x5c, 0x35, 0x23, 0x90, 0x38, 0x04, 0x50, 0x0e,
	0xdd, 0x20, 0xb4, 0x16, 0xf8, 0xbb, 0x6e, 0x9d, 0xf9, 0x35, 0x76, 0xd3, 0x4f, 0x58, 0xc4, 0x2d,
	0x79, 0x23, 0xbe, 0x71, 0xb5, 0x0d, 0x0b, 0x1d, 0x5a, 0xd0, 0x84, 0x14, 0x76, 0x64, 0x7c, 0xa5,
	0xdc, 0x72, 0x36, 0xfa, 0xef, 0xbb, 0x19, 0xa9, 0xa9, 0x43, 0x20, 0x14, 0x14, 0x52, 0x49, 0xf4,
	0x97, 0x72, 0x64, 0x36, 0xb4, 0xde, 0x1d, 0xce, 0xed, 0xc1, 0x96, 0xc4, 0xae, 0x73, 0x62, 0xe5,
	0x82, 0xec, 0xca, 0xac, 0xc0, 0x31, 0x89, 0x83, 0x4c, 0x1f, 0xf8, 0x77, 0x16, 0x7a, 0x81, 0x75,
	0x7c, 0xbd, 0xed, 0x05, 0x09, 0x20, 0x94, 0xbe, 0x4a, 0xe6, 0xf9, 0x5f, 0x23, 0x80, 0x30, 0x96,
	0x0e, 0x22, 0x74, 0x96, 0x6e, 0x67, 0x70, 0xd0, 0x46, 0x5d, 0x9e, 0x26, 0x64, 0x03, 0x35, 0x76,
	0xde, 0xab, 0xf2, 0xdf, 0xce, 0x93, 0xc5, 0x0e, 0x7a, 0x13, 0xef, 0x85, 0xb1, 0x32, 0x16, 0xde,
	0x75, 0xd7, 0xc1, 0x93, 0x64, 0x6c, 0xd7, 0x8d, 0xe4, 0xfc, 0x98, 0xd4, 0xeb, 0xeb, 0x06, 0x07,
	0x82, 0xc0, 0xf1, 0xc5, 0x3a, 0x66, 0xb5, 0x40, 0x9e, 0x72, 0x1b, 0x8b, 0x75, 0x05, 0xa1, 0x20,
	0xb1, 0x74, 0x89, 0x14, 0x82, 0xc8, 0x6d, 0xb8, 0xbe, 0xe3, 0x49, 0x53, 0x3f, 0xfd, 0xde, 0xd7,
	0xef, 0x87, 0x11, 0x7f, 0x11, 0x81, 0x0f, 0x29, 0x4d, 0xf9, 0x87, 0x79, 0x32, 0x79, 0xc3, 0x65,
	0x91, 0x13, 0xd5, 0xf6, 0x0e, 0x4c, 0x2f, 0x46, 0xee, 0x18, 0x2f, 0xc6, 0x3e, 0x99, 0xc2, 0x83,
	0x30, 0x5c, 0x41, 0x94, 0x4a, 0xf7, 0x99, 0xfe, 0xa7, 0x16, 0xf2, 0xd1, 0xbe, 0xa9, 0xeb, 0x9a,
	0x37, 0x98, 0x82, 0xa8, 0x47, 0x26, 0xdd, 0x84, 0x35, 0xf1, 0x97, 0xfc, 0x9a, 0x06, 0x96, 0x8a,
	0x2a, 0xc7, 0x4d, 0xc5, 0x15, 0xb4, 0x00, 0xbe, 0x97, 0x88, 0x68, 0x1d, 0xe1, 0xb7, 0x96, 0x03,
	0x3f, 0xaf, 0x63, 0x7a, 0xa4, 0x3f, 0xdb, 0xa2, 0x2a, 0xff, 0x51, 0x8e, 0x4c, 0xdd, 0x08, 0x3c,
	0xb7, 0xee, 0x88, 0x43, 0xaf, 0x17, 0xc9, 0xcc, 0x9e, 0xf8, 0x29, 0x4f, 0x2d, 0xc4, 0xb4, 0x5b,
	0x38, 0x3a, 0x2c, 0xcd, 0xdc, 0x30, 0x11, 0x60, 0xd3, 0xd1, 0x80, 0xbf, 0x8b, 0x96, 0x9f, 0x44,
	0x07, 0x72, 0x1e, 0xbe, 0x21, 0xde, 0x05, 0x82, 0x06, 0x71, 0x61, 0xa4, 0x52, 0x91, 0x13, 0x28,
	0x29, 0xd9, 0xe3, 0xc4, 0x91, 0x87, 0x1f, 0x27, 0x96, 0x3f, 0x4f, 0x3a, 0xc5, 0xa9, 0xf6, 0xa0,
	0x7b, 0xa4, 0x3a, 0x45, 0xde, 0x9e, 0xf3, 0x96, 0x4e, 0xf1, 0x9d, 0x1c, 0x59, 0x68, 0xb3, 0x61,
	0x4f, 0x3b, 0x5a, 0x1e, 0x05, 0x76, 0x89, 0x96, 0xff, 0x61, 0x9e, 0x8c, 0x89, 0xb9, 0xf1, 0x14,
	0x19, 0x8f, 0x93, 0x48, 0x45, 0xc9, 0x67, 0x9f, 0x51, 0xe2, 0xb8, 0xc6, 0xb7, 0x17, 0x44, 0xee,
	0x3b, 0x81, 0x3a, 0x98, 0x4b, 0x35, 0xbe, 0x1b, 0x02, 0x0c, 0x0a, 0x4f, 0x3f, 0x4f, 0x46, 0x77,
	0x23, 0xf6, 0xb6, 0x1c, 0xf5, 0x1b, 0x9c, 0xd5, 0x46, 0xc4, 0xde, 0x7e, 0x70, 0x58, 0xfa, 0x54,
	0xbf, 0x4f, 0xc2, 0xdb, 0x03, 0x72, 0xa5, 0x21, 0x99, 0x74, 0x1a, 0x8d, 0x88, 0x35, 0x9c, 0x44,
	0xcd, 0x63, 0xc0, 0xd4, 0x12, 0x05, 0x1c, 0xe4, 0xb0, 0x2e, 0x65, 0x02, 0x5a, 0x08, 0x7d, 0x8a,
	0x4c, 0xd4, 0xdd, 0x38, 0x71, 0xfd, 0x1a, 0xc6, 0x3b, 0xc8, 0xa3, 0x62, 0x19, 0x94, 0xa2, 0x50,
	0xe5, 0xdf, 0xc8, 0x93, 0x31, 0x34, 0x35, 0xce, 0x20, 0x7e, 0x99, 0x59, 0xf1, 0xcb, 0xab, 0x03,
	0xfa, 0xd4, 0xbb, 0x86, 0x2e, 0x37, 0x33, 0xa1, 0xcb, 0xeb, 0x83, 0x0a, 0x3a, 0x3e, 0x6a, 0xf9,
	0xf7, 0xf3, 0x64, 0x1e, 0xe9, 0x96, 0x5b, 0x49, 0xb0, 0xd3, 0x72, 0xbd, 0x3a, 0x8b, 0xce, 0x60,
	0x30, 0x43, 0x6b, 0x30, 0x6f, 0x0d, 0xf8, 0x8c, 0x46, 0xdf, 0xbb, 0x8e, 0xeb, 0xfd, 0xcc, 0xb8,
	0x6e, 0x0f, 0x51, 0xe6, 0xf1, 0x43, 0xfc, 0x3f, 0xf2, 0xe4, 0x62, 0xb6, 0x89, 0x0e, 0x0f, 0x5f,
	0xb6, 0xc2, 0xc3, 0x3f, 0x9a, 0x39, 0xf8, 0x7c, 0xbc, 0x6b, 0xc3, 0x33, 0x0e, 0x12, 0x1f, 0x3d,
	0xa3, 0x20, 0xf1, 0xb1, 0x5e, 0x83, 0xc4, 0xc7, 0x1f, 0x12, 0x24, 0xfe, 0x87, 0x39, 0x72, 0x2e,
	0x3b, 0x78, 0x67, 0x10, 0x2a, 0x1e, 0xd8, 0xa1, 0xe2, 0x9f, 0x1d, 0xde, 0x2c, 0xeb, 0x12, 0x30,
	0xfe, 0xab, 0xa4, 0xfd, 0x39, 0x71, 0x9f, 0x7b, 0x85, 0xcc, 0xf1, 0x1e, 0x6d, 0x47, 0x41, 0xbd,
	0x55, 0x33, 0x23, 0x7c, 0xf0, 0x18, 0x72, 0xcd, 0x46, 0x41, 0x96, 0x96, 0x02, 0xba, 0xd5, 0x15,
	0xc8, 0x88, 0x34, 0x97, 0x93, 0xec, 0x92, 0x74, 0xab, 0x77, 0xa0, 0x80, 0x2e, 0x2d, 0x3b, 0x04,
	0x23, 0x8c, 0xd8, 0xc1, 0x08, 0x95, 0xe3, 0x83, 0x11, 0x0c, 0xed, 0x62, 0xb4, 0x87, 0x60, 0x25,
	0x8f, 0x14, 0xbc, 0x40, 0xc6, 0x67, 0x8b, 0x00, 0xf2, 0x95, 0x5e, 0x5f, 0x07, 0x67, 0xb3, 0x64,
	0x29, 0xdd, 0x9b, 0x92, 0x93, 0x30, 0x39, 0xd5, 0x2f, 0x48, 0x25, 0xd0, 0x2f, 0x90, 0xd1, 0xc4,
	0x89, 0xef, 0xca, 0x89, 0xf9, 0x59, 0xfc, 0x88, 0x9d, 0xf8, 0xee, 0x83, 0xc3, 0xd2, 0xa7, 0xfb,
	0xdd, 0x19, 0xb7, 0x36, 0x39, 0x07, 0x40, 0xbe, 0xb4, 0x49, 0x26, 0x03, 0x5c, 0x4a, 0xdd, 0x7d,
	0x26, 0xcf, 0xa6, 0x6e, 0xf3, 0x3d, 0xf8, 0xb6, 0x02, 0x0e, 0x24, 0x89, 0x25, 0x91, 0x5b, 0x03,
	0x2d, 0x81, 0x6b, 0xaf, 0x89, 0x13, 0x35, 0x98, 0x0a, 0x96, 0x29, 0x18, 0x01, 0x4e, 0x06, 0x1c,
	0x2c, 0x2a, 0x6e, 0x00, 0x28, 0x87, 0xdf, 0x24, 0x6a, 0x2c, 0x68, 0x00, 0x48, 0x87, 0x9f, 0xf6,
	0xf6, 0x59, 0x4e, 0x44, 0xf2, 0x10, 0x27, 0xe2, 0x3b, 0x64, 0xda, 0xa9, 0x71, 0x13, 0x70, 0x8b,
	0x25, 0x7b, 0x41, 0x1d, 0x8f, 0x50, 0x26, 0x57, 0xee, 0xf0, 0x9e, 0x2c, 0x1b, 0xf0, 0x41, 0xce,
	0x3d, 0x05, 0x1f, 0x5c, 0x52, 0x2d, 0x59, 0xbc, 0xa3, 0x4e, 0x2b, 0x09, 0x2a, 0x35, 0xc7, 0x13,
	0x07, 0x2a, 0x32, 0x12, 0x6f, 0x59, 0x01, 0x41, 0xe3, 0xe9, 0xd7, 0x73, 0x62, 0x7e, 0x8b, 0x59,
	0xcc, 0x3f, 0x42, 0x79, 0x2a, 0xb2, 0xd6, 0xff, 0xb4, 0xd3, 0xbc, 0xb2, 0x5f, 0x09, 0xee, 0x6d,
	0x19, 0x79, 0xf4, 0x0a, 0x29, 0x24, 0xca, 0x87, 0x3a, 0x8b, 0xe3, 0x8a, 0xd3, 0x35, 0x75, 0xa0,
	0xa6, 0x58, 0x7a, 0x8d, 0x4c, 0x08, 0xef, 0x68, 0x54, 0x9c, 0x4b, 0x3f, 0xe8, 0x09, 0xe1, 0x3b,
	0xe5, 0x0a, 0xf0, 0x94, 0xfc, 0x57, 0x04, 0x24, 0x49, 0x52, 0xfe, 0x7e, 0x9d, 0x9d, 0x20, 0x4a,
	0x58, 0x1d, 0x33, 0x6d, 0xa5, 0x37, 0x6e, 0x59, 0x80, 0x40, 0xe1, 0x74, 0xfe, 0xc9, 0x42, 0x97,
	0xfc, 0x93, 0x2b, 0xa4, 0xa0, 0x4e, 0xfd, 0xf1, 0x0c, 0x41, 0x3a, 0xac, 0x54, 0x70, 0x00, 0xa4,
	0x58, 0x7a, 0x9d, 0x8c, 0x7b, 0xce, 0x0e, 0xb0, 0xdd, 0xe2, 0x22, 0x8e, 0xe5, 0x93, 0xc6, 0x62,
	0xbd, 0xc4, 0xf7, 0x32, 0xad, 0x77, 0x00, 0xdb, 0x65, 0x11, 0xf3, 0x6b, 0x4c, 0xc6, 0x70, 0x63,
	0x33, 0x90, 0xcd, 0xcb, 0xff, 0x94, 0x90, 0x0b, 0x9d, 0x77, 0x6e, 0xfa, 0x12, 0x99, 0xde, 0xf5,
	0x9c, 0x64, 0xc3, 0xf5, 0x98, 0xb1, 0x4e, 0xa6, 0x8e, 0xda, 0x0d, 0x03, 0x07, 0x16, 0x25, 0xfd,
	0xb4, 0xf9, 0xc6, 0x8d, 0xd5, 0x31, 0xf5, 0x68, 0x74, 0x5a, 0xd5, 0xf4, 0x6f, 0xfa, 0xf1, 0x4e,
	0x36, 0x53, 0x6a, 0xc8, 0x76, 0x5d, 0xd9, 0xae, 0x92, 0xc9, 0x38, 0x69, 0xd5, 0x0f, 0x8c, 0xa5,
	0x30, 0x3d, 0xbb, 0xa8, 0x28, 0x04, 0x68, 0x1a, 0xfa, 0x49, 0x32, 0xb3, 0xc3, 0xe2, 0x04, 0x9f,
	0x1f, 0x1b, 0x8d, 0xdb, 0x59, 0x8c, 0x2b, 0x26, 0x12, 0x6c, 0x5a, 0xde, 0x38, 0x8c, 0x58, 0xdd,
	0xad, 0xc9, 0xe3, 0x00, 0xb9, 0xfa, 0xa4, 0x8d, 0xb7, 0x4d, 0x24, 0xd8, 0xb4, 0xbc, 0x31, 0x9e,
	0x14, 0x02, 0x0b, 0x03, 0x6c, 0x5c, 0xb0, 0x1b, 0xdf, 0x34, 0x91, 0x60, 0xd3, 0xd2, 0x4f, 0x91,
	0xb1, 0x70, 0xcf, 0x89, 0x99, 0x3c, 0x5c, 0x7e, 0x46, 0xed, 0x80, 0xdb, 0x1c, 0xf8, 0xe0, 0xb0,
	0x74, 0x3e, 0xfb, 0x42, 0x11, 0x01, 0xa2, 0x11, 0x37, 0x23, 0x31, 0xc8, 0x56, 0x2c, 0x30, 0xa9,
	0x52, 0x68, 0x04, 0xda, 0x3e, 0x41, 0x46, 0x6b, 0x81, 0x17, 0xe3, 0x92, 0x62, 0x50, 0xac, 0x06,
	0x5e, 0x0c, 0x88, 0xa1, 0x1f, 0x21, 0x85, 0x5d, 0xd7, 0x63, 0x18, 0xf9, 0x34, 0x2d, 0x9c, 0xc1,
	0x6a, 0xf7, 0xdf, 0x90, 0x70, 0x48, 0x29, 0xb8, 0x1e, 0xd3, 0x14, 0x8b, 0xda, 0x8c, 0x38, 0xee,
	0x50, 0x7a, 0x8c, 0x5c, 0xd5, 0x24, 0x96, 0x0f, 0x8a, 0xf8, 0x10, 0xeb, 0x72, 0x0d, 0x14, 0xdf,
	0x6a, 0x3a, 0x28, 0x55, 0x13, 0x09, 0x36, 0x2d, 0x9f, 0x73, 0xe9, 0xfb, 0xa9, 0xf0, 0x2f, 0x00,
	0x3f, 0xe0, 0x9c, 0x9e, 0x73, 0x2b, 0x16, 0x16, 0x32, 0xd4, 0xf4, 0xab, 0xe6, 0xf1, 0xd1, 0xfc,
	0xa0, 0xca, 0x70, 0xe7, 0xb4, 0x59, 0xb1, 0x4a, 0xa6, 0x20, 0xf3, 0x00, 0xe9, 0x4d, 0x3e, 0x77,
	0x9d, 0x28, 0xc1, 0x4d, 0x62, 0xe1, 0xc4, 0x6a, 0xa5, 0x38, 0xe2, 0x51, 0x0c, 0x40, 0xf3, 0xa2,
	0xaf, 0x93, 0x09, 0xe6, 0xd7, 0x91, 0x2d, 0xed, 0x2f, 0xf1, 0x69, 0x5d, 0x34, 0x07, 0xc5, 0xa7,
	0x4b, 0x66, 0xd2, 0x62, 0x5f, 0x99, 0x49, 0x57, 0xc9, 0x24, 0xd7, 0x7c, 0xd7, 0xa3, 0x28, 0x88,
	0x8a, 0xe7, 0xec, 0x6f, 0x76, 0x53, 0x21, 0x40, 0xd3, 0xd0, 0xbf, 0x60, 0xa7, 0x32, 0x9d, 0x47,
	0x85, 0xb2, 0x32, 0x3c, 0x85, 0xb2, 0xf7, 0x84, 0xa6, 0xd4, 0x48, 0x5c, 0x0d, 0x9a, 0xa1, 0xeb,
	0xb1, 0x08, 0x5a, 0xfe, 0x7b, 0xce, 0x48, 0x34, 0xfa, 0x7e, 0x66, 0x46, 0xa2, 0x29, 0xb3, 0x47,
	0x23, 0xd1, 0x68, 0x72, 0x32, 0x23, 0xb1, 0x53, 0xc3, 0xf7, 0x8d, 0xc4, 0x1e, 0x8d, 0x44, 0x63,
	0xf0, 0xde, 0x7b, 0x46, 0xa2, 0xd1, 0xf9, 0x2e, 0x46, 0xe2, 0xdf, 0x1c, 0x6d, 0x7f, 0xce, 0x7e,
	0x73, 0x8b, 0xb9, 0x21, 0xc6, 0xe2, 0x5a, 0xe4, 0x86, 0xb8, 0x18, 0x1a, 0x69, 0x0c, 0x6b, 0x1a,
	0x0c, 0x26, 0x0d, 0xaa, 0xfb, 0xa9, 0xe6, 0x21, 0x4f, 0x29, 0x50, 0xdd, 0x4f, 0x35, 0x0e, 0x8d,
	0xd7, 0xba, 0xe3, 0x68, 0x17, 0xdd, 0xf1, 0x6d, 0x52, 0x08, 0x23, 0x37, 0x88, 0xdc, 0x44, 0xa5,
	0x0e, 0xbc, 0xc1, 0xc7, 0x79, 0x5b, 0xc2, 0x1e, 0x1c, 0x96, 0xd6, 0xfb, 0xb5, 0x03, 0x14, 0x0f,
	0xe1, 0xcb, 0x4f, 0xc5, 0xd0, 0x90, 0x14, 0x6a, 0x72, 0xe4, 0xe4, 0x9c, 0xaa, 0x72, 0x91, 0x6a,
	0x34, 0x1f, 0x1c, 0x96, 0xd6, 0xfa, 0x8e, 0xb7, 0x90, 0x3c, 0x70, 0x18, 0x52, 0x29, 0xd4, 0x23,
	0xe3, 0xc2, 0xb0, 0x92, 0xca, 0x56, 0x55, 0xa4, 0xc7, 0x71, 0xc8, 0x40, 0xbe, 0x7b, 0x27, 0xaa,
	0xdf, 0x73, 0x22, 0x26, 0x38, 0x81, 0x94, 0x51, 0xfe, 0xe3, 0x51, 0xa9, 0x1b, 0xb7, 0x2d, 0x58,
	0xf6, 0x76, 0x3d, 0x33, 0xc4, 0xed, 0x7a, 0x97, 0xcc, 0xf2, 0xa7, 0xf5, 0x58, 0xba, 0x7c, 0xcc,
	0x9e, 0x98, 0xbb, 0x3c, 0x34, 0x36, 0xb9, 0x40, 0x86, 0x2b, 0xbd, 0xa6, 0x74, 0x48, 0x61, 0xe6,
	0x5c, 0xce, 0xea, 0x90, 0x33, 0xea, 0x99, 0x2d, 0xdd, 0xb1, 0xf3, 0xce, 0x3f, 0xdf, 0xd7, 0xce,
	0xff, 0x31, 0x32, 0xc5, 0xf6, 0x1d, 0x4f, 0xd8, 0xd8, 0xb1, 0xb4, 0x89, 0xd2, 0xd5, 0x6b, 0x23,
	0xe0, 0x9b, 0x31, 0x98, 0x24, 0xb6, 0xae, 0x40, 0x7b, 0xd0, 0x15, 0xae, 0xf0, 0x6f, 0x22, 0x68,
	0x44, 0x2c, 0x8e, 0x51, 0x3d, 0x91, 0x76, 0xdf, 0xb6, 0x84, 0x41, 0x8a, 0xcd, 0x6a, 0x15, 0xe7,
	0x86, 0xa2, 0x55, 0x74, 0xda, 0x7b, 0x1e, 0xaa, 0x55, 0xfc, 0x5e, 0x9e, 0xcc, 0xca, 0xd6, 0x6a,
	0x9f, 0xfb, 0x29, 0x6b, 0x9f, 0x2b, 0x67, 0xf6, 0x39, 0x6a, 0x53, 0xbf, 0xbf, 0xb9, 0x1d, 0xbf,
	0xb9, 0xfd, 0xc3, 0x9c, 0x1c, 0x5f, 0x34, 0xb1, 0x70, 0xb9, 0x2f, 0x91, 0x31, 0x76, 0xdf, 0x8d,
	0x13, 0x19, 0x4a, 0x83, 0x6b, 0xeb, 0x3a, 0x07, 0x80, 0x80, 0xf3, 0x95, 0x1a, 0x2d, 0x30, 0xc3,
	0x94, 0x15, 0x07, 0x9c, 0x0a, 0x08, 0x1a, 0x4f, 0x6f, 0x91, 0x0b, 0x11, 0x6b, 0xb8, 0x71, 0x12,
	0x1d, 0xd8, 0x81, 0x1b, 0x72, 0x8d, 0xc7, 0xe7, 0x87, 0x36, 0x0a, 0xe8, 0xd2, 0xaa, 0xfc, 0xaf,
	0x73, 0x44, 0x6c, 0x09, 0x67, 0xb0, 0x05, 0xd7, 0xed, 0x2d, 0xf8, 0x33, 0x03, 0x7e, 0x00, 0x5d,
	0xf6, 0xdd, 0x7f, 0x9f, 0x27, 0x33, 0x88, 0x4f, 0x73, 0x0f, 0x4e, 0x5f, 0x6b, 0x6e, 0x5a, 0x5a,
	0xf3, 0x6b, 0x03, 0x3e, 0x98, 0x15, 0x22, 0xdb, 0x49, 0x65, 0x6e, 0x65, 0x54, 0xe6, 0xad, 0x61,
	0x09, 0x3c, 0x5e, 0x5f, 0xfe, 0x2f, 0x79, 0xb9, 0x63, 0x29, 0x7a, 0xbd, 0x88, 0x7c, 0xda, 0x5a,
	0x44, 0x3e, 0x9c, 0x59, 0x44, 0x2e, 0x75, 0x6e, 0xf5, 0x7e, 0xcd, 0x9d, 0xe3, 0x17, 0x93, 0x1f,
	0xe5, 0xc8, 0x82, 0x35, 0x72, 0x67, 0xf0, 0x8d, 0x7a, 0xf6, 0x37, 0x7a, 0x7d, 0x48, 0x33, 0xab,
	0xcb, 0xb7, 0x9a, 0x1a, 0xb9, 0x69, 0x4c, 0xe6, 0x7b, 0xd0, 0xc8, 0x35, 0xfa, 0x7e, 0x66, 0x46,
	0xae, 0x29, 0xf3, 0xf8, 0x8f, 0xf6, 0xbf, 0x2a, 0x23, 0xd7, 0x68, 0xa2, 0xbf, 0xdb, 0x4f, 0x59,
	0xdf, 0xed, 0x95, 0xcc, 0x77, 0x5b, 0xec, 0xd4, 0xe6, 0x7d, 0x15, 0xa0, 0x47, 0xfb, 0xd6, 0x18,
	0xbc, 0xf7, 0x9e, 0x7d, 0x6b, 0x74, 0xbe, 0xcb, 0xb7, 0xfb, 0xbb, 0x23, 0xed, 0xcf, 0x79, 0x86,
	0xf6, 0xed, 0x47, 0x3b, 0x79, 0xf1, 0xd1, 0xa3, 0x28, 0x3d, 0xf8, 0xb6, 0xf7, 0xfe, 0x1a, 0x99,
	0xb6, 0x32, 0xba, 0x8d, 0xc0, 0x30, 0x2b, 0x9b, 0xdb, 0xa2, 0xd2, 0x76, 0xf1, 0x58, 0x0f, 0x76,
	0xf1, 0xf8, 0xd9, 0xd8, 0xc5, 0xba, 0x54, 0xd6, 0x44, 0xd7, 0x52, 0x59, 0xc6, 0x91, 0x51, 0xe1,
	0x98, 0x23, 0xa3, 0x8b, 0x64, 0x24, 0x49, 0x3c, 0x79, 0x6a, 0x88, 0x19, 0xbd, 0xd5, 0xea, 0x26,
	0x70, 0x58, 0xf9, 0xc7, 0xa3, 0xe4, 0xd1, 0x0e, 0x2b, 0x4d, 0x43, 0xea, 0x08, 0xf4, 0x45, 0x65,
	0xe1, 0x89, 0xd7, 0xfb, 0xc1, 0xac, 0x85, 0x37, 0x6f, 0x10, 0x5b, 0x46, 0xde, 0x47, 0x48, 0xc1,
	0xc1, 0xd4, 0x59, 0x59, 0xd4, 0xaa, 0xa0, 0x67, 0xf5, 0xb2, 0x84, 0x43, 0x4a, 0x41, 0x5f, 0x20,
	0x44, 0xfd, 0xbf, 0xa2, 0x4a, 0xf5, 0xa4, 0x6b, 0xfb, 0x72, 0x8a, 0x01, 0x83, 0x8a, 0x7e, 0x4e,
	0xb7, 0x59, 0x4e, 0xfa, 0x58, 0x3f, 0x66, 0x4d, 0xde, 0xcb, 0x09, 0x18, 0xdc, 0x6c, 0xcb, 0x7c,
	0xe2, 0x74, 0x1c, 0xe9, 0x85, 0x21, 0x39, 0xd2, 0xdf, 0x21, 0x13, 0x11, 0x8b, 0x5b, 0x5e, 0x12,
	0x17, 0x27, 0x07, 0xad, 0x1a, 0x93, 0xc9, 0x49, 0x06, 0xe4, 0xab, 0x17, 0x41, 0xf1, 0x3b, 0x06,
	0x25, 0x90, 0x3e, 0x49, 0xc6, 0x18, 0x1a, 0xd2, 0xc4, 0x8e, 0x15, 0x14, 0x46, 0xb4, 0xc0, 0x95,
	0xff, 0x78, 0x3e, 0xa3, 0x4f, 0x6a, 0x0f, 0xc8, 0x27, 0xc8, 0x58, 0xcc, 0x27, 0x90, 0x9c, 0x5e,
	0x4f, 0xaa, 0xf6, 0x38, 0xab, 0x52, 0xb3, 0xd4, 0xd0, 0x5b, 0x1b, 0x0c, 0x44, 0x8b, 0xec, 0xf1,
	0x5e, 0xbe, 0x9f, 0xe3, 0xbd, 0x91, 0x1e, 0x8e, 0xf7, 0xae, 0x9a, 0x0e, 0xb6, 0xcc, 0x79, 0x60,
	0x47, 0x27, 0xdb, 0xb7, 0x73, 0x84, 0xd4, 0x45, 0xe1, 0x0a, 0xbe, 0x65, 0x8a, 0xe8, 0x88, 0x37,
	0x86, 0xaa, 0x08, 0xa8, 0x2f, 0x4e, 0x7f, 0x23, 0x6b, 0xa9, 0x40, 0x30, 0x84, 0xd3, 0x5f, 0xce,
	0x91, 0x59, 0xc5, 0x51, 0xf6, 0x67, 0xfc, 0x34, 0xfb, 0x93, 0x9e, 0x93, 0x55, 0x2d, 0xa1, 0x90,
	0xe9, 0x04, 0xe6, 0x7b, 0xb5, 0x1c, 0x59, 0x56, 0x4f, 0x7e, 0x60, 0xa7, 0xd4, 0xa5, 0xf4, 0x65,
	0xbd, 0xb1, 0x5c, 0x95, 0xbd, 0xd1, 0xa2, 0x71, 0x80, 0x6a, 0xba, 0xb2, 0x30, 0xef, 0x4d, 0xe1,
	0x4c, 0x06, 0x68, 0xd5, 0x12, 0x0a, 0x99, 0x4e, 0xd0, 0xbf, 0x91, 0x23, 0xf3, 0x75, 0xb3, 0x4e,
	0x02, 0xef, 0xd9, 0xe4, 0x69, 0xf6, 0x2c, 0x4d, 0x8f, 0x5b, 0xcb, 0x88, 0x85, 0xb6, 0x8e, 0xd0,
	0x5f, 0xcc, 0x91, 0x99, 0x88, 0x79, 0xcc, 0x89, 0x65, 0x6b, 0xfc, 0xfe, 0x4f, 0xad, 0x6b, 0xe9,
	0xd9, 0x2d, 0x98, 0x32, 0xc1, 0xee, 0x02, 0x0e, 0x59, 0x33, 0xf0, 0xdd, 0x24, 0xd0, 0xe9, 0x67,
	0x32, 0x27, 0xf8, 0xb4, 0x87, 0x6c, 0x2b, 0x23, 0x16, 0xda, 0x3a, 0x82, 0x13, 0xcd, 0x73, 0x76,
	0x38, 0x1b, 0xd5, 0xb7, 0xe9, 0x33, 0x99, 0x68, 0x9b, 0x96, 0x50, 0xc8, 0x74, 0xe2, 0x4f, 0x81,
	0x0f, 0x5a, 0x0d, 0xd0, 0x9f, 0x0e, 0x1f, 0xf4, 0x57, 0xc8, 0x54, 0x12, 0xb9, 0x8d, 0x06, 0x8b,
	0x50, 0x95, 0x12, 0x87, 0xe1, 0x9f, 0x53, 0xdb, 0x62, 0x55, 0xa3, 0x1e, 0x1c, 0x96, 0x56, 0xfb,
	0xd5, 0x59, 0x25, 0x1b, 0x51, 0x05, 0xca, 0x10, 0x77, 0x3a, 0xe7, 0xea, 0x9d, 0xac, 0xd3, 0x87,
	0x7a, 0xc0, 0xff, 0xf9, 0x4c, 0xc6, 0xa9, 0x32, 0x24, 0x9b, 0x65, 0xa4, 0x07, 0x9b, 0xe5, 0xef,
	0xe4, 0x44, 0x7c, 0x68, 0xcc, 0x12, 0x91, 0x70, 0x89, 0xb9, 0xc4, 0x7c, 0x28, 0xbe, 0x38, 0x44,
	0x97, 0xe1, 0xd2, 0x9a, 0x2d, 0x62, 0xdd, 0x4f, 0xa2, 0x83, 0x95, 0x47, 0xe4, 0xb8, 0xcc, 0x65,
	0xb0, 0x90, 0xed, 0x11, 0x65, 0x32, 0x6d, 0x4f, 0x28, 0x28, 0x03, 0x78, 0x80, 0xac, 0x2a, 0x5d,
	0x32, 0xa9, 0x5d, 0x67, 0xeb, 0xb5, 0x64, 0xd8, 0x9c, 0x2a, 0x34, 0x32, 0x90, 0xdf, 0xd4, 0x50,
	0x2b, 0xa4, 0x38, 0x1d, 0x83, 0x87, 0xe5, 0x4d, 0x54, 0x13, 0xea, 0x90, 0x91, 0x96, 0x93, 0x48,
	0xd5, 0x62, 0x80, 0xbc, 0x3e, 0xa1, 0x35, 0x48, 0x61, 0x68, 0x3b, 0xbd, 0xb1, 0x5c, 0x05, 0xce,
	0x9b, 0x3f, 0x99, 0xda, 0xb5, 0xa5, 0xd2, 0x30, 0x48, 0xe5, 0xce, 0xec, 0xf5, 0x06, 0xe2, 0xc9,
	0x14, 0x18, 0x52, 0x51, 0xf4, 0xab, 0x84, 0xe8, 0x0d, 0x59, 0xea, 0x04, 0x5b, 0x83, 0x14, 0xb6,
	0x6a, 0xab, 0xc6, 0x24, 0x4c, 0x23, 0x8d, 0x00, 0x43, 0x20, 0x7d, 0x9b, 0x9b, 0x1b, 0xb8, 0xef,
	0xca, 0x4d, 0xff, 0xb3, 0x83, 0x54, 0x8e, 0x56, 0x1b, 0xb8, 0x14, 0x3c, 0x25, 0xac, 0x0c, 0x84,
	0x82, 0x92, 0x63, 0x05, 0x1b, 0xcf, 0x9c, 0x7a, 0xb0, 0xb1, 0x59, 0xbf, 0x7b, 0xf6, 0x8c, 0xea,
	0x77, 0xa7, 0x0e, 0x88, 0xb9, 0x2e, 0x0e, 0x88, 0x9b, 0x64, 0x51, 0x9a, 0xa7, 0xd1, 0x72, 0x0d,
	0xb3, 0xc2, 0x70, 0x01, 0x9b, 0x4f, 0x4b, 0x8c, 0x2d, 0x2e, 0xb7, 0xa3, 0xa1, 0x53, 0x9b, 0xf6,
	0xfa, 0xda, 0x0b, 0xef, 0x42, 0x7d, 0x6d, 0xba, 0x4a, 0x16, 0xd4, 0x15, 0x2d, 0x3a, 0x72, 0x92,
	0xea, 0x5a, 0x56, 0x2b, 0x59, 0x24, 0xb4, 0xd3, 0x5b, 0x6e, 0x99, 0xcb, 0x67, 0xed, 0x96, 0x29,
	0x75, 0x73, 0xcb, 0x5c, 0x5a, 0x21, 0xe7, 0x3a, 0xad, 0xcd, 0x74, 0xde, 0xc8, 0x08, 0x17, 0x49,
	0xe0, 0xe7, 0xac, 0x5c, 0x3b, 0x99, 0x5c, 0xf7, 0x72, 0xfe, 0xa5, 0x5c, 0xf9, 0x5f, 0x8d, 0x90,
	0xc5, 0x0e, 0x87, 0x36, 0xa7, 0x51, 0x82, 0xbc, 0xb3, 0x2e, 0x94, 0xef, 0x4b, 0x17, 0xca, 0x94,
	0x33, 0x1f, 0x19, 0x72, 0x39, 0x73, 0x4b, 0x71, 0x1a, 0xed, 0x41, 0x71, 0xfa, 0x86, 0xad, 0x90,
	0x88, 0xfa, 0xbe, 0xc3, 0xf2, 0xca, 0xf7, 0xae, 0x8d, 0x7c, 0x37, 0x47, 0xa6, 0xb0, 0xa9, 0xf0,
	0xa0, 0xf4, 0x90, 0x85, 0xf9, 0x38, 0x19, 0x71, 0xbc, 0x86, 0xaa, 0x60, 0xa9, 0xaa, 0x07, 0x2c,
	0x7b, 0x0d, 0xe0, 0x70, 0xbe, 0x60, 0xc4, 0x18, 0x9f, 0x3a, 0xa2, 0x2f, 0x6b, 0x11, 0x21, 0xa9,
	0x02, 0x8e, 0xc7, 0xd1, 0xe9, 0x28, 0xa9, 0xe3, 0x68, 0xd3, 0x2b, 0xf3, 0x97, 0x27, 0xc8, 0x9c,
	0x88, 0x5c, 0x95, 0x77, 0x5d, 0xb1, 0x9a, 0x19, 0xb8, 0x9e, 0xeb, 0x3d, 0x70, 0x7d, 0x8f, 0x8c,
	0x87, 0x51, 0x4b, 0x5d, 0x89, 0x30, 0xd0, 0x1d, 0x0e, 0xdb, 0xc8, 0x07, 0x17, 0x11, 0xf1, 0x61,
	0xe1, 0x6f, 0x90, 0xfc, 0x65, 0x0a, 0xc4, 0x6a, 0x20, 0x13, 0xb2, 0x75, 0x0a, 0x04, 0x07, 0x81,
	0xc2, 0x99, 0x99, 0x12, 0xa3, 0xbd, 0x66, 0x4a, 0x3c, 0xbc, 0xdc, 0x4a, 0xa1, 0xe9, 0xfa, 0x22,
	0x26, 0x78, 0x1c, 0xc7, 0x1c, 0xf7, 0x8f, 0x2d, 0x09, 0x83, 0x14, 0x6b, 0xe5, 0x09, 0x4c, 0x1c,
	0x9b, 0x27, 0xa0, 0x2a, 0xb9, 0x16, 0x3a, 0x56, 0x72, 0x7d, 0x8e, 0x4c, 0x46, 0x2c, 0x71, 0x5c,
	0xbf, 0x1a, 0x84, 0xd2, 0x77, 0x8b, 0xdd, 0x03, 0x05, 0x04, 0x8d, 0xa7, 0x57, 0xc9, 0x94, 0xf8,
	0xc1, 0xea, 0x1b, 0xd2, 0x1d, 0x67, 0x91, 0x6f, 0x04, 0x11, 0x98, 0x14, 0xf4, 0x5b, 0x39, 0x32,
	0x83, 0x4e, 0x2e, 0xb5, 0x1b, 0x49, 0x53, 0x79, 0x00, 0x15, 0xa6, 0x62, 0xb2, 0xc3, 0x77, 0xa8,
	0xcb, 0x4d, 0x9b, 0x28, 0xb0, 0x05, 0xd3, 0x6f, 0xe7, 0xc8, 0x54, 0xac, 0x2f, 0x5c, 0x93, 0x76,
	0x31, 0x0c, 0x50, 0xee, 0xaa, 0xcb, 0x35, 0x6e, 0xda, 0x3d, 0x68, 0x20, 0xc0, 0x94, 0x4d, 0x5f,
	0x26, 0xb3, 0xcc, 0x89, 0xbc, 0x83, 0x4a, 0x12, 0x84, 0xcb, 0xbb, 0x09, 0x8b, 0xa4, 0xb9, 0x85,
	0x96, 0xe8, 0xba, 0x85, 0x81, 0x0c, 0x25, 0x7d, 0x95, 0xcc, 0xdf, 0x65, 0x2c, 0xbc, 0xed, 0x7b,
	0x07, 0xd5, 0x20, 0xc4, 0x79, 0x83, 0xf6, 0x97, 0x2c, 0x92, 0xf0, 0x5a, 0x06, 0x07, 0x6d, 0xd4,
	0xe5, 0xff, 0xb8, 0x28, 0xa3, 0x34, 0x54, 0x44, 0x89, 0x50, 0x0a, 0x72, 0x5d, 0x94, 0x82, 0x8c,
	0x35, 0x93, 0xef, 0xc1, 0x9a, 0xb9, 0x46, 0xa6, 0x71, 0x08, 0x25, 0x81, 0x79, 0x3e, 0xb2, 0x65,
	0xc0, 0xc1, 0xa2, 0xc2, 0x72, 0x40, 0xa9, 0xd3, 0x74, 0x4c, 0x87, 0xae, 0x74, 0x74, 0x98, 0x66,
	0xb2, 0xc9, 0xc6, 0x7b, 0xc8, 0x26, 0x53, 0xf9, 0x5d, 0x13, 0x67, 0x91, 0xdf, 0x55, 0x38, 0xf5,
	0xfc, 0xae, 0xfb, 0x24, 0xbf, 0xcb, 0xa4, 0x66, 0xbe, 0x3d, 0xcc, 0x42, 0x47, 0xa2, 0xa2, 0x07,
	0xdf, 0x8e, 0xdb, 0x71, 0x90, 0xdf, 0xcd, 0xe4, 0x1f, 0x90, 0x33, 0xcf, 0x3f, 0xd8, 0x25, 0x23,
	0x75, 0xdf, 0x1f, 0x7c, 0x25, 0x69, 0xab, 0xe4, 0x2b, 0x2c, 0xaf, 0x35, 0xdf, 0x07, 0x2e, 0x80,
	0xb6, 0xc8, 0x44, 0x4d, 0xdc, 0x44, 0x26, 0x17, 0x8b, 0x41, 0x2e, 0x0d, 0xe8, 0x70, 0xa5, 0x99,
	0xac, 0xad, 0x21, 0x30, 0xa0, 0x64, 0xd1, 0xaf, 0x73, 0xcd, 0xd9, 0xd3, 0x3d, 0x93, 0xc6, 0xc8,
	0x20, 0xa5, 0x91, 0x37, 0xb7, 0x6d, 0xc1, 0xa2, 0x84, 0x85, 0x01, 0x05, 0x4b, 0x22, 0x0d, 0x49,
	0x81, 0x99, 0xf7, 0x38, 0x0e, 0x64, 0xdb, 0x9a, 0x65, 0x5f, 0xc5, 0x26, 0x95, 0x56, 0x86, 0x4d,
	0xa5, 0x70, 0x89, 0xa9, 0xfd, 0x3e, 0x37, 0xa8, 0xc4, 0xd4, 0x7e, 0x3f, 0xce, 0x74, 0x2f, 0x93,
	0x71, 0xbe, 0x01, 0xa6, 0x79, 0x70, 0xa8, 0x09, 0x54, 0x11, 0x02, 0x12, 0x63, 0x9e, 0x7c, 0x2e,
	0x1c, 0x73, 0xf2, 0x79, 0x85, 0x14, 0x42, 0xa7, 0x76, 0xd7, 0x69, 0xb0, 0xba, 0xac, 0xa7, 0x27,
	0xfc, 0x66, 0x12, 0x06, 0x29, 0x96, 0x2f, 0x71, 0x61, 0x6b, 0xc7, 0x73, 0xe3, 0x3d, 0x56, 0xc7,
	0x35, 0x5f, 0x66, 0x23, 0x6e, 0x2b, 0x20, 0x68, 0x3c, 0x1a, 0x01, 0x2d, 0xa4, 0x3c, 0x67, 0x18,
	0x01, 0x08, 0x01, 0x89, 0x11, 0x75, 0xa3, 0x42, 0xd1, 0xc5, 0xf3, 0x5a, 0x34, 0x48, 0x18, 0xa4,
	0x58, 0xc3, 0xa4, 0xb8, 0xd0, 0xf5, 0xa4, 0x57, 0x38, 0x00, 0x77, 0x5d, 0x8f, 0xd5, 0x8b, 0x8f,
	0x18, 0x0f, 0x22, 0x61, 0x90, 0x62, 0x39, 0x25, 0xdf, 0xce, 0xdc, 0x7d, 0x56, 0x2f, 0x16, 0x35,
	0xe5, 0xb2, 0x84, 0x41, 0x8a, 0xa5, 0x4b, 0x84, 0xa8, 0xa2, 0x4e, 0xac, 0x5e, 0xbc, 0xa8, 0xcb,
	0x0d, 0x6e, 0xa4, 0x50, 0x30, 0x28, 0xc4, 0x13, 0xa1, 0x45, 0x5e, 0x2f, 0x5e, 0x32, 0x9f, 0x48,
	0xc0, 0x20, 0xc5, 0xf2, 0x2d, 0x60, 0x87, 0xf9, 0xb5, 0xbd, 0xa6, 0x13, 0xdd, 0x65, 0xf5, 0xe2,
	0xa3, 0x48, 0x8c, 0x5b, 0xc0, 0x8a, 0x06, 0x83, 0x49, 0xc3, 0x99, 0x2b, 0xfb, 0xae, 0xf8, 0x98,
	0x66, 0xae, 0xcc, 0x40, 0x48, 0xb1, 0x78, 0x5b, 0x84, 0xe7, 0x34, 0xf8, 0x2b, 0x7d, 0x5c, 0xbf,
	0xfa, 0x0d, 0x01, 0x02, 0x85, 0xb3, 0x9c, 0x06, 0x97, 0x4f, 0xdd, 0x69, 0x10, 0x1b, 0xe5, 0xb3,
	0x4a, 0x83, 0x7e, 0x25, 0x66, 0x75, 0x2d, 0x31, 0x6c, 0xc6, 0x25, 0x9b, 0xba, 0x12, 0x17, 0xbd,
	0x4f, 0xa6, 0x44, 0x50, 0xbb, 0x78, 0xca, 0x27, 0x4e, 0x56, 0xd4, 0xa2, 0xcd, 0x8e, 0x57, 0x91,
	0xc6, 0x5a, 0xec, 0xaa, 0xe6, 0x0e, 0xa6, 0x28, 0x7a, 0x9b, 0x9c, 0x77, 0x70, 0xaf, 0x5b, 0x63,
	0x4e, 0x1d, 0xad, 0x53, 0x2c, 0x71, 0x14, 0x17, 0x3f, 0x88, 0x56, 0x23, 0x5e, 0x0c, 0xba, 0xdc,
	0x89, 0x00, 0x3a, 0xb7, 0xa3, 0x5f, 0x21, 0x33, 0xe9, 0x36, 0x52, 0x3d, 0x08, 0x59, 0xb1, 0x9c,
	0x66, 0x22, 0xcf, 0xac, 0x9b, 0x88, 0x41, 0xaa, 0xa1, 0xa0, 0x86, 0x83, 0x4e, 0x6b, 0x5b, 0x98,
	0x0a, 0x90, 0x78, 0xb2, 0x3d, 0x40, 0x82, 0x02, 0xb9, 0xb0, 0xdb, 0xb6, 0xd7, 0x72, 0xa5, 0xad,
	0xf8, 0x14, 0x4e, 0x3e, 0xcc, 0xd5, 0xdf, 0xe8, 0x48, 0x01, 0x5d, 0x5a, 0x96, 0x7f, 0xfe, 0x29,
	0x69, 0x0d, 0x76, 0x3a, 0x83, 0xc9, 0x0d, 0xf1, 0x0c, 0x26, 0x20, 0x0b, 0xc6, 0xc1, 0xab, 0x14,
	0x70, 0xf2, 0x2b, 0xc6, 0xd0, 0x21, 0x53, 0xcd, 0x32, 0x82, 0x76, 0xde, 0xd4, 0x25, 0x73, 0x0a,
	0x28, 0xe3, 0x14, 0xfa, 0x70, 0x01, 0x60, 0x11, 0x85, 0xaa, 0xcd, 0x06, 0xb2, 0x7c, 0xa9, 0x47,
	0xe6, 0xe5, 0x75, 0x1e, 0xfa, 0xd1, 0x4e, 0x1e, 0x04, 0x82, 0x9a, 0x79, 0x35, 0xc3, 0x07, 0xda,
	0x38, 0xd3, 0x5d, 0x32, 0x2b, 0x61, 0xea, 0xb9, 0xc6, 0xfa, 0x3b, 0xcd, 0xaa, 0x5a, 0x5c, 0x20,
	0xc3, 0xd5, 0x8c, 0x0f, 0x19, 0x1f, 0x52, 0x7c, 0xc8, 0xb3, 0x64, 0xa2, 0xb6, 0x2f, 0x0c, 0xd7,
	0x09, 0x34, 0x5c, 0xd3, 0x70, 0x8e, 0xd5, 0x3b, 0xc2, 0x76, 0x55, 0xf8, 0x34, 0x77, 0x96, 0x3f,
	0x3a, 0x36, 0x28, 0x60, 0x03, 0x3b, 0x77, 0x56, 0x21, 0xc1, 0xa6, 0xa5, 0x57, 0xc9, 0x24, 0x16,
	0xc0, 0xc3, 0x86, 0x93, 0xd8, 0x30, 0xf5, 0xcd, 0x54, 0x15, 0x02, 0x34, 0x8d, 0xc8, 0x10, 0x8e,
	0x13, 0xd4, 0x53, 0x73, 0x66, 0x86, 0x30, 0x37, 0x81, 0x39, 0x86, 0x53, 0xec, 0x70, 0x03, 0x79,
	0x4a, 0x6c, 0x08, 0x8a, 0x62, 0x05, 0x8d, 0x64, 0x8e, 0xa1, 0x5f, 0x24, 0xf9, 0xda, 0x3e, 0xde,
	0xc8, 0x3d, 0x88, 0x9b, 0x76, 0x8b, 0x39, 0x71, 0x2b, 0x62, 0x4d, 0xe6, 0x27, 0x2b, 0x44, 0x4a,
	0xc9, 0xaf, 0xde, 0x81, 0x7c, 0x6d, 0x9f, 0xba, 0xea, 0xfe, 0x96, 0x99, 0x21, 0x0a, 0x49, 0x03,
	0x65, 0xac, 0x9b, 0x60, 0x76, 0xa5, 0x3f, 0x60, 0x76, 0x88, 0x92, 0xd2, 0x41, 0x33, 0x3c, 0x0b,
	0xcf, 0xdb, 0x47, 0xa6, 0x8f, 0x66, 0x8f, 0x4c, 0x89, 0xf0, 0x72, 0x99, 0xe7, 0xa5, 0x2f, 0x10,
	0x22, 0xf4, 0x15, 0xc3, 0xed, 0x9c, 0x3a, 0xbd, 0x20, 0xc5, 0x80, 0x41, 0xc5, 0x27, 0x84, 0xf8,
	0xf5, 0x46, 0xe4, 0xca, 0x53, 0xd1, 0x74, 0x42, 0x80, 0x42, 0x80, 0xa6, 0xa1, 0x1f, 0x27, 0x53,
	0x4d, 0xc7, 0x77, 0x77, 0x59, 0x8c, 0x4d, 0xa8, 0x1d, 0xd2, 0xb3, 0xa5, 0x51, 0x60, 0xd2, 0xf1,
	0xbe, 0xdd, 0x63, 0x6e, 0x63, 0x2f, 0x89, 0x79, 0xab, 0x45, 0xbb, 0x6f, 0x6f, 0xa6, 0x18, 0x30,
	0xa8, 0xe8, 0x32, 0x99, 0xc3, 0x83, 0x70, 0x2c, 0x8c, 0xcf, 0x22, 0xde, 0x50, 0x1c, 0x95, 0xa6,
	0xe7, 0x67, 0x9b, 0x36, 0x1a, 0xb2, 0xf4, 0xfc, 0xbb, 0xf2, 0x82, 0x06, 0xca, 0x3c, 0x6f, 0xc7,
	0x8a, 0x6e, 0x0a, 0x30, 0x28, 0x3c, 0xef, 0xa1, 0xd4, 0xcf, 0x38, 0xf5, 0x05, 0xbb, 0x87, 0xdb,
	0x29, 0x06, 0x0c, 0x2a, 0x1c, 0x0c, 0x37, 0xae, 0x71, 0x13, 0x8c, 0x37, 0x7a, 0x24, 0x33, 0x18,
	0x1a, 0x05, 0x26, 0x1d, 0x7d, 0x06, 0x93, 0xdb, 0x78, 0x8b, 0xa2, 0x7d, 0x0e, 0x5d, 0x45, 0x28,
	0x48, 0x2c, 0xa7, 0x73, 0xc2, 0x90, 0xd3, 0x5d, 0xb4, 0xe9, 0x96, 0x11, 0x0a, 0x12, 0xcb, 0x5f,
	0xa2, 0xce, 0x5a, 0xb9, 0x64, 0xbf, 0xc4, 0x8e, 0x99, 0x2b, 0x5f, 0xb3, 0xea, 0xe3, 0x3e, 0x3a,
	0xe8, 0x8d, 0x76, 0x6d, 0xb5, 0x7a, 0x1f, 0x56, 0x6c, 0x97, 0x0f, 0x9c, 0xd2, 0x90, 0xf8, 0xe3,
	0x3d, 0x6e, 0x0f, 0xdc, 0x86, 0x46, 0x81, 0x49, 0x87, 0x95, 0x18, 0x0e, 0x92, 0xbd, 0xc0, 0x57,
	0xae, 0x91, 0xcb, 0x99, 0x4a, 0x0c, 0x26, 0x12, 0x6c, 0x5a, 0xfa, 0xd7, 0x72, 0x64, 0x56, 0x40,
	0xa4, 0x69, 0x11, 0x17, 0x4b, 0xf8, 0xe4, 0x6f, 0x0d, 0xa5, 0xc4, 0xd8, 0xd2, 0xb6, 0xc5, 0x5b,
	0x9c, 0xf4, 0xea, 0xca, 0x9e, 0x16, 0x12, 0x32, 0x1d, 0xa1, 0xdf, 0xc8, 0x91, 0x69, 0xe4, 0x2e,
	0xdd, 0x2f, 0x52, 0x4f, 0x1c, 0x86, 0x36, 0xfc, 0x98, 0xec, 0xc2, 0xb9, 0xaa, 0xc1, 0x3f, 0xd5,
	0x8e, 0x2d, 0xa9, 0xf4, 0x67, 0x73, 0xe2, 0x8e, 0x2e, 0xd5, 0x8b, 0x0f, 0x0e, 0xad, 0x17, 0x6a,
	0xfd, 0x5a, 0xac, 0x6a, 0xf6, 0x69, 0x27, 0x4c, 0x99, 0xf4, 0x2f, 0xe6, 0xc8, 0x82, 0xbe, 0x50,
	0x45, 0xf5, 0xa4, 0x3c, 0xb4, 0x9e, 0x5c, 0x94, 0x3d, 0x59, 0xb8, 0x93, 0x15, 0x02, 0xed, 0x72,
	0xbb, 0x9c, 0xbb, 0x3c, 0xd9, 0xd7, 0xb9, 0xcb, 0x35, 0xf9, 0x8e, 0xb9, 0x81, 0x10, 0xdc, 0x8b,
	0x51, 0x39, 0x1d, 0xb3, 0xef, 0x4c, 0xc3, 0xda, 0x1c, 0x16, 0x95, 0x71, 0x6d, 0x1a, 0x36, 0x7a,
	0x5a, 0x57, 0x06, 0xaf, 0x6a, 0x30, 0x98, 0x34, 0xf6, 0xb5, 0x69, 0xd8, 0xea, 0x19, 0xed, 0x20,
	0xbd, 0x63, 0x61, 0x20, 0x43, 0x69, 0x9f, 0xde, 0x7c, 0xe8, 0x84, 0x61, 0x2f, 0x57, 0x8e, 0x0d,
	0x7b, 0xf9, 0x38, 0x99, 0x8a, 0xdd, 0x77, 0xd8, 0x4d, 0x7f, 0xe5, 0x20, 0x61, 0x71, 0xf1, 0x59,
	0x71, 0xe3, 0x51, 0xea, 0xee, 0xd5, 0x28, 0x30, 0xe9, 0x70, 0x0d, 0x77, 0x12, 0xe6, 0xd7, 0x0e,
	0x8a, 0x1f, 0xb6, 0x75, 0xa3, 0x4d, 0x01, 0x06, 0x85, 0xa7, 0x8f, 0x93, 0x91, 0x56, 0xe4, 0x15,
	0x9f, 0xb3, 0x0f, 0x64, 0xde, 0x80, 0x4d, 0xe0, 0xf0, 0xf6, 0x42, 0x2e, 0x1f, 0x39, 0x41, 0x21,
	0x97, 0xcf, 0xf1, 0xdd, 0x55, 0xd8, 0xce, 0xcb, 0x49, 0xf1, 0xa3, 0xfd, 0x85, 0x32, 0x43, 0xca,
	0x01, 0x0c, 0x6e, 0x7c, 0x64, 0x12, 0x27, 0xe2, 0xbb, 0x0a, 0x5e, 0x72, 0xb7, 0x64, 0x2f, 0x87,
	0x55, 0x27, 0xda, 0x90, 0x28, 0x30, 0xe9, 0xd2, 0x75, 0x1f, 0x1b, 0x5d, 0xed, 0xb0, 0xee, 0x8b,
	0x2b, 0xf8, 0x52, 0x1a, 0xfa, 0xf3, 0x39, 0x32, 0xaf, 0x26, 0x97, 0xba, 0xc9, 0xaf, 0xf8, 0xb1,
	0x41, 0x0f, 0x84, 0xf4, 0x9d, 0x80, 0x3a, 0xda, 0xae, 0x9a, 0x91, 0x02, 0x6d, 0x72, 0xe9, 0xaf,
	0xe4, 0xb4, 0xe5, 0x03, 0x4c, 0x94, 0x3a, 0x8b, 0x8b, 0xcf, 0x0f, 0x1a, 0x2b, 0xa1, 0x58, 0xad,
	0x06, 0x7e, 0xdc, 0x6a, 0x86, 0xf6, 0x37, 0x5f, 0xcd, 0xca, 0x83, 0xf6, 0x2e, 0xd0, 0xbf, 0x92,
	0x4b, 0xcd, 0x16, 0xdd, 0xaf, 0x17, 0x4e, 0xa3, 0x5f, 0x7a, 0xb8, 0x32, 0xe2, 0xa0, 0xad, 0x03,
	0xa8, 0xba, 0x8b, 0x3a, 0x38, 0x2b, 0x07, 0xc5, 0xff, 0xcf, 0x7e, 0xd9, 0x55, 0x85, 0x00, 0x4d,
	0xc3, 0x15, 0xf3, 0x84, 0x39, 0xcd, 0xe2, 0x35, 0xfb, 0xfc, 0xb2, 0xca, 0x9c, 0x26, 0x20, 0x86,
	0xbe, 0x24, 0x17, 0x24, 0x75, 0xc3, 0xdd, 0xc7, 0xed, 0xba, 0x4f, 0x55, 0x03, 0x07, 0x16, 0x25,
	0xfd, 0x08, 0x29, 0x30, 0xbf, 0x1e, 0x06, 0xae, 0x9f, 0x14, 0x7f, 0x4a, 0x1c, 0x4f, 0xa8, 0xc8,
	0x89, 0x75, 0xbf, 0x8e, 0xe5, 0xa4, 0x21, 0xa5, 0xa0, 0x7f, 0x96, 0x8c, 0x72, 0x2d, 0xab, 0xf8,
	0x22, 0x8e, 0xe1, 0x2b, 0x7d, 0xeb, 0xcc, 0x5c, 0x67, 0x33, 0x6f, 0x2c, 0x6b, 0xe0, 0x8d, 0x65,
	0x0d, 0xbc, 0x75, 0x34, 0x89, 0x5c, 0xc7, 0xbb, 0xb9, 0x56, 0x7c, 0x49, 0x1f, 0x26, 0x56, 0x05,
	0x08, 0x14, 0x8e, 0x7e, 0x99, 0x4c, 0x45, 0x41, 0xcd, 0x69, 0xd5, 0x6a, 0xad, 0x68, 0x9f, 0x15,
	0x3f, 0x31, 0x68, 0xe0, 0x48, 0x50, 0x5b, 0x6e, 0xd5, 0x56, 0x39, 0x2f, 0xfd, 0xb1, 0x1a, 0x40,
	0x30, 0xa5, 0xd1, 0xbb, 0x64, 0x22, 0x8c, 0x84, 0xe0, 0x97, 0x51, 0xf0, 0xab, 0x7d, 0x0b, 0xde,
	0x06, 0x21, 0x34, 0x5d, 0x08, 0x25, 0x00, 0x94, 0x04, 0xbe, 0x89, 0xce, 0xd5, 0x02, 0x7f, 0xb7,
	0xc5, 0x35, 0x9f, 0x2d, 0x27, 0x89, 0xdc, 0xfb, 0xc5, 0x4f, 0x9e, 0xec, 0x0e, 0xf9, 0x0e, 0xae,
	0x27, 0x8b, 0x9f, 0xd6, 0xc2, 0x33, 0x08, 0xc8, 0x4a, 0xa6, 0x5f, 0xb1, 0xce, 0xf7, 0x3f, 0x85,
	0x4a, 0xd7, 0x8d, 0x81, 0x53, 0xee, 0x7b, 0x3c, 0xd7, 0xbf, 0xb4, 0x4c, 0x16, 0x3b, 0xa8, 0x66,
	0x27, 0x0a, 0xf4, 0xf8, 0xb7, 0x63, 0xf2, 0x1c, 0x5e, 0x6f, 0x9e, 0xf4, 0x45, 0x2b, 0x5d, 0xef,
	0xc9, 0x4c, 0xba, 0xde, 0x62, 0x86, 0xdc, 0xbe, 0x4d, 0x30, 0x8c, 0xd8, 0xbe, 0x38, 0x7b, 0x34,
	0x72, 0xcc, 0xb7, 0x15, 0x10, 0x34, 0xbe, 0x8f, 0xa2, 0xd2, 0x34, 0x20, 0x93, 0xf5, 0xc8, 0xdd,
	0x4d, 0x36, 0x22, 0xf6, 0xb6, 0x3c, 0x3b, 0x7c, 0x5d, 0x2d, 0x14, 0x6b, 0x0a, 0x31, 0x70, 0x61,
	0x64, 0x2d, 0x83, 0xbe, 0x48, 0x66, 0xf0, 0x47, 0x5a, 0xe6, 0x5f, 0x9c, 0xd3, 0x63, 0x89, 0xee,
	0x35, 0x13, 0x01, 0x36, 0x9d, 0x71, 0x9b, 0xee, 0x78, 0xd7, 0xdb, 0x74, 0xeb, 0x64, 0xbc, 0x89,
	0x87, 0x77, 0xf2, 0xe0, 0x71, 0x13, 0xcb, 0x89, 0x21, 0x64, 0x08, 0x07, 0x82, 0x92, 0x37, 0xbd,
	0x48, 0x46, 0x9a, 0xae, 0x2f, 0x5d, 0x29, 0xe8, 0x5c, 0xdc, 0x72, 0x7d, 0xe0, 0x30, 0x44, 0x39,
	0xf7, 0xa5, 0xb3, 0x44, 0xa0, 0x9c, 0xfb, 0xc0, 0x61, 0x74, 0x89, 0x90, 0xa6, 0xeb, 0xab, 0x8b,
	0x2c, 0x84, 0x8b, 0x44, 0xdc, 0xf0, 0x92, 0x42, 0xc1, 0xa0, 0x40, 0x7a, 0xe7, 0xbe, 0xa2, 0x9f,
	0x32, 0xe8, 0x53, 0x28, 0x18, 0x14, 0xf4, 0x0b, 0x64, 0xc4, 0x69, 0x34, 0xf0, 0xf8, 0x4c, 0x3c,
	0xf8, 0xc8, 0x72, 0xa3, 0x31, 0x9c, 0x52, 0xd3, 0x9c, 0x71, 0xf9, 0xd7, 0x47, 0xc9, 0xf9, 0x8e,
	0xd9, 0x44, 0xb8, 0x77, 0xe8, 0xc9, 0x3d, 0x6d, 0x4e, 0x6e, 0x39, 0x8b, 0xfb, 0x4f, 0xed, 0xc9,
	0x96, 0xc2, 0x39, 0x3e, 0x53, 0xe7, 0x99, 0x74, 0x8e, 0x64, 0x72, 0xb9, 0x33, 0xf3, 0x24, 0xcd,
	0x72, 0x1a, 0xeb, 0x9e, 0xe5, 0x64, 0x4c, 0xa6, 0xf1, 0x53, 0x9c, 0x4c, 0xcf, 0x93, 0x29, 0xa7,
	0x96, 0xb4, 0x1c, 0x0f, 0xcb, 0x75, 0x2b, 0x87, 0x1e, 0x1f, 0x96, 0x65, 0x0d, 0x06, 0x93, 0x06,
	0x2f, 0x6e, 0x76, 0xe2, 0x38, 0xcd, 0x11, 0xd4, 0x17, 0x37, 0x23, 0x14, 0x24, 0x96, 0xae, 0x90,
	0xbc, 0xa3, 0xe2, 0x49, 0x4f, 0xa2, 0x7c, 0x8e, 0x1f, 0x1d, 0x96, 0xf2, 0xcb, 0x09, 0xe4, 0x9d,
	0x84, 0x6b, 0xc1, 0xf5, 0x96, 0x30, 0x49, 0x6e, 0xfa, 0x15, 0x56, 0x93, 0x81, 0x28, 0xa9, 0x16,
	0xbc, 0x66, 0x22, 0xc1, 0xa6, 0x2d, 0x7f, 0x8c, 0xcc, 0x67, 0xcf, 0x43, 0xd3, 0xcb, 0x28, 0x8d,
	0x0b, 0x21, 0x8c, 0xcb, 0x28, 0xdf, 0x22, 0xf3, 0xd9, 0xcb, 0x65, 0x87, 0x55, 0xe0, 0xfe, 0x07,
	0x79, 0x52, 0xb8, 0x15, 0x24, 0x6c, 0x27, 0x08, 0xee, 0x9e, 0x41, 0xaa, 0xfa, 0x9e, 0x95, 0xaa,
	0x3e, 0xc0, 0xd9, 0x91, 0xea, 0x73, 0xd7, 0x14, 0xf5, 0x30, 0x93, 0xa2, 0x7e, 0x63, 0x08, 0xb2,
	0x8e, 0x4f, 0x4d, 0xff, 0x83, 0x3c, 0x59, 0x50, 0xa4, 0x3a, 0x25, 0xfd, 0x13, 0xd6, 0x32, 0xf0,
	0x74, 0x66, 0x8f, 0x3b, 0xdf, 0xd6, 0xe0, 0xfd, 0x7c, 0xf4, 0xe3, 0xf3, 0xd1, 0xff, 0x5d, 0x8e,
	0x4c, 0xab, 0x41, 0x3b, 0x83, 0x3c, 0xf4, 0x86, 0x9d, 0x87, 0xbe, 0x32, 0xf8, 0x2c, 0xea, 0x92,
	0x7f, 0xfe, 0x5b, 0x79, 0x32, 0xa5, 0x48, 0xce, 0xa6, 0x6c, 0xc4, 0x5d, 0xeb, 0x5b, 0xbc, 0x39,
	0xf8, 0x93, 0x1d, 0x57, 0x31, 0x22, 0xce, 0x7c, 0x8e, 0xaf, 0x0d, 0x47, 0xdc, 0xf1, 0x5f, 0xe4,
	0x7f, 0xce, 0x93, 0x73, 0x06, 0x75, 0xcf, 0x75, 0x22, 0x3a, 0xb5, 0x79, 0xff, 0xbb, 0x3c, 0xfe,
	0xbb, 0xfc, 0xdd, 0x1c, 0x99, 0x33, 0xc6, 0xed, 0x0c, 0x3e, 0xcd, 0x2f, 0xd9, 0x9f, 0xe6, 0xfa,
	0x50, 0x66, 0x54, 0x97, 0xaf, 0xf3, 0xbf, 0xe5, 0xad, 0xa7, 0xeb, 0x37, 0xc9, 0x4a, 0xdc, 0xe7,
	0x83, 0x5c, 0x0c, 0x95, 0x4f, 0xdd, 0xe7, 0x93, 0xc2, 0xc1, 0xa2, 0xa2, 0x11, 0x19, 0xc7, 0xcd,
	0x7a, 0x18, 0x77, 0xd4, 0x4b, 0xbe, 0x77, 0x1c, 0x71, 0x4f, 0x8e, 0x7e, 0xf3, 0xf2, 0x5e, 0x14,
	0x29, 0xe9, 0xe1, 0x25, 0x14, 0x87, 0x71, 0x49, 0xb7, 0x0a, 0x48, 0x18, 0xef, 0x50, 0xb1, 0xe1,
	0x77, 0xc6, 0xf4, 0x6e, 0xaa, 0x13, 0xe9, 0x1f, 0x5a, 0xa7, 0xc1, 0x68, 0x62, 0x1d, 0xec, 0x59,
	0xb1, 0x07, 0xf9, 0xd3, 0xa9, 0x74, 0x30, 0x72, 0xaa, 0x25, 0x83, 0x47, 0x07, 0x2f, 0x19, 0x3c,
	0xd6, 0x83, 0x2f, 0x3a, 0x93, 0x58, 0x39, 0x7e, 0xb6, 0x89, 0x95, 0xca, 0xcd, 0x35, 0x71, 0x5a,
	0x6e, 0xae, 0x9f, 0xb3, 0x13, 0x25, 0x0a, 0xf8, 0x41, 0xdd, 0x1a, 0xca, 0xd2, 0xd1, 0x7b, 0x9a,
	0xc4, 0xf7, 0x27, 0xb4, 0x0e, 0x73, 0x86, 0x35, 0x66, 0xb6, 0xc9, 0x64, 0x5c, 0xdb, 0x63, 0x4d,
	0x07, 0xd8, 0xae, 0x9c, 0xac, 0x3d, 0x95, 0xc2, 0x17, 0x93, 0x5f, 0xb5, 0x04, 0xcd, 0xc4, 0xae,
	0xf5, 0x37, 0xfa, 0x90, 0x5a, 0x7f, 0xd7, 0xc8, 0x74, 0xc4, 0xde, 0x6e, 0xb9, 0xe2, 0xc4, 0x3e,
	0x96, 0xb3, 0x11, 0x17, 0x3f, 0x30, 0xe0, 0x60, 0x51, 0x89, 0xe7, 0xdc, 0x49, 0x8f, 0x1b, 0xcd,
	0x30, 0x6b, 0x0d, 0x06, 0x93, 0x86, 0x1b, 0x53, 0xfb, 0x0e, 0x66, 0x25, 0xa4, 0x37, 0xfb, 0xdf,
	0x71, 0xa2, 0x18, 0x10, 0x6a, 0x05, 0xcc, 0x15, 0x4e, 0x3d, 0x60, 0x2e, 0x5d, 0x47, 0x27, 0x4f,
	0xb2, 0x8e, 0x92, 0x13, 0xae, 0xa3, 0x5d, 0xe3, 0xd4, 0xa6, 0xfa, 0x8c, 0x53, 0x33, 0x93, 0x03,
	0xa7, 0xcf, 0x28, 0x39, 0xd0, 0xcc, 0x72, 0x9b, 0x39, 0xeb, 0x2c, 0xb7, 0xd9, 0x6e, 0x21, 0xa9,
	0xe5, 0xff, 0x99, 0x27, 0xb3, 0xb6, 0x05, 0xc8, 0x2d, 0x6b, 0x71, 0x3f, 0x7a, 0xce, 0xb6, 0xac,
	0xad, 0x6b, 0xcd, 0xf1, 0x20, 0xcd, 0xcd, 0x66, 0x36, 0xbd, 0x01, 0x37, 0x81, 0xc3, 0xbb, 0x2c,
	0xf2, 0x23, 0x7d, 0x2d, 0xf2, 0x46, 0xb2, 0xdc, 0xe8, 0x90, 0x92, 0xe5, 0xbe, 0xd6, 0x21, 0x9f,
	0x6c, 0x08, 0x3a, 0x7b, 0xef, 0x6b, 0xe4, 0x5b, 0x64, 0x3e, 0xab, 0xac, 0x0c, 0xcb, 0xe7, 0xf1,
	0xc3, 0x1c, 0x39, 0xbf, 0xcd, 0x22, 0x37, 0xa8, 0x57, 0x50, 0xcd, 0x75, 0x3c, 0x37, 0x39, 0x38,
	0xc9, 0x4d, 0xc1, 0x4f, 0x93, 0x89, 0x10, 0xdb, 0xc7, 0xf2, 0x52, 0x3d, 0x24, 0x13, 0x2c, 0x63,
	0x50, 0x38, 0xda, 0x20, 0xa3, 0x7c, 0x70, 0xa4, 0x8f, 0xae, 0xc2, 0xbb, 0xba, 0x15, 0xd4, 0xd9,
	0x20, 0x57, 0x03, 0x1a, 0x1d, 0xe6, 0xac, 0x00, 0x05, 0x94, 0xff, 0x51, 0x8e, 0x10, 0xf9, 0x40,
	0xfc, 0x29, 0xf6, 0x48, 0xc1, 0x55, 0x7e, 0xe4, 0x5c, 0xea, 0xa4, 0x2b, 0x28, 0x9f, 0xf1, 0xc0,
	0x7e, 0xeb, 0x94, 0x3b, 0xa6, 0xe7, 0x71, 0x4d, 0x48, 0x0e, 0xc3, 0xa4, 0xac, 0x69, 0x14, 0x25,
	0x20, 0xe0, 0x5c, 0xc1, 0x63, 0xbe, 0xba, 0x03, 0x19, 0x15, 0xbc, 0x75, 0xbf, 0x0e, 0x1c, 0x56,
	0xfe, 0xc5, 0x51, 0x42, 0x74, 0x1e, 0x1c, 0xfd, 0xb0, 0x65, 0x92, 0x5d, 0x30, 0xcc, 0x31, 0x49,
	0x65, 0xb8, 0xff, 0x5f, 0x24, 0x33, 0xc8, 0xbe, 0x15, 0xe2, 0xf9, 0x94, 0x7a, 0x0b, 0x0b, 0x22,
	0x05, 0xcb, 0x40, 0x80, 0x4d, 0xc7, 0xb7, 0xa0, 0x7b, 0x91, 0xd3, 0x4c, 0xdb, 0x19, 0x77, 0x33,
	0xbf, 0x69, 0xc0, 0xc1, 0xa2, 0x42, 0x87, 0xab, 0xeb, 0xcb, 0x26, 0xa3, 0x5a, 0xd4, 0x96, 0xeb,
	0xbb, 0xcd, 0x56, 0x53, 0xb6, 0xd1, 0x34, 0xf4, 0x13, 0x64, 0x56, 0x0d, 0x91, 0x6c, 0x65, 0xb8,
	0xf3, 0xd5, 0x6b, 0xa8, 0x24, 0x2c, 0x8c, 0x21, 0x43, 0x48, 0x5f, 0x26, 0xf3, 0xa1, 0x70, 0x5d,
	0xbb, 0x69, 0x63, 0xe3, 0xde, 0x73, 0xe9, 0xd6, 0x76, 0x3d, 0x06, 0x6d, 0x74, 0xfc, 0x6d, 0x78,
	0xc1, 0x3d, 0x16, 0xc9, 0x74, 0x3c, 0x7c, 0x1b, 0x9b, 0x1c, 0x00, 0x02, 0xce, 0x09, 0x5a, 0x61,
	0xc8, 0x22, 0x99, 0x89, 0x87, 0x04, 0x6f, 0x70, 0x00, 0x08, 0x38, 0xfd, 0x1a, 0x99, 0x8c, 0xf7,
	0x6e, 0x87, 0xe2, 0xa3, 0x9f, 0x1c, 0x34, 0x3f, 0xad, 0xd2, 0xc2, 0x7b, 0x90, 0xdc, 0x7d, 0x76,
	0xc3, 0xf1, 0xf6, 0x5d, 0xbf, 0x21, 0x39, 0x4b, 0x85, 0xe2, 0x86, 0xfc, 0x09, 0x5a, 0x66, 0xf9,
	0xbb, 0x39, 0x32, 0x03, 0x0c, 0x63, 0x1d, 0xb4, 0x67, 0xf4, 0x98, 0xab, 0x72, 0x97, 0x08, 0xc1,
	0xc5, 0x5c, 0xdc, 0xae, 0x94, 0xd7, 0xc7, 0x01, 0xdb, 0x29, 0x14, 0x0c, 0x0a, 0xae, 0x4d, 0xc4,
	0x89, 0xe3, 0xd7, 0x9d, 0xa8, 0xee, 0xbe, 0x23, 0xbe, 0x4c, 0x19, 0xb1, 0x5f, 0xd1, 0x60, 0x30,
	0x69, 0xca, 0xff, 0x60, 0x94, 0xcc, 0x67, 0x13, 0xf8, 0x7b, 0x5d, 0x28, 0x5e, 0x21, 0x73, 0x7c,
	0xb1, 0x76, 0xfd, 0x46, 0xc5, 0x4d, 0xcc, 0x8a, 0xc8, 0x18, 0xfb, 0x5b, 0xb1, 0x51, 0x90, 0xa5,
	0xe5, 0xf3, 0xdc, 0x0e, 0xb6, 0x18, 0xd1, 0x17, 0xb7, 0x1e, 0x1b, 0x68, 0xb1, 0x4f, 0x0a, 0x09,
	0x6b, 0x86, 0x9e, 0xba, 0x6b, 0xf3, 0x04, 0xd7, 0x55, 0xb7, 0x47, 0x59, 0x72, 0x1a, 0xa3, 0x7a,
	0x82, 0x4e, 0x69, 0x91, 0x12, 0x20, 0x95, 0x45, 0x5f, 0x26, 0xb3, 0x4d, 0xc7, 0x6f, 0x39, 0x9e,
	0xc8, 0xd2, 0x97, 0xe7, 0x58, 0x05, 0x11, 0x35, 0xb3, 0x65, 0x61, 0x20, 0x43, 0x49, 0xbf, 0x9e,
	0x23, 0x53, 0x3a, 0x90, 0x26, 0xc6, 0x4b, 0xc8, 0x07, 0x72, 0x4b, 0x65, 0x8e, 0x65, 0xf4, 0xc9,
	0x8a, 0x86, 0xc5, 0x60, 0x8a, 0xec, 0xac, 0x8b, 0x4d, 0x9c, 0x4c, 0x17, 0x2b, 0xff, 0xcb, 0x3c,
	0x19, 0x17, 0x61, 0x9f, 0x67, 0xe0, 0xc3, 0xdb, 0xb5, 0x7c, 0x78, 0x6b, 0x83, 0x84, 0x56, 0xf0,
	0x1e, 0x77, 0x75, 0xdf, 0xf9, 0x19, 0xf7, 0xdd, 0xc6, 0xc0, 0x92, 0x8e, 0xf7, 0xdc, 0xfd, 0x28,
	0x4f, 0xe6, 0x04, 0xa1, 0x76, 0xda, 0x3d, 0xe4, 0xb4, 0x38, 0x43, 0xfe, 0xbe, 0xbf, 0xee, 0x78,
	0x7f, 0xdd, 0x6f, 0xe5, 0x88, 0x0c, 0x68, 0x3e, 0x03, 0x57, 0x1d, 0xb3, 0x5d, 0x75, 0xaf, 0x0e,
	0x3a, 0x7b, 0xba, 0x78, 0xe9, 0xfe, 0xcd, 0x98, 0x7a, 0xa6, 0x7e, 0xad, 0xea, 0x2a, 0x99, 0xe4,
	0x5b, 0x6a, 0x72, 0xc0, 0x4d, 0xe4, 0x7c, 0xef, 0x26, 0x72, 0xea, 0x53, 0x59, 0x57, 0xad, 0x41,
	0x33, 0xb2, 0x4c, 0xce, 0xd1, 0x53, 0x37, 0x39, 0x3f, 0xa5, 0x62, 0xd8, 0x31, 0xc1, 0x48, 0x4c,
	0x98, 0xc7, 0x74, 0xfc, 0xba, 0xd2, 0xaa, 0xf4, 0x2f, 0x30, 0xe8, 0xe9, 0x0b, 0x64, 0x7c, 0x17,
	0x2f, 0xb0, 0x97, 0x33, 0xe8, 0x92, 0x28, 0xee, 0xc5, 0x21, 0x0f, 0xd0, 0x52, 0xe7, 0x94, 0xe2,
	0x37, 0x48, 0xca, 0xb6, 0x6b, 0xca, 0x27, 0x7a, 0xb9, 0xa6, 0x5c, 0x9b, 0xc6, 0x85, 0x93, 0x98,
	0xc6, 0x93, 0xc3, 0x32, 0x8d, 0x49, 0x9f, 0xa6, 0xb1, 0x4f, 0xc6, 0x6b, 0xad, 0x38, 0x09, 0x9a,
	0x32, 0xff, 0x77, 0x00, 0x6f, 0xec, 0x2a, 0xf2, 0x31, 0x96, 0x5e, 0x11, 0xbd, 0x21, 0xa0, 0x52,
	0x4a, 0xf9, 0x8f, 0x46, 0xc9, 0xb4, 0xb9, 0x66, 0xbe, 0xa7, 0x5c, 0x99, 0x2f, 0x28, 0x7f, 0xad,
	0x70, 0x0e, 0x3d, 0x96, 0xf5, 0xd7, 0x4e, 0x89, 0x27, 0xb3, 0x5c, 0xb5, 0xd2, 0x70, 0x1e, 0x3b,
	0x91, 0xe1, 0x3c, 0x3e, 0xb8, 0x77, 0x74, 0xa2, 0x07, 0xef, 0xa8, 0xf2, 0x4f, 0x16, 0x4e, 0xcb,
	0x3f, 0xf9, 0x55, 0xcb, 0xee, 0x9e, 0x1c, 0x54, 0x07, 0xca, 0x6c, 0x8a, 0x0f, 0xb5, 0xba, 0xef,
	0x93, 0x59, 0xb9, 0x2e, 0x28, 0x95, 0x4e, 0x69, 0x18, 0xb9, 0xd3, 0xd5, 0x30, 0xca, 0x11, 0x59,
	0xec, 0x10, 0xde, 0xc9, 0x27, 0x43, 0x2d, 0x6c, 0xa1, 0xf4, 0x9c, 0x9e, 0x0c, 0xab, 0x61, 0x0b,
	0x38, 0x9c, 0xa3, 0x9b, 0xac, 0x29, 0x15, 0xff, 0x14, 0xbd, 0xc5, 0x9a, 0xc0, 0xe1, 0x1c, 0xdd,
	0x08, 0x5b, 0xb2, 0x78, 0x4c, 0x8a, 0xbe, 0xce, 0x5b, 0x37, 0xc2, 0x16, 0xde, 0xfd, 0x8e, 0xb5,
	0x1d, 0xde, 0x4b, 0x77, 0xbf, 0x8b, 0x1a, 0x23, 0x67, 0x70, 0xf7, 0xbb, 0x10, 0x74, 0xbc, 0x9e,
	0xf6, 0x7b, 0x79, 0x32, 0x8b, 0x74, 0x3d, 0x5f, 0xc0, 0x63, 0x53, 0xbf, 0xaf, 0xa5, 0x1d, 0xaf,
	0xa5, 0xfd, 0x49, 0x8e, 0x2c, 0xe0, 0x88, 0x99, 0xb9, 0xd2, 0xf4, 0xbe, 0x91, 0x85, 0xfd, 0xe4,
	0x50, 0xb3, 0xb0, 0x31, 0x4f, 0x54, 0x41, 0xb4, 0x81, 0x97, 0xa6, 0x62, 0x87, 0x64, 0x72, 0xcf,
	0x65, 0x91, 0x13, 0xd5, 0xf6, 0x0e, 0x30, 0x57, 0x6b, 0xa0, 0xa9, 0x7c, 0x43, 0xb1, 0x12, 0x9b,
	0x52, 0xfa, 0x13, 0xb4, 0x10, 0xbc, 0xd1, 0x07, 0x47, 0xe0, 0x3d, 0x75, 0xa3, 0x0f, 0xf6, 0xb8,
	0x8b, 0x96, 0xfa, 0x0b, 0xea, 0x9d, 0x9a, 0x35, 0x84, 0x7a, 0xf5, 0x28, 0xbc, 0x4e, 0x26, 0x70,
	0xc3, 0x5e, 0x4e, 0xfa, 0xd8, 0xfa, 0x91, 0x65, 0x45, 0x34, 0x07, 0xc5, 0xa7, 0xfc, 0xbf, 0x16,
	0xe4, 0x08, 0x9f, 0x61, 0xe9, 0x50, 0x7d, 0x25, 0xf3, 0xe8, 0x40, 0x57, 0x32, 0x67, 0x83, 0x7b,
	0xc7, 0x4e, 0x50, 0x85, 0xe7, 0xff, 0x91, 0x5b, 0xd6, 0x43, 0x42, 0xd2, 0x1f, 0x2f, 0x48, 0x5d,
	0x7a, 0x5b, 0x6f, 0x43, 0x1c, 0x3a, 0x04, 0x81, 0x86, 0x0c, 0xdc, 0x63, 0xb0, 0x96, 0x94, 0x74,
	0x11, 0x0e, 0xea, 0xa3, 0xd1, 0x95, 0xd9, 0xc4, 0x2b, 0x16, 0xbf, 0x41, 0x0a, 0x91, 0x65, 0x86,
	0xc8, 0xbb, 0x50, 0x66, 0xe8, 0x5b, 0x46, 0xae, 0x8f, 0x5a, 0x0c, 0xa5, 0xd6, 0x3f, 0xac, 0xe2,
	0x30, 0xe7, 0xcc, 0x4c, 0x9f, 0x74, 0xc1, 0x6d, 0x93, 0xca, 0x97, 0xa6, 0x38, 0xf4, 0x5c, 0x55,
	0x08, 0x68, 0x75, 0xc0, 0x32, 0xb6, 0x9c, 0x95, 0x74, 0xd7, 0xf3, 0x7f, 0x41, 0x30, 0x37, 0xcb,
	0xcd, 0xcc, 0x1c, 0x53, 0x6e, 0x66, 0x95, 0x2c, 0x64, 0x4a, 0x3e, 0xa4, 0x27, 0x68, 0x68, 0x98,
	0x6d, 0x64, 0x91, 0xd0, 0x4e, 0x6f, 0x15, 0x8e, 0x99, 0xeb, 0xb1, 0x70, 0xcc, 0x7c, 0x4f, 0x85,
	0x63, 0x16, 0x8e, 0x2d, 0x1c, 0xf3, 0x32, 0x99, 0xc5, 0x71, 0x4a, 0x2b, 0xde, 0xc8, 0x8a, 0x39,
	0xc2, 0x47, 0x69, 0x61, 0x20, 0x43, 0x49, 0x5f, 0x25, 0xf3, 0xcd, 0xf4, 0x3a, 0x3c, 0x51, 0x08,
	0x47, 0x16, 0xd1, 0x39, 0x27, 0xea, 0xa3, 0xdb, 0x38, 0x68, 0xa3, 0x4e, 0x39, 0x18, 0x05, 0x62,
	0x64, 0xd9, 0x1c, 0xcd, 0xc1, 0x2c, 0x1e, 0xd3, 0x46, 0x6d, 0x39, 0x13, 0x2e, 0x9c, 0xdd, 0xf9,
	0x75, 0xb1, 0x8b, 0x91, 0xde, 0xd5, 0xbe, 0xbe, 0xd8, 0xa7, 0x7d, 0x9d, 0xa9, 0xf6, 0x72, 0xe9,
	0xec, 0xaa, 0xbd, 0x5c, 0x31, 0xbc, 0xe6, 0x8f, 0xea, 0x39, 0xd4, 0xc1, 0xcf, 0x6d, 0xd4, 0xe6,
	0x79, 0xec, 0x98, 0xda, 0x3c, 0x6d, 0x25, 0x68, 0x1f, 0x7f, 0x37, 0x4a, 0xd0, 0x7e, 0x85, 0x10,
	0x3d, 0x0d, 0x65, 0x8d, 0xa0, 0x41, 0x53, 0x87, 0xd2, 0xfb, 0x20, 0xb5, 0xd5, 0xa3, 0xe1, 0x60,
	0xc8, 0x53, 0x21, 0x5e, 0xa5, 0x0e, 0x35, 0x67, 0xbe, 0xda, 0xa6, 0xc6, 0x0e, 0x5a, 0x95, 0xd1,
	0xd6, 0x65, 0xd5, 0xd8, 0x98, 0x50, 0xad, 0xcb, 0x96, 0xbf, 0x79, 0x99, 0x4c, 0x19, 0x36, 0x8e,
	0x71, 0xf3, 0x7e, 0xee, 0xd8, 0x9b, 0xf7, 0x7d, 0x72, 0xb9, 0xbd, 0xe0, 0x0d, 0xd2, 0xbc, 0xe9,
	0xb8, 0x89, 0xeb, 0x37, 0xe4, 0x71, 0xe4, 0x33, 0xb2, 0xfd, 0xe5, 0x8d, 0x63, 0xa9, 0xe1, 0x21,
	0xdc, 0xe8, 0xdb, 0xa4, 0xd4, 0x85, 0x42, 0xed, 0x1b, 0xf2, 0x1c, 0xf3, 0x43, 0x52, 0x60, 0x69,
	0xe3, 0x78, 0x72, 0x78, 0x18, 0x3f, 0xba, 0x47, 0x1e, 0xeb, 0x4c, 0xb2, 0xe1, 0xe0, 0x0a, 0x2b,
	0x0e, 0x41, 0x9f, 0x92, 0xf2, 0x1e, 0xdb, 0x38, 0x86, 0x16, 0x8e, 0xe5, 0x74, 0xcc, 0x60, 0xca,
	0x84, 0x4c, 0x79, 0x74, 0xfa, 0xb0, 0xc1, 0x94, 0xd4, 0xf0, 0x10, 0x6e, 0xb4, 0x42, 0xce, 0x0b,
	0xb5, 0x22, 0xfb, 0xce, 0xc4, 0x21, 0xeb, 0xe3, 0x52, 0xcc, 0xf9, 0x4a, 0x27, 0x22, 0xe8, 0xdc,
	0x96, 0xbe, 0x45, 0x1e, 0xb1, 0x11, 0x71, 0xfa, 0x66, 0xc4, 0x51, 0x6c, 0x49, 0xb2, 0x7d, 0xa4,
	0xd2, 0x99, 0x0c, 0xba, 0xb5, 0xa7, 0x5b, 0x64, 0xd1, 0x42, 0xc9, 0x17, 0x20, 0x0e, 0x70, 0xd3,
	0x8a, 0x00, 0x95, 0x76, 0x12, 0xe8, 0xd4, 0x8e, 0x6e, 0x93, 0x73, 0x16, 0x58, 0x0d, 0xb2, 0xa8,
	0xbb, 0x9a, 0xd6, 0x39, 0xa8, 0x74, 0xa0, 0x81, 0x8e, 0x2d, 0x79, 0x07, 0x65, 0x9e, 0xad, 0x35,
	0x9c, 0xc4, 0xee, 0x60, 0xb5, 0x9d, 0x04, 0x3a, 0xb5, 0xc3, 0xd2, 0x3c, 0x06, 0x58, 0x44, 0x30,
	0x19, 0x99, 0x35, 0x26, 0xa3, 0x18, 0x6c, 0x5a, 0x7a, 0x9d, 0x2c, 0x18, 0x00, 0x39, 0x54, 0xd3,
	0xc8, 0x40, 0xa7, 0x2f, 0x67, 0x09, 0xa0, 0xbd, 0x0d, 0x66, 0xf5, 0x62, 0x01, 0x3e, 0xd9, 0x89,
	0x19, 0xe4, 0xa1, 0xb3, 0x7a, 0x0d, 0x1c, 0x58, 0x94, 0xb6, 0x73, 0x76, 0x76, 0x88, 0xce, 0xd9,
	0x5f, 0xc8, 0x91, 0x47, 0xdb, 0xe7, 0xb6, 0xae, 0x09, 0x35, 0x77, 0x62, 0x59, 0xa5, 0xa3, 0xc3,
	0xd2, 0xa3, 0x1b, 0xdd, 0x59, 0xc2, 0x71, 0xf2, 0xe8, 0x37, 0x73, 0xe4, 0x62, 0x3b, 0x5e, 0x55,
	0x8d, 0x9a, 0x3f, 0x71, 0x6f, 0x1e, 0x3b, 0x3a, 0x2c, 0x15, 0xdb, 0x7a, 0xa3, 0x1c, 0xca, 0xdd,
	0x45, 0xd1, 0xb0, 0x53, 0xf1, 0xaf, 0x85, 0xfe, 0x1c, 0x3d, 0xe9, 0xbc, 0x3f, 0xb6, 0xfa, 0xd7,
	0x97, 0xda, 0xab, 0x7f, 0x2d, 0xf6, 0x57, 0x91, 0x2b, 0x95, 0x77, 0xa2, 0xf2, 0x5f, 0xe7, 0xce,
	0xb0, 0xfc, 0xd7, 0xf9, 0xd3, 0x2e, 0xff, 0x75, 0x61, 0x48, 0x27, 0x0d, 0x57, 0xc9, 0xe4, 0x0e,
	0x8b, 0x13, 0x91, 0x12, 0xfc, 0x88, 0xed, 0xca, 0x5f, 0x51, 0x08, 0xd0, 0x34, 0xf4, 0xd3, 0x64,
	0x36, 0xfd, 0x21, 0x8a, 0x79, 0x15, 0xd1, 0x4d, 0x9c, 0xd6, 0x9b, 0x59, 0xb1, 0xb0, 0x90, 0xa1,
	0xce, 0x14, 0x3b, 0xba, 0xd8, 0x53, 0xb1, 0x23, 0xbb, 0xbc, 0xd4, 0xa5, 0x9e, 0xca, 0x4b, 0xa5,
	0x55, 0xac, 0x1e, 0xed, 0x52, 0xc5, 0x0a, 0x75, 0x98, 0x1e, 0x6e, 0xfd, 0x79, 0xac, 0xaf, 0x23,
	0x92, 0xb6, 0xb2, 0x3a, 0x8f, 0xff, 0x44, 0x94, 0xd5, 0xb9, 0xfc, 0x13, 0x53, 0x56, 0xa7, 0xf4,
	0x2e, 0x95, 0xd5, 0x79, 0x5e, 0x5c, 0x41, 0x20, 0xd4, 0xee, 0x35, 0xac, 0x76, 0x34, 0xa2, 0xaf,
	0x15, 0x90, 0x60, 0x30, 0x69, 0xe8, 0x73, 0xe6, 0x71, 0xd7, 0x07, 0x75, 0xb8, 0x76, 0xc7, 0xa3,
	0xae, 0x6c, 0xa9, 0x9d, 0x72, 0x3f, 0xa5, 0x76, 0x9e, 0xec, 0xab, 0xd4, 0xce, 0x53, 0x3d, 0x97,
	0xda, 0x31, 0x2b, 0xe7, 0x3c, 0xfd, 0x90, 0x0b, 0xa3, 0x74, 0xe1, 0xd5, 0x67, 0xf0, 0xd1, 0xbf,
	0xc8, 0x1f, 0x65, 0xc5, 0x89, 0xd3, 0xbb, 0x36, 0x1e, 0x1c, 0x96, 0x36, 0xfb, 0x75, 0x93, 0xc9,
	0x1a, 0xd2, 0x69, 0x56, 0x2f, 0x7e, 0xc6, 0xba, 0x98, 0x6b, 0xc7, 0xaa, 0x31, 0x1f, 0x7a, 0x97,
	0xaa, 0xc6, 0x64, 0x52, 0x3c, 0xae, 0xbc, 0x3b, 0x29, 0x1e, 0xcf, 0x9e, 0xd6, 0x11, 0xea, 0xaf,
	0xe7, 0x48, 0xb1, 0xa3, 0xe6, 0x92, 0xb4, 0x62, 0x2c, 0x7f, 0x34, 0x50, 0x50, 0xe3, 0x46, 0x17,
	0xce, 0x2b, 0x4f, 0xc8, 0xae, 0x14, 0xbb, 0x51, 0x40, 0xd7, 0x5e, 0x65, 0xaa, 0x7b, 0x3c, 0x37,
	0x68, 0x75, 0x0f, 0xfb, 0x8c, 0xed, 0xa1, 0x87, 0xbe, 0xff, 0x3b, 0x47, 0x8a, 0xdd, 0x62, 0x35,
	0xe5, 0xed, 0x11, 0x2b, 0xad, 0x7a, 0x83, 0x25, 0xd2, 0x30, 0x56, 0xb7, 0x47, 0x08, 0x20, 0x68,
	0x3c, 0x7d, 0x85, 0xcc, 0x31, 0xcf, 0x6d, 0xba, 0xbe, 0xf8, 0x42, 0x9d, 0x84, 0x49, 0x5b, 0x18,
	0xe3, 0x1d, 0xd7, 0x6d, 0x14, 0x64, 0x69, 0x69, 0x48, 0x0a, 0xcd, 0xa0, 0x8e, 0xd1, 0xcd, 0xf2,
	0x14, 0xa1, 0x8a, 0x97, 0x4f, 0x48, 0xd8, 0x83, 0xc3, 0xd2, 0xda, 0x00, 0x35, 0x71, 0x91, 0x07,
	0xce, 0xc7, 0x54, 0x4a, 0xf9, 0x57, 0xf2, 0xe4, 0x7c, 0xdb, 0xa3, 0xe3, 0x39, 0x48, 0x99, 0x8c,
	0xef, 0x98, 0x0f, 0x8d, 0x4e, 0x47, 0xf9, 0xc4, 0x12, 0x43, 0x9f, 0x26, 0x13, 0x3b, 0x91, 0x53,
	0xbb, 0xcb, 0x12, 0x33, 0x0e, 0x7c, 0x45, 0x80, 0x40, 0xe1, 0xe8, 0x63, 0x64, 0x34, 0x6a, 0xa5,
	0x56, 0x3a, 0x86, 0xb0, 0x42, 0xcb, 0x6f, 0x00, 0x42, 0x45, 0x05, 0x0f, 0x7f, 0xf7, 0xe6, 0x9a,
	0xb4, 0xaa, 0x65, 0x05, 0x0f, 0x0e, 0x01, 0x89, 0xb1, 0x06, 0xe6, 0xd2, 0x99, 0x0c, 0xcc, 0x6f,
	0x8c, 0x90, 0xf9, 0x2a, 0xbb, 0x9f, 0x58, 0xd7, 0xca, 0x35, 0xb9, 0xda, 0x86, 0x85, 0x21, 0xe5,
	0xb9, 0x50, 0x45, 0xa8, 0x62, 0x08, 0x1a, 0xa4, 0x13, 0x5c, 0x12, 0xb2, 0xe1, 0x7b, 0x82, 0x92,
	0xc1, 0xa7, 0x5e, 0x12, 0xdc, 0x65, 0xbe, 0xfb, 0x8e, 0xbc, 0x73, 0x45, 0x6e, 0x57, 0x55, 0x05,
	0x04, 0x8d, 0x17, 0x77, 0x37, 0x04, 0xe1, 0xbd, 0x20, 0xaa, 0xc7, 0x32, 0xae, 0x57, 0x1a, 0x53,
	0x41, 0xf8, 0x26, 0x07, 0x82, 0xc6, 0xd3, 0x8b, 0x64, 0x24, 0x0c, 0x62, 0x79, 0x67, 0x0c, 0x3a,
	0xa5, 0xb6, 0x83, 0x18, 0x38, 0x0c, 0x83, 0xa8, 0x59, 0xb3, 0xe9, 0xc8, 0xc8, 0x55, 0x11, 0x44,
	0xcd, 0x01, 0x20, 0xe0, 0xfc, 0x6d, 0xc6, 0x09, 0x6b, 0xa2, 0xc3, 0xa0, 0x20, 0xde, 0x66, 0x25,
	0x61, 0x4d, 0x40, 0x28, 0xef, 0x06, 0x6b, 0xee, 0xb0, 0x7a, 0x5d, 0x19, 0xff, 0xb2, 0xcf, 0xeb,
	0x0a, 0x08, 0x1a, 0xcf, 0xbb, 0x11, 0xef, 0xab, 0x7a, 0x15, 0xd8, 0x8d, 0xca, 0x7e, 0x1d, 0x38,
	0x0c, 0xfd, 0xc4, 0xce, 0xfd, 0xca, 0x7e, 0x7d, 0x35, 0x68, 0x86, 0x81, 0x8f, 0x09, 0x53, 0xc2,
	0x48, 0x17, 0x7e, 0xe2, 0x0c, 0x0e, 0xda, 0xa8, 0xcb, 0xff, 0x61, 0x86, 0x50, 0xae, 0x19, 0x57,
	0x58, 0xe4, 0xb2, 0x58, 0x78, 0xfd, 0x59, 0x8d, 0x2e, 0x11, 0x92, 0xb8, 0x4d, 0x26, 0x4a, 0x7f,
	0xc8, 0xd7, 0x88, 0x11, 0xd3, 0xd5, 0x14, 0x0a, 0x06, 0x05, 0xaa, 0x01, 0x4e, 0xd4, 0x60, 0x89,
	0x6c, 0x61, 0xa4, 0xac, 0x56, 0x0d, 0x38, 0x58, 0x54, 0x7c, 0x4f, 0xaf, 0x3b, 0x09, 0xe3, 0x7c,
	0x44, 0xac, 0x98, 0xba, 0xec, 0x9a, 0xef, 0xe9, 0x6b, 0x4e, 0xc2, 0xaa, 0x29, 0x06, 0x32, 0x94,
	0x34, 0x24, 0x13, 0x7b, 0x01, 0xdf, 0xe5, 0x0f, 0xe4, 0xe1, 0xe0, 0x00, 0x31, 0x0c, 0x37, 0x04,
	0x23, 0xe1, 0xfc, 0x55, 0xa7, 0xec, 0x12, 0x08, 0x4a, 0x0c, 0x57, 0x5a, 0x1a, 0x51, 0xd0, 0x0a,
	0xe5, 0x23, 0x1a, 0x87, 0x88, 0xd7, 0x35, 0x18, 0x4c, 0x1a, 0xfe, 0x80, 0x71, 0x6b, 0xc7, 0x40,
	0xcb, 0xe3, 0x44, 0x7c, 0xc0, 0x8a, 0x85, 0x81, 0x0c, 0x25, 0x5d, 0x25, 0x0b, 0x71, 0x6b, 0xc7,
	0x26, 0x32, 0xc3, 0x8c, 0x2b, 0x59, 0x24, 0xb4, 0xd3, 0xd3, 0xbb, 0x64, 0x62, 0xcf, 0x8d, 0x93,
	0x20, 0x52, 0x97, 0xf2, 0x0d, 0x72, 0x1d, 0x51, 0x9a, 0x3b, 0x22, 0x56, 0xb0, 0x1b, 0x82, 0x31,
	0x28, 0x09, 0xd4, 0x37, 0x3c, 0xb5, 0x93, 0x43, 0x94, 0x86, 0xca, 0x9a, 0x72, 0xcf, 0x1a, 0x61,
	0x06, 0xdf, 0xcb, 0x91, 0x85, 0x03, 0x71, 0xed, 0x8c, 0x4e, 0x78, 0x91, 0x47, 0x80, 0xb7, 0x07,
	0x96, 0x6c, 0x27, 0xfd, 0x68, 0xb5, 0xfb, 0xad, 0xac, 0x44, 0x68, 0xef, 0x04, 0x76, 0xed, 0x1e,
	0x63, 0x77, 0xed, 0xae, 0x4d, 0x9d, 0x72, 0xd7, 0xde, 0xcc, 0x4a, 0x84, 0xf6, 0x4e, 0xd0, 0x5f,
	0xce, 0x91, 0xf9, 0xba, 0xe3, 0xda, 0x3d, 0x9b, 0x3e, 0x9d, 0x9e, 0xe9, 0x6b, 0x94, 0x33, 0x02,
	0xa1, 0xad, 0x0b, 0xf4, 0x63, 0x64, 0xbc, 0x11, 0x05, 0xf7, 0x92, 0x3d, 0x99, 0xd6, 0x57, 0xe4,
	0x3b, 0xdc, 0x75, 0x84, 0x70, 0xfb, 0x55, 0xfc, 0x87, 0xe9, 0x4c, 0x92, 0x8e, 0x7e, 0x99, 0xdb,
	0xc9, 0x32, 0x0b, 0x24, 0x96, 0x75, 0xa2, 0xaf, 0x0f, 0x12, 0x7a, 0x66, 0x64, 0x94, 0x98, 0x06,
	0xb7, 0x12, 0x01, 0x86, 0x38, 0xfa, 0xb7, 0x72, 0x64, 0x51, 0xc4, 0x5e, 0xea, 0x87, 0x70, 0x59,
	0x5c, 0x9c, 0x1b, 0xf4, 0xd6, 0xf9, 0xd5, 0x0c, 0x53, 0x31, 0x92, 0xa9, 0xfd, 0xb9, 0xda, 0x2e,
	0x13, 0x3a, 0x75, 0x04, 0x8f, 0x95, 0x6a, 0x7b, 0x8e, 0xdf, 0x60, 0x58, 0x1b, 0x30, 0x96, 0xde,
	0xb6, 0x9b, 0x03, 0x5d, 0x0e, 0xe3, 0x37, 0x18, 0xd6, 0x1c, 0xb4, 0x8f, 0x4e, 0x0c, 0x44, 0x0c,
	0x96, 0x50, 0xfa, 0x71, 0x32, 0xed, 0xfa, 0x09, 0xdb, 0x77, 0xbc, 0x37, 0xdd, 0x7a, 0xb2, 0x87,
	0x2e, 0xb7, 0x9c, 0x9d, 0xe2, 0x84, 0x08, 0xb0, 0xc8, 0xe8, 0x06, 0xa1, 0x2d, 0xbf, 0xc6, 0xa2,
	0xc4, 0x71, 0xfd, 0xe4, 0x40, 0x5c, 0xb4, 0x16, 0xe3, 0x11, 0xec, 0x98, 0xf0, 0xc1, 0xbd, 0xd1,
	0x86, 0x85, 0x0e, 0x2d, 0xca, 0xbf, 0x3a, 0x41, 0xa6, 0xcd, 0x93, 0x74, 0x2b, 0x7d, 0x34, 0x77,
	0x36, 0xe9, 0xa3, 0x75, 0x32, 0x5e, 0xdb, 0xc7, 0x60, 0xb7, 0xbc, 0xae, 0x85, 0xb5, 0xba, 0x2f,
	0x43, 0xdd, 0xfa, 0x0e, 0xb9, 0x10, 0x1c, 0x40, 0xf2, 0xa6, 0x17, 0xb0, 0xf6, 0xbb, 0x50, 0x69,
	0xc6, 0x8d, 0x8a, 0xed, 0x25, 0x32, 0xb6, 0x1b, 0x78, 0x75, 0x95, 0x92, 0x86, 0x9a, 0xca, 0x06,
	0x07, 0x80, 0x80, 0xd3, 0xd8, 0xbe, 0xb0, 0x79, 0x0c, 0xd3, 0xa1, 0x5f, 0xe7, 0xdb, 0xda, 0xba,
	0x06, 0x0f, 0x21, 0x36, 0xc4, 0xba, 0xf3, 0x99, 0x2b, 0x40, 0xea, 0xbe, 0x30, 0xa9, 0x23, 0x09,
	0x05, 0x48, 0x01, 0x41, 0xe3, 0xf9, 0x64, 0xa8, 0xed, 0xb1, 0xda, 0x5d, 0x9c, 0x52, 0x69, 0xed,
	0xbb, 0x09, 0x3d, 0x19, 0x56, 0xdb, 0xb0, 0xd0, 0xa1, 0x05, 0x6d, 0x90, 0x7c, 0xac, 0xa2, 0x51,
	0x6e, 0x0f, 0x31, 0x61, 0x0d, 0x3f, 0x06, 0x1c, 0xf3, 0xca, 0x0d, 0xc8, 0xc7, 0x7b, 0xa8, 0xfc,
	0x31, 0x56, 0x97, 0x85, 0xea, 0x84, 0xf2, 0xc7, 0x58, 0x1d, 0x10, 0xda, 0x39, 0x60, 0x7d, 0xea,
	0xe4, 0x35, 0x31, 0x1a, 0x61, 0x0b, 0xd7, 0x6d, 0xa9, 0x14, 0xaa, 0x78, 0x55, 0x2e, 0xbd, 0xee,
	0xc6, 0x89, 0x8c, 0xcd, 0x10, 0x37, 0x10, 0xbb, 0x71, 0x02, 0x08, 0xe5, 0x23, 0xef, 0x07, 0x75,
	0xb6, 0x1a, 0xb4, 0xfc, 0x04, 0x8f, 0x1e, 0xa4, 0xa5, 0x76, 0x4b, 0x01, 0x41, 0xe3, 0xe9, 0x1e,
	0x19, 0x17, 0xf7, 0x1a, 0xca, 0x83, 0x83, 0x57, 0xfb, 0xf3, 0x5f, 0x89, 0xaf, 0x51, 0x5c, 0xa6,
	0x9b, 0xc6, 0x6b, 0x22, 0x0c, 0x24, 0xff, 0xf2, 0x8f, 0xf2, 0x64, 0xa1, 0xed, 0x3e, 0xe3, 0x5e,
	0xc3, 0xdd, 0xfa, 0x2b, 0x98, 0xf2, 0x34, 0x99, 0xf0, 0x9c, 0x1d, 0x23, 0x63, 0x4e, 0xe6, 0x38,
	0xef, 0x88, 0x0b, 0x1d, 0x25, 0x0e, 0xf5, 0x30, 0x6e, 0x29, 0xab, 0x03, 0x7e, 0xa3, 0x8a, 0x81,
	0xd0, 0xc3, 0xb2, 0x48, 0x68, 0xa7, 0x6f, 0x4b, 0x5b, 0x1b, 0x3b, 0xf3, 0xb4, 0xb5, 0xf2, 0x3f,
	0xcb, 0x93, 0x69, 0xf3, 0xfe, 0xe6, 0x33, 0xca, 0x4e, 0xcc, 0x3e, 0xf9, 0xc8, 0x4f, 0x48, 0xc2,
	0xde, 0xe8, 0x09, 0x13, 0xf6, 0xbe, 0x93, 0x23, 0x0b, 0x77, 0xdc, 0x3a, 0x0b, 0x2c, 0x5b, 0xf7,
	0x80, 0x10, 0xe1, 0xae, 0x41, 0xeb, 0x53, 0x6c, 0x28, 0x6f, 0xe1, 0xad, 0x51, 0x29, 0x74, 0x90,
	0x44, 0x6e, 0x14, 0xa8, 0x59, 0x81, 0x21, 0x6c, 0x65, 0xe9, 0x07, 0x3f, 0xbe, 0xfc, 0x81, 0xdf,
	0xfc, 0xf1, 0xe5, 0x0f, 0xfc, 0xf6, 0x8f, 0x2f, 0x7f, 0xe0, 0xeb, 0x47, 0x97, 0x73, 0x3f, 0x38,
	0xba, 0x9c, 0xfb, 0xcd, 0xa3, 0xcb, 0xb9, 0xdf, 0x3e, 0xba, 0x9c, 0xfb, 0xfd, 0xa3, 0xcb, 0xb9,
	0xef, 0xfe, 0xc1, 0xe5, 0x0f, 0x7c, 0xae, 0xa0, 0x78, 0xfd, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xb4, 0xf2, 0xa1, 0x0e, 0xd8, 0xe1, 0x00, 0x00,
}

func (m *AlgorithmSearchSpaceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlgorithmSearchSpaceSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlgorithmSearchSpaceSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TestAll != nil {
		i--
		if *m.TestAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.Baselines) > 0 {
		for iNdEx := len(m.Baselines) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Baselines[iNdEx])
			copy(dAtA[i:], m.Baselines[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Baselines[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.AlgorithmFilter != nil {
		i -= len(*m.AlgorithmFilter)
		copy(dAtA[i:], *m.AlgorithmFilter)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.AlgorithmFilter)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.StackingEnsemble != nil {
		i--
		if *m.StackingEnsemble {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.VotingEnsemble != nil {
		i--
		if *m.VotingEnsemble {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.AllowList) > 0 {
		for iNdEx := len(m.AllowList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowList[iNdEx])
			copy(dAtA[i:], m.AllowList[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.AllowList[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	return len(dAtA) - i, nil
}

func (m *AudioPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudioPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AudioPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Featurizer != nil {
		i -= len(*m.Featurizer)
		copy(dAtA[i:], *m.Featurizer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Featurizer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BacktestSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BacktestSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BacktestSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SlidingSteps != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.SlidingSteps))
		i--
		dAtA[i] = 0x20
	}
	if m.ForecastingWindowSize != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ForecastingWindowSize))
		i--
		dAtA[i] = 0x18
	}
	if m.TrainingWindowSize != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TrainingWindowSize))
		i--
		dAtA[i] = 0x10
	}
	if m.Sliding != nil {
		i--
		if *m.Sliding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CapacityStageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapacityStageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CapacityStageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Validations) > 0 {
		for iNdEx := len(m.Validations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ServingSiteName != nil {
		i -= len(*m.ServingSiteName)
		copy(dAtA[i:], *m.ServingSiteName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ServingSiteName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChangePointSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePointSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangePointSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Range))))
		i--
		dAtA[i] = 0x11
	}
	if m.N != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.N))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChatbotEstimatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatbotEstimatorSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatbotEstimatorSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Base != nil {
		i -= len(*m.Base)
		copy(dAtA[i:], *m.Base)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Base)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClassicalEstimatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassicalEstimatorSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassicalEstimatorSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i -= len(m.AlgorithmName)
	copy(dAtA[i:], m.AlgorithmName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.AlgorithmName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CronReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CronReportCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronReportCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronReportCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x22
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CronReportList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronReportList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronReportList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CronReportSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronReportSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronReportSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Notification.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.Paused != nil {
		i--
		if *m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.Template.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Range != nil {
		i -= len(*m.Range)
		copy(dAtA[i:], *m.Range)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Range)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CronReportStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronReportStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronReportStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x18
	if m.LastUpdated != nil {
		{
			size, err := m.LastUpdated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LastRun != nil {
		{
			size, err := m.LastRun.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CustomReportBarChart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomReportBarChart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomReportBarChart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sort != nil {
		i--
		if *m.Sort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Legend != nil {
		i--
		if *m.Legend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Y != nil {
		i -= len(*m.Y)
		copy(dAtA[i:], *m.Y)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Y)))
		i--
		dAtA[i] = 0x1a
	}
	if m.X != nil {
		i -= len(*m.X)
		copy(dAtA[i:], *m.X)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.X)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CustomReportHistogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomReportHistogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomReportHistogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bins != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Bins))
		i--
		dAtA[i] = 0x18
	}
	if m.X != nil {
		i -= len(*m.X)
		copy(dAtA[i:], *m.X)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.X)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CustomReportLineChart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomReportLineChart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomReportLineChart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Legend != nil {
		i--
		if *m.Legend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Y != nil {
		i -= len(*m.Y)
		copy(dAtA[i:], *m.Y)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Y)))
		i--
		dAtA[i] = 0x1a
	}
	if m.X != nil {
		i -= len(*m.X)
		copy(dAtA[i:], *m.X)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.X)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CustomReportScatterPlot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomReportScatterPlot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomReportScatterPlot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Y != nil {
		i -= len(*m.Y)
		copy(dAtA[i:], *m.Y)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Y)))
		i--
		dAtA[i] = 0x1a
	}
	if m.X != nil {
		i -= len(*m.X)
		copy(dAtA[i:], *m.X)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.X)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CustomReportSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomReportSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomReportSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScatterCharts) > 0 {
		for iNdEx := len(m.ScatterCharts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ScatterCharts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.HistCharts) > 0 {
		for iNdEx := len(m.HistCharts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HistCharts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BarCharts) > 0 {
		for iNdEx := len(m.BarCharts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BarCharts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LineCharts) > 0 {
		for iNdEx := len(m.LineCharts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LineCharts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CustomReportTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomReportTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomReportTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Border != nil {
		i--
		if *m.Border {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ShowIndex != nil {
		i--
		if *m.ShowIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Rows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Rows))
		i--
		dAtA[i] = 0x28
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupBy[iNdEx])
			copy(dAtA[i:], m.GroupBy[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.GroupBy[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Filters[iNdEx])
			copy(dAtA[i:], m.Filters[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Filters[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CustomReportValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomReportValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomReportValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Scalar != nil {
		i -= len(*m.Scalar)
		copy(dAtA[i:], *m.Scalar)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Scalar)))
		i--
		dAtA[i] = 0x22
	}
	if m.Row != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Row))
		i--
		dAtA[i] = 0x18
	}
	if m.Column != nil {
		i -= len(*m.Column)
		copy(dAtA[i:], *m.Column)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Column)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CustomSeasonalitySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomSeasonalitySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomSeasonalitySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FourierOrder != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.FourierOrder))
		i--
		dAtA[i] = 0x18
	}
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Period))))
	i--
	dAtA[i] = 0x11
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataHashes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataHashes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataHashes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidationHash != nil {
		i -= len(*m.ValidationHash)
		copy(dAtA[i:], *m.ValidationHash)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ValidationHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TestingHash != nil {
		i -= len(*m.TestingHash)
		copy(dAtA[i:], *m.TestingHash)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TestingHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.TrainingHash != nil {
		i -= len(*m.TrainingHash)
		copy(dAtA[i:], *m.TrainingHash)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TrainingHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataSplit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSplit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSplit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Seed != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Seed))
		i--
		dAtA[i] = 0x38
	}
	if m.SplitColumn != nil {
		i -= len(*m.SplitColumn)
		copy(dAtA[i:], *m.SplitColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SplitColumn)))
		i--
		dAtA[i] = 0x32
	}
	if m.SplitPolicy != nil {
		i -= len(*m.SplitPolicy)
		copy(dAtA[i:], *m.SplitPolicy)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SplitPolicy)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Test != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Test))
		i--
		dAtA[i] = 0x20
	}
	if m.Validation != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Validation))
		i--
		dAtA[i] = 0x18
	}
	if m.Train != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Train))
		i--
		dAtA[i] = 0x10
	}
	if m.Auto != nil {
		i--
		if *m.Auto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataStageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataStageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataStageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DockerImage != nil {
		i -= len(*m.DockerImage)
		copy(dAtA[i:], *m.DockerImage)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DockerImage)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DatasourceName != nil {
		i -= len(*m.DatasourceName)
		copy(dAtA[i:], *m.DatasourceName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasourceName)))
		i--
		dAtA[i] = 0x22
	}
	if m.DataPipelineName != nil {
		i -= len(*m.DataPipelineName)
		copy(dAtA[i:], *m.DataPipelineName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DataPipelineName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.LabName != nil {
		i -= len(*m.LabName)
		copy(dAtA[i:], *m.LabName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.LabName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeepEstimatorLayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeepEstimatorLayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeepEstimatorLayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InputLayers) > 0 {
		for iNdEx := len(m.InputLayers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InputLayers[iNdEx])
			copy(dAtA[i:], m.InputLayers[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.InputLayers[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeepEstimatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeepEstimatorSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeepEstimatorSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Loss)
	copy(dAtA[i:], m.Loss)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Loss)))
	i--
	dAtA[i] = 0x42
	if m.Gpus != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Gpus))
		i--
		dAtA[i] = 0x38
	}
	if m.Seq != nil {
		i--
		if *m.Seq {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ValidationSplit != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ValidationSplit))
		i--
		dAtA[i] = 0x28
	}
	if m.Epochs != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Epochs))
		i--
		dAtA[i] = 0x20
	}
	if m.BatchSize != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.BatchSize))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != nil {
		i -= len(*m.Type)
		copy(dAtA[i:], *m.Type)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Layers) > 0 {
		for iNdEx := len(m.Layers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Layers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentStageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentStageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentStageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Validations) > 0 {
		for iNdEx := len(m.Validations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ManualApproval != nil {
		i--
		if *m.ManualApproval {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ServingSiteName != nil {
		i -= len(*m.ServingSiteName)
		copy(dAtA[i:], *m.ServingSiteName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ServingSiteName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnsembleRules) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnsembleRules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnsembleRules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EnsembleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnsembleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnsembleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Base) > 0 {
		for iNdEx := len(m.Base) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Base[iNdEx])
			copy(dAtA[i:], m.Base[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Base[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *FeatureEngineeringPipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureEngineeringPipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureEngineeringPipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Passtrough != nil {
		i--
		if *m.Passtrough {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Drop != nil {
		i--
		if *m.Drop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.Custom) > 0 {
		for iNdEx := len(m.Custom) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Custom[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.Genereted) > 0 {
		for iNdEx := len(m.Genereted) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Genereted[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Audio != nil {
		{
			size, err := m.Audio.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Text != nil {
		{
			size, err := m.Text.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.DatetimeTransformation != nil {
		i -= len(*m.DatetimeTransformation)
		copy(dAtA[i:], *m.DatetimeTransformation)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatetimeTransformation)))
		i--
		dAtA[i] = 0x52
	}
	if m.OutlierHandling != nil {
		i -= len(*m.OutlierHandling)
		copy(dAtA[i:], *m.OutlierHandling)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.OutlierHandling)))
		i--
		dAtA[i] = 0x4a
	}
	if m.VariableTransformation != nil {
		i -= len(*m.VariableTransformation)
		copy(dAtA[i:], *m.VariableTransformation)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VariableTransformation)))
		i--
		dAtA[i] = 0x42
	}
	if m.Discretisation != nil {
		i -= len(*m.Discretisation)
		copy(dAtA[i:], *m.Discretisation)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Discretisation)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Scaling != nil {
		i -= len(*m.Scaling)
		copy(dAtA[i:], *m.Scaling)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Scaling)))
		i--
		dAtA[i] = 0x32
	}
	if m.Encoding != nil {
		i -= len(*m.Encoding)
		copy(dAtA[i:], *m.Encoding)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Encoding)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Imputation != nil {
		i -= len(*m.Imputation)
		copy(dAtA[i:], *m.Imputation)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Imputation)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	i -= len(m.DataType)
	copy(dAtA[i:], m.DataType)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DataType)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeatureEngineeringSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureEngineeringSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureEngineeringSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SamplePct != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.SamplePct))
		i--
		dAtA[i] = 0x40
	}
	if m.MaxTrainers != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxTrainers))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxTimeSec != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxTimeSec))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxModels != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxModels))
		i--
		dAtA[i] = 0x28
	}
	if m.Estimator != nil {
		i -= len(*m.Estimator)
		copy(dAtA[i:], *m.Estimator)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Estimator)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.FeatureSelection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Pipelines) > 0 {
		for iNdEx := len(m.Pipelines) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pipelines[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeatureEngineeringStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureEngineeringStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureEngineeringStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.BestPipeline.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeatureImportance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureImportance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureImportance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Importance))))
	i--
	dAtA[i] = 0x11
	i -= len(m.Feature)
	copy(dAtA[i:], m.Feature)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Feature)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeatureInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
	i--
	dAtA[i] = 0x19
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeatureSelectionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureSelectionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureSelectionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reserved) > 0 {
		for iNdEx := len(m.Reserved) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Reserved[iNdEx])
			copy(dAtA[i:], m.Reserved[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reserved[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.CumulativeImportancePrecent != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.CumulativeImportancePrecent))
		i--
		dAtA[i] = 0x28
	}
	if m.TopN != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TopN))
		i--
		dAtA[i] = 0x20
	}
	if m.CorrTreshold != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.CorrTreshold))
		i--
		dAtA[i] = 0x18
	}
	if m.VarianceTresholdPct != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.VarianceTresholdPct))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForecastObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForecastObj) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForecastObj) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintGenerated(dAtA, i, uint64(m.LevelIndex))
	i--
	dAtA[i] = 0x10
	i -= len(m.Key)
	copy(dAtA[i:], m.Key)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Key)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ForecastPostProcessingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForecastPostProcessingSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForecastPostProcessingSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Forecast != nil {
		i--
		if *m.Forecast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ConnectionName != nil {
		i -= len(*m.ConnectionName)
		copy(dAtA[i:], *m.ConnectionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ConnectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ForecastSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForecastSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForecastSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlotChangePoints != nil {
		i--
		if *m.PlotChangePoints {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Plot != nil {
		i--
		if *m.Plot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.PostPrecessing.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Backtest.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ConfidenceInterval != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ConfidenceInterval))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FormatSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FormatSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FormatSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GeneratedColumnSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneratedColumnSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeneratedColumnSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Expression)
	copy(dAtA[i:], m.Expression)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Expression)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Second)
	copy(dAtA[i:], m.Second)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Second)))
	i--
	dAtA[i] = 0x22
	i -= len(m.First)
	copy(dAtA[i:], m.First)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.First)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.DataType)
	copy(dAtA[i:], m.DataType)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DataType)))
	i--
	dAtA[i] = 0x12
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Hierarchy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Hierarchy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Hierarchy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NotifierName != nil {
		i -= len(*m.NotifierName)
		copy(dAtA[i:], *m.NotifierName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.NotifierName)))
		i--
		dAtA[i] = 0x22
	}
	if m.ItemLevel != nil {
		{
			size, err := m.ItemLevel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GroupLevels) > 0 {
		for iNdEx := len(m.GroupLevels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupLevels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HolidaySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HolidaySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HolidaySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Country != nil {
		i -= len(*m.Country)
		copy(dAtA[i:], *m.Country)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Country)))
		i--
		dAtA[i] = 0x12
	}
	if m.HolidayColumn != nil {
		i -= len(*m.HolidayColumn)
		copy(dAtA[i:], *m.HolidayColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.HolidayColumn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HyperParameterValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HyperParameterValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HyperParameterValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Value)
	copy(dAtA[i:], m.Value)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Value)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ImagePipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImagePipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImagePipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Featurizer != nil {
		i -= len(*m.Featurizer)
		copy(dAtA[i:], *m.Featurizer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Featurizer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Level) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Level) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Level) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Aggregate != nil {
		i -= len(*m.Aggregate)
		copy(dAtA[i:], *m.Aggregate)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Aggregate)))
		i--
		dAtA[i] = 0x22
	}
	if m.Freq != nil {
		i -= len(*m.Freq)
		copy(dAtA[i:], *m.Freq)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Freq)))
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.Horizon))
	i--
	dAtA[i] = 0x10
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Model) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelAutobuilder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelAutobuilder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAutobuilder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelAutobuilderCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelAutobuilderCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAutobuilderCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelAutobuilderList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelAutobuilderList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAutobuilderList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelAutobuilderSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelAutobuilderSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAutobuilderSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LabRef != nil {
		{
			size, err := m.LabRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Workload != nil {
		i -= len(*m.Workload)
		copy(dAtA[i:], *m.Workload)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Workload)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Aborted != nil {
		i--
		if *m.Aborted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Sampler != nil {
		i -= len(*m.Sampler)
		copy(dAtA[i:], *m.Sampler)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Sampler)))
		i--
		dAtA[i] = 0x7a
	}
	if m.Trainers != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Trainers))
		i--
		dAtA[i] = 0x70
	}
	if m.DataSourceSpec != nil {
		{
			size, err := m.DataSourceSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AutoScale != nil {
		i--
		if *m.AutoScale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.AccessMethod != nil {
		i -= len(*m.AccessMethod)
		copy(dAtA[i:], *m.AccessMethod)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.AccessMethod)))
		i--
		dAtA[i] = 0x5a
	}
	if m.MaxModels != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxModels))
		i--
		dAtA[i] = 0x50
	}
	if m.MaxTime != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxTime))
		i--
		dAtA[i] = 0x48
	}
	if m.TargetColumn != nil {
		i -= len(*m.TargetColumn)
		copy(dAtA[i:], *m.TargetColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TargetColumn)))
		i--
		dAtA[i] = 0x42
	}
	if m.Objective != nil {
		i -= len(*m.Objective)
		copy(dAtA[i:], *m.Objective)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Objective)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Task != nil {
		i -= len(*m.Task)
		copy(dAtA[i:], *m.Task)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Task)))
		i--
		dAtA[i] = 0x32
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0x22
	}
	if m.DataSourceName != nil {
		i -= len(*m.DataSourceName)
		copy(dAtA[i:], *m.DataSourceName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DataSourceName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DataProductVersionName != nil {
		i -= len(*m.DataProductVersionName)
		copy(dAtA[i:], *m.DataProductVersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DataProductVersionName)))
		i--
		dAtA[i] = 0x12
	}
	if m.DataProductName != nil {
		i -= len(*m.DataProductName)
		copy(dAtA[i:], *m.DataProductName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DataProductName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelAutobuilderStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelAutobuilderStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAutobuilderStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	i -= len(m.LastError)
	copy(dAtA[i:], m.LastError)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LastError)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	if m.EndTime != nil {
		{
			size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Estimator != nil {
		{
			size, err := m.Estimator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BestModelScore))))
	i--
	dAtA[i] = 0x79
	i = encodeVarintGenerated(dAtA, i, uint64(m.TrainedModels))
	i--
	dAtA[i] = 0x70
	i = encodeVarintGenerated(dAtA, i, uint64(m.Models))
	i--
	dAtA[i] = 0x68
	i = encodeVarintGenerated(dAtA, i, uint64(m.FileSize))
	i--
	dAtA[i] = 0x60
	i = encodeVarintGenerated(dAtA, i, uint64(m.Cols))
	i--
	dAtA[i] = 0x58
	i = encodeVarintGenerated(dAtA, i, uint64(m.Rows))
	i--
	dAtA[i] = 0x50
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x4a
	i -= len(m.ImageRepoName)
	copy(dAtA[i:], m.ImageRepoName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ImageRepoName)))
	i--
	dAtA[i] = 0x42
	i -= len(m.PredictorName)
	copy(dAtA[i:], m.PredictorName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PredictorName)))
	i--
	dAtA[i] = 0x3a
	i -= len(m.BestModelName)
	copy(dAtA[i:], m.BestModelName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.BestModelName)))
	i--
	dAtA[i] = 0x32
	i -= len(m.StudyName)
	copy(dAtA[i:], m.StudyName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.StudyName)))
	i--
	dAtA[i] = 0x22
	i -= len(m.DatasetName)
	copy(dAtA[i:], m.DatasetName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DatasetName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.DataSourceName)
	copy(dAtA[i:], m.DataSourceName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DataSourceName)))
	i--
	dAtA[i] = 0x12
	i -= len(m.FlatFileName)
	copy(dAtA[i:], m.FlatFileName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.FlatFileName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelCompilerRun) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelCompilerRun) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelCompilerRun) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelCompilerRunCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelCompilerRunCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelCompilerRunCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelCompilerRunList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelCompilerRunList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelCompilerRunList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelCompilerRunSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelCompilerRunSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelCompilerRunSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Target != nil {
		i -= len(*m.Target)
		copy(dAtA[i:], *m.Target)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Target)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Compiler != nil {
		i -= len(*m.Compiler)
		copy(dAtA[i:], *m.Compiler)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Compiler)))
		i--
		dAtA[i] = 0x32
	}
	if m.Priority != nil {
		i -= len(*m.Priority)
		copy(dAtA[i:], *m.Priority)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Priority)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if m.ModelName != nil {
		i -= len(*m.ModelName)
		copy(dAtA[i:], *m.ModelName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ModelName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelCompilerRunStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelCompilerRunStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelCompilerRunStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Progress != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Progress))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	i -= len(m.LastError)
	copy(dAtA[i:], m.LastError)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LastError)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	i -= len(m.Folder)
	copy(dAtA[i:], m.Folder)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Folder)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x7a
	if m.CompletionTime != nil {
		{
			size, err := m.CompletionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}

func (m *ModelCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelImageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelImageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelImageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegistryConnection != nil {
		i -= len(*m.RegistryConnection)
		copy(dAtA[i:], *m.RegistryConnection)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.RegistryConnection)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ImageName != nil {
		i -= len(*m.ImageName)
		copy(dAtA[i:], *m.ImageName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ImageName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Exist != nil {
		i--
		if *m.Exist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModelList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x22
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineRun) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineRun) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineRun) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineRunCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineRunCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineRunCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineRunList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineRunList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineRunList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineRunSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineRunSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineRunSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TTL))
		i--
		dAtA[i] = 0x48
	}
	if m.Aborted != nil {
		i--
		if *m.Aborted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Paused != nil {
		i--
		if *m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Priority != nil {
		i -= len(*m.Priority)
		copy(dAtA[i:], *m.Priority)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Priority)))
		i--
		dAtA[i] = 0x32
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PipelineName != nil {
		i -= len(*m.PipelineName)
		copy(dAtA[i:], *m.PipelineName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.PipelineName)))
		i--
		dAtA[i] = 0x22
	}
	if m.Dataset != nil {
		i -= len(*m.Dataset)
		copy(dAtA[i:], *m.Dataset)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Dataset)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelPipelineRunStageStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineRunStageStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineRunStageStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Error)
	copy(dAtA[i:], m.Error)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Error)))
	i--
	dAtA[i] = 0x52
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Results[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.EndTime != nil {
		{
			size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.ApprovedAt != nil {
		{
			size, err := m.ApprovedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.ApprovedBy)
	copy(dAtA[i:], m.ApprovedBy)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ApprovedBy)))
	i--
	dAtA[i] = 0x1a
	i--
	if m.Approved {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineRunStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineRunStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineRunStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	i -= len(m.TriggeredBy)
	copy(dAtA[i:], m.TriggeredBy)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.TriggeredBy)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	if m.Progress != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Progress))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	i -= len(m.LastError)
	copy(dAtA[i:], m.LastError)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LastError)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	i -= len(m.Folder)
	copy(dAtA[i:], m.Folder)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Folder)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x7a
	if m.CompletionTime != nil {
		{
			size, err := m.CompletionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	{
		size, err := m.LabelingStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.MonitoringStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.ReleaseStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.DeploymentStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.CapacityStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.UATStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.TrainingStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.DataStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	i -= len(m.ModelName)
	copy(dAtA[i:], m.ModelName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ModelName)))
	i--
	dAtA[i] = 0x22
	i -= len(m.StudyName)
	copy(dAtA[i:], m.StudyName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.StudyName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.DatasetName)
	copy(dAtA[i:], m.DatasetName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DatasetName)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Stage)
	copy(dAtA[i:], m.Stage)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Stage)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Paused != nil {
		i--
		if *m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.Priority != nil {
		i -= len(*m.Priority)
		copy(dAtA[i:], *m.Priority)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Priority)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.BaselineModelName != nil {
		i -= len(*m.BaselineModelName)
		copy(dAtA[i:], *m.BaselineModelName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.BaselineModelName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	{
		size, err := m.Notification.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.ApproverAccountName != nil {
		i -= len(*m.ApproverAccountName)
		copy(dAtA[i:], *m.ApproverAccountName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ApproverAccountName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x7a
	}
	{
		size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Release != nil {
		{
			size, err := m.Release.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Deployment != nil {
		{
			size, err := m.Deployment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Capacity != nil {
		{
			size, err := m.Capacity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.UAT != nil {
		{
			size, err := m.UAT.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Training != nil {
		{
			size, err := m.Training.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DatasetSelector) > 0 {
		keysForDatasetSelector := make([]string, 0, len(m.DatasetSelector))
		for k := range m.DatasetSelector {
			keysForDatasetSelector = append(keysForDatasetSelector, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForDatasetSelector)
		for iNdEx := len(keysForDatasetSelector) - 1; iNdEx >= 0; iNdEx-- {
			v := m.DatasetSelector[string(keysForDatasetSelector[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForDatasetSelector[iNdEx])
			copy(dAtA[i:], keysForDatasetSelector[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForDatasetSelector[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelPipelineStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	i -= len(m.LastError)
	copy(dAtA[i:], m.LastError)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LastError)))
	i--
	dAtA[i] = 0x22
	if m.LastUpdated != nil {
		{
			size, err := m.LastUpdated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x10
	if m.LastRun != nil {
		{
			size, err := m.LastRun.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		i--
		if *m.Error {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Score != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Score))))
		i--
		dAtA[i] = 0x19
	}
	i -= len(m.Alg)
	copy(dAtA[i:], m.Alg)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Alg)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelSearchSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelSearchSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelSearchSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeepOnlyTopModel != nil {
		i--
		if *m.KeepOnlyTopModel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.EarlyStopAfter != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.EarlyStopAfter))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	{
		size, err := m.SearchSpace.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.StudySchedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.RetainFor != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.RetainFor))
		i--
		dAtA[i] = 0x50
	}
	if m.RetainTop != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.RetainTop))
		i--
		dAtA[i] = 0x48
	}
	if m.Test != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Test))
		i--
		dAtA[i] = 0x40
	}
	if m.Trainers != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Trainers))
		i--
		dAtA[i] = 0x38
	}
	if m.MinScore != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.MinScore))))
		i--
		dAtA[i] = 0x31
	}
	if m.MaxModels != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxModels))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxTime != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxTime))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxCost != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxCost))
		i--
		dAtA[i] = 0x18
	}
	if m.Pruner != nil {
		{
			size, err := m.Pruner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Sampler != nil {
		i -= len(*m.Sampler)
		copy(dAtA[i:], *m.Sampler)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Sampler)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FeatureEngineeringOnly != nil {
		i--
		if *m.FeatureEngineeringOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.TTL != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TTL))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.EstimatorType != nil {
		i -= len(*m.EstimatorType)
		copy(dAtA[i:], *m.EstimatorType)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.EstimatorType)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.ActiveDeadlineSeconds != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ActiveDeadlineSeconds))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.Compilation != nil {
		{
			size, err := m.Compilation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.Forecasting != nil {
		{
			size, err := m.Forecasting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.Flagged != nil {
		i--
		if *m.Flagged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.Baseline != nil {
		i--
		if *m.Baseline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.Benchmarked != nil {
		i--
		if *m.Benchmarked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.Released != nil {
		i--
		if *m.Released {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.Forecasted != nil {
		i--
		if *m.Forecasted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.Archived != nil {
		i--
		if *m.Archived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.Profiled != nil {
		i--
		if *m.Profiled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.Paused != nil {
		i--
		if *m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Reported != nil {
		i--
		if *m.Reported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Pushed != nil {
		i--
		if *m.Pushed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Published != nil {
		i--
		if *m.Published {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Packaged != nil {
		i--
		if *m.Packaged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Aborted != nil {
		i--
		if *m.Aborted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Tested != nil {
		i--
		if *m.Tested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Training != nil {
		{
			size, err := m.Training.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Ensemble != nil {
		{
			size, err := m.Ensemble.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.NLPEstimator != nil {
		{
			size, err := m.NLPEstimator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Chatbot != nil {
		{
			size, err := m.Chatbot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Dnn != nil {
		{
			size, err := m.Dnn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Estimator != nil {
		{
			size, err := m.Estimator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.FeatureEngineering != nil {
		{
			size, err := m.FeatureEngineering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Objective != nil {
		i -= len(*m.Objective)
		copy(dAtA[i:], *m.Objective)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Objective)))
		i--
		dAtA[i] = 0x42
	}
	if m.Task != nil {
		i -= len(*m.Task)
		copy(dAtA[i:], *m.Task)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Task)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0x32
	}
	if m.StudyName != nil {
		i -= len(*m.StudyName)
		copy(dAtA[i:], *m.StudyName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.StudyName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ModelVersion != nil {
		i -= len(*m.ModelVersion)
		copy(dAtA[i:], *m.ModelVersion)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ModelVersion)))
		i--
		dAtA[i] = 0x22
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.ConfusionMatrix.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0xda
	{
		size, err := m.PRCurve.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0xd2
	{
		size, err := m.RocAucCurve.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0xca
	if m.TrialID != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TrialID))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	{
		size, err := m.Logs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0xba
	i -= len(m.EndPoint)
	copy(dAtA[i:], m.EndPoint)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.EndPoint)))
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0xb2
	i -= len(m.TrainerImage)
	copy(dAtA[i:], m.TrainerImage)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.TrainerImage)))
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0xaa
	i -= len(m.Team)
	copy(dAtA[i:], m.Team)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Team)))
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0xa2
	i -= len(m.TrainedBy)
	copy(dAtA[i:], m.TrainedBy)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.TrainedBy)))
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0x9a
	{
		size, err := m.TestingResources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0x92
	{
		size, err := m.TrainingResources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0x8a
	{
		size, err := m.TrainingDataHash.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0x82
	i -= len(m.ImageHash)
	copy(dAtA[i:], m.ImageHash)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ImageHash)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xfa
	i -= len(m.TarFileHash)
	copy(dAtA[i:], m.TarFileHash)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.TarFileHash)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xf2
	if m.ReleasedAt != nil {
		{
			size, err := m.ReleasedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	i -= len(m.PredictorName)
	copy(dAtA[i:], m.PredictorName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PredictorName)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xe2
	i -= len(m.URL)
	copy(dAtA[i:], m.URL)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.URL)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xda
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latency))))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xd1
	i = encodeVarintGenerated(dAtA, i, uint64(m.SizeInBytes))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xc8
	if m.Progress != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Progress))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	i -= len(m.LastError)
	copy(dAtA[i:], m.LastError)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LastError)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xba
	if m.ValidationRows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ValidationRows))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.TestingRows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TestingRows))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.TrainingRows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TrainingRows))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x98
	{
		size, err := m.ValidationDataset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x92
	{
		size, err := m.TestDatasetLocation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x8a
	{
		size, err := m.TrainDatasetLocation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x82
	if len(m.PythonPackages) > 0 {
		keysForPythonPackages := make([]string, 0, len(m.PythonPackages))
		for k := range m.PythonPackages {
			keysForPythonPackages = append(keysForPythonPackages, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForPythonPackages)
		for iNdEx := len(keysForPythonPackages) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PythonPackages[string(keysForPythonPackages[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForPythonPackages[iNdEx])
			copy(dAtA[i:], keysForPythonPackages[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForPythonPackages[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xfa
		}
	}
	i -= len(m.PythonVersion)
	copy(dAtA[i:], m.PythonVersion)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PythonVersion)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xf2
	i -= len(m.ForecastUri)
	copy(dAtA[i:], m.ForecastUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ForecastUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xea
	if len(m.Importance) > 0 {
		for iNdEx := len(m.Importance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Importance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	i -= len(m.ImageName)
	copy(dAtA[i:], m.ImageName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ImageName)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd2
	i -= len(m.AppUri)
	copy(dAtA[i:], m.AppUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.AppUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xca
	i -= len(m.TarUri)
	copy(dAtA[i:], m.TarUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.TarUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc2
	i -= len(m.MisclassUri)
	copy(dAtA[i:], m.MisclassUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.MisclassUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	i -= len(m.ProfileUri)
	copy(dAtA[i:], m.ProfileUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ProfileUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	i -= len(m.LogsUri)
	copy(dAtA[i:], m.LogsUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LogsUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	i -= len(m.LabelEncoderUri)
	copy(dAtA[i:], m.LabelEncoderUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LabelEncoderUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	i -= len(m.WeightsUri)
	copy(dAtA[i:], m.WeightsUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.WeightsUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	i -= len(m.ManifestUri)
	copy(dAtA[i:], m.ManifestUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ManifestUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	i -= len(m.ReportUri)
	copy(dAtA[i:], m.ReportUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ReportUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	i -= len(m.ReportName)
	copy(dAtA[i:], m.ReportName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ReportName)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x7a
	if len(m.Test) > 0 {
		for iNdEx := len(m.Test) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Test[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.Train) > 0 {
		for iNdEx := len(m.Train) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Train[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.CV) > 0 {
		for iNdEx := len(m.CV) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CV[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	i--
	if m.Best {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x58
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Cost))))
	i--
	dAtA[i] = 0x51
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TestScore))))
	i--
	dAtA[i] = 0x49
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TrainingScore))))
	i--
	dAtA[i] = 0x41
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CVScore))))
	i--
	dAtA[i] = 0x39
	if m.EndTime != nil {
		{
			size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TestingEndTime != nil {
		{
			size, err := m.TestingEndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TestingStartTime != nil {
		{
			size, err := m.TestingStartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TrainingEndTime != nil {
		{
			size, err := m.TrainingEndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TrainingStartTime != nil {
		{
			size, err := m.TrainingStartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Agg != nil {
		i -= len(*m.Agg)
		copy(dAtA[i:], *m.Agg)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Agg)))
		i--
		dAtA[i] = 0x62
	}
	if m.MaxPrecent != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.MaxPrecent))))
		i--
		dAtA[i] = 0x59
	}
	if m.MinPrecent != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.MinPrecent))))
		i--
		dAtA[i] = 0x51
	}
	if m.Max != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Max))))
		i--
		dAtA[i] = 0x49
	}
	if m.Min != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Min))))
		i--
		dAtA[i] = 0x41
	}
	if m.Metric != nil {
		i -= len(*m.Metric)
		copy(dAtA[i:], *m.Metric)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Metric)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Column != nil {
		i -= len(*m.Column)
		copy(dAtA[i:], *m.Column)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Column)))
		i--
		dAtA[i] = 0x32
	}
	if m.DriftInterval != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.DriftInterval))
		i--
		dAtA[i] = 0x28
	}
	i -= len(m.DriftFreq)
	copy(dAtA[i:], m.DriftFreq)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DriftFreq)))
	i--
	dAtA[i] = 0x22
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PrevModel != nil {
		i -= len(*m.PrevModel)
		copy(dAtA[i:], *m.PrevModel)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.PrevModel)))
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelValidationResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelValidationResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelValidationResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintGenerated(dAtA, i, uint64(m.DurationInSec))
	i--
	dAtA[i] = 0x50
	if m.At != nil {
		{
			size, err := m.At.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	i--
	if m.Passed {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	if m.ActualValue != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.ActualValue))))
		i--
		dAtA[i] = 0x39
	}
	if m.Metric != nil {
		i -= len(*m.Metric)
		copy(dAtA[i:], *m.Metric)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Metric)))
		i--
		dAtA[i] = 0x32
	}
	i -= len(m.Error)
	copy(dAtA[i:], m.Error)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Error)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Column)
	copy(dAtA[i:], m.Column)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Column)))
	i--
	dAtA[i] = 0x22
	i -= len(m.ModelName)
	copy(dAtA[i:], m.ModelName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ModelName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.DatasetName)
	copy(dAtA[i:], m.DatasetName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DatasetName)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NLPEstimatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NLPEstimatorSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NLPEstimatorSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Base != nil {
		i -= len(*m.Base)
		copy(dAtA[i:], *m.Base)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Base)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NNLayerParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NNLayerParameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NNLayerParameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Value)
	copy(dAtA[i:], m.Value)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Value)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Notebook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notebook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notebook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookRun) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookRun) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookRun) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookRunCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookRunCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookRunCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookRunList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookRunList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookRunList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookRunSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookRunSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookRunSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TTL))
		i--
		dAtA[i] = 0x30
	}
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.NotebookName != nil {
		i -= len(*m.NotebookName)
		copy(dAtA[i:], *m.NotebookName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.NotebookName)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NotebookRunStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookRunStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookRunStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	{
		size, err := m.Logs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	i -= len(m.TriggeredBy)
	copy(dAtA[i:], m.TriggeredBy)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.TriggeredBy)))
	i--
	dAtA[i] = 0x32
	i -= len(m.LastError)
	copy(dAtA[i:], m.LastError)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LastError)))
	i--
	dAtA[i] = 0x2a
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x20
	if m.EndTime != nil {
		{
			size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Paused != nil {
		i--
		if *m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.Priority != nil {
		i -= len(*m.Priority)
		copy(dAtA[i:], *m.Priority)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Priority)))
		i--
		dAtA[i] = 0x6a
	}
	{
		size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.ActiveDeadlineSeconds != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ActiveDeadlineSeconds))
		i--
		dAtA[i] = 0x58
	}
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x52
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Vars) > 0 {
		for iNdEx := len(m.Vars) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Vars[iNdEx])
			copy(dAtA[i:], m.Vars[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Vars[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.DebPackages != nil {
		i -= len(*m.DebPackages)
		copy(dAtA[i:], *m.DebPackages)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DebPackages)))
		i--
		dAtA[i] = 0x32
	}
	if m.Requirements != nil {
		i -= len(*m.Requirements)
		copy(dAtA[i:], *m.Requirements)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Requirements)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ImageName != nil {
		i -= len(*m.ImageName)
		copy(dAtA[i:], *m.ImageName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ImageName)))
		i--
		dAtA[i] = 0x22
	}
	if m.SchemaRef != nil {
		{
			size, err := m.SchemaRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NotebookStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.LastRun != nil {
		{
			size, err := m.LastRun.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x18
	i -= len(m.URI)
	copy(dAtA[i:], m.URI)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.URI)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Image)
	copy(dAtA[i:], m.Image)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Image)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookVarValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookVarValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookVarValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Value)
	copy(dAtA[i:], m.Value)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Value)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PeriodSeasonalitySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeriodSeasonalitySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeriodSeasonalitySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mode != nil {
		i -= len(*m.Mode)
		copy(dAtA[i:], *m.Mode)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Mode)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Periods != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Periods))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeriodSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeriodSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeriodSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Start))
		i--
		dAtA[i] = 0x10
	}
	if m.Interval != nil {
		i -= len(*m.Interval)
		copy(dAtA[i:], *m.Interval)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Interval)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrunerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrunerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrunerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SHOptions != nil {
		{
			size, err := m.SHOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Upper != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Upper))
		i--
		dAtA[i] = 0x40
	}
	if m.Lower != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Lower))
		i--
		dAtA[i] = 0x38
	}
	if m.Precentile != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Precentile))
		i--
		dAtA[i] = 0x30
	}
	if m.IntervalSteps != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.IntervalSteps))
		i--
		dAtA[i] = 0x28
	}
	if m.MinimumTrials != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MinimumTrials))
		i--
		dAtA[i] = 0x20
	}
	if m.WramupTrials != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.WramupTrials))
		i--
		dAtA[i] = 0x18
	}
	if m.StartupTrials != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.StartupTrials))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != nil {
		i -= len(*m.Type)
		copy(dAtA[i:], *m.Type)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegressorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegressorSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegressorSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Standardize != nil {
		i--
		if *m.Standardize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.PriorScale != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.PriorScale))))
		i--
		dAtA[i] = 0x11
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReleaseStageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReleaseStageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReleaseStageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Validations) > 0 {
		for iNdEx := len(m.Validations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ManualApproval != nil {
		i--
		if *m.ManualApproval {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Template != nil {
		{
			size, err := m.Template.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PredictorName != nil {
		i -= len(*m.PredictorName)
		copy(dAtA[i:], *m.PredictorName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.PredictorName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ServingSiteName != nil {
		i -= len(*m.ServingSiteName)
		copy(dAtA[i:], *m.ServingSiteName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ServingSiteName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Report) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Report) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Report) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReportCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReportList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReportSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Custom != nil {
		{
			size, err := m.Custom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.ActiveDeadlineSeconds != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ActiveDeadlineSeconds))
		i--
		dAtA[i] = 0x50
	}
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x42
	}
	if m.NotifierName != nil {
		i -= len(*m.NotifierName)
		copy(dAtA[i:], *m.NotifierName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.NotifierName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Format != nil {
		i -= len(*m.Format)
		copy(dAtA[i:], *m.Format)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Format)))
		i--
		dAtA[i] = 0x32
	}
	if m.ReportType != nil {
		i -= len(*m.ReportType)
		copy(dAtA[i:], *m.ReportType)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ReportType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.EntityRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size, err := m.Logs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	i -= len(m.LastError)
	copy(dAtA[i:], m.LastError)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LastError)))
	i--
	dAtA[i] = 0x3a
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x30
	i -= len(m.URI)
	copy(dAtA[i:], m.URI)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.URI)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x22
	if m.EndTime != nil {
		{
			size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ReportTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResourceConsumption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceConsumption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceConsumption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Gpu))))
	i--
	dAtA[i] = 0x19
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mem))))
	i--
	dAtA[i] = 0x11
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Cpu))))
	i--
	dAtA[i] = 0x9
	return len(dAtA) - i, nil
}

func (m *Study) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Study) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Study) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StudyCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StudyCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StudyCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StudyForecastSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StudyForecastSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StudyForecastSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForecastTemplate != nil {
		{
			size, err := m.ForecastTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.Hierarchy != nil {
		{
			size, err := m.Hierarchy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}

func (m *StudyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StudyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StudyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StudyScheduleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StudyScheduleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StudyScheduleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StartAt != nil {
		{
			size, err := m.StartAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StudySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StudySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StudySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ForecastSpec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x9a
	if m.TTL != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TTL))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	{
		size, err := m.ModelImage.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xf2
	{
		size, err := m.Notification.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xea
	if m.Flagged != nil {
		i--
		if *m.Flagged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.Template != nil {
		i--
		if *m.Template {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.Compilation != nil {
		{
			size, err := m.Compilation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.ActiveDeadlineSeconds != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ActiveDeadlineSeconds))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.ModelBenchmarked != nil {
		i--
		if *m.ModelBenchmarked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.ModelImagePushed != nil {
		i--
		if *m.ModelImagePushed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.ModelPublished != nil {
		i--
		if *m.ModelPublished {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Profiled != nil {
		i--
		if *m.Profiled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Paused != nil {
		i--
		if *m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Reported != nil {
		i--
		if *m.Reported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.FeatureEngineered != nil {
		i--
		if *m.FeatureEngineered {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.Aborted != nil {
		i--
		if *m.Aborted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Split != nil {
		{
			size, err := m.Split.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.TrainingTemplate != nil {
		{
			size, err := m.TrainingTemplate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.FeatureEngineering != nil {
		{
			size, err := m.FeatureEngineering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Search != nil {
		{
			size, err := m.Search.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Objective2 != nil {
		i -= len(*m.Objective2)
		copy(dAtA[i:], *m.Objective2)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Objective2)))
		i--
		dAtA[i] = 0x42
	}
	if m.Objective != nil {
		i -= len(*m.Objective)
		copy(dAtA[i:], *m.Objective)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Objective)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Task != nil {
		i -= len(*m.Task)
		copy(dAtA[i:], *m.Task)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Task)))
		i--
		dAtA[i] = 0x32
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LabRef != nil {
		{
			size, err := m.LabRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StudyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StudyStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StudyStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xda
		}
	}
	{
		size, err := m.FeatureEngineeringStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xd2
	{
		size, err := m.Logs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xca
	i -= len(m.TriggeredBy)
	copy(dAtA[i:], m.TriggeredBy)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.TriggeredBy)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xc2
	{
		size, err := m.TrainingDataHash.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xba
	if m.BaslineModel != nil {
		i -= len(*m.BaslineModel)
		copy(dAtA[i:], *m.BaslineModel)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.BaslineModel)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.Progress != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Progress))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.ValidationRows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ValidationRows))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.TestingRows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TestingRows))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.TrainingRows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TrainingRows))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.LastError != nil {
		i -= len(*m.LastError)
		copy(dAtA[i:], *m.LastError)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.LastError)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.LastModelID != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.LastModelID))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	{
		size, err := m.ValidationDataset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xfa
	{
		size, err := m.TestDatasetLocation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xf2
	{
		size, err := m.TrainDatasetLocation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xea
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe0
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xda
	i -= len(m.ReportName)
	copy(dAtA[i:], m.ReportName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ReportName)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd2
	i -= len(m.ProfileUri)
	copy(dAtA[i:], m.ProfileUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ProfileUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xca
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BestModelScore))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc1
	i -= len(m.BestModel)
	copy(dAtA[i:], m.BestModel)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.BestModel)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	if m.EndTime != nil {
		{
			size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.TestingEndTime != nil {
		{
			size, err := m.TestingEndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.TestingStartTime != nil {
		{
			size, err := m.TestingStartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.SearchingEndTime != nil {
		{
			size, err := m.SearchingEndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.SearchingStartTime != nil {
		{
			size, err := m.SearchingStartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.FeatureEngineerinEndTime != nil {
		{
			size, err := m.FeatureEngineerinEndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.FeatureEngineeringStartTime != nil {
		{
			size, err := m.FeatureEngineeringStartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.TestedModels))
	i--
	dAtA[i] = 0x68
	i = encodeVarintGenerated(dAtA, i, uint64(m.TestingModeFailed))
	i--
	dAtA[i] = 0x60
	i = encodeVarintGenerated(dAtA, i, uint64(m.TestingModels))
	i--
	dAtA[i] = 0x58
	i = encodeVarintGenerated(dAtA, i, uint64(m.TestingModelWaiting))
	i--
	dAtA[i] = 0x50
	i = encodeVarintGenerated(dAtA, i, uint64(m.SearchingModeTrained))
	i--
	dAtA[i] = 0x48
	i = encodeVarintGenerated(dAtA, i, uint64(m.SearchingModeFailed))
	i--
	dAtA[i] = 0x40
	i = encodeVarintGenerated(dAtA, i, uint64(m.SearchingModelsTraining))
	i--
	dAtA[i] = 0x38
	i = encodeVarintGenerated(dAtA, i, uint64(m.SearchingModelWaiting))
	i--
	dAtA[i] = 0x30
	i = encodeVarintGenerated(dAtA, i, uint64(m.FeatureEngineeringModelTrained))
	i--
	dAtA[i] = 0x28
	i = encodeVarintGenerated(dAtA, i, uint64(m.FeatureEngineeringModeFailed))
	i--
	dAtA[i] = 0x20
	i = encodeVarintGenerated(dAtA, i, uint64(m.FeatureEngineeringModelTraining))
	i--
	dAtA[i] = 0x18
	i = encodeVarintGenerated(dAtA, i, uint64(m.FeatureEngineeringModelWaiting))
	i--
	dAtA[i] = 0x10
	i = encodeVarintGenerated(dAtA, i, uint64(m.Models))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *SuccessiveHalvingOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuccessiveHalvingOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuccessiveHalvingOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Modality != nil {
		i -= len(*m.Modality)
		copy(dAtA[i:], *m.Modality)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Modality)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EliminationRate != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.EliminationRate))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxBudget != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxBudget))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SuccessiveHalvingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuccessiveHalvingSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuccessiveHalvingSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Modality != nil {
		i -= len(*m.Modality)
		copy(dAtA[i:], *m.Modality)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Modality)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.ConfID != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ConfID))
		i--
		dAtA[i] = 0x20
	}
	if m.Rung != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Rung))
		i--
		dAtA[i] = 0x18
	}
	if m.Bracket != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Bracket))
		i--
		dAtA[i] = 0x10
	}
	if m.Budget != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Budget))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TextPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TextPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxSvdComponents != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxSvdComponents))
		i--
		dAtA[i] = 0x48
	}
	if m.Svd != nil {
		i--
		if *m.Svd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Embedding != nil {
		i -= len(*m.Embedding)
		copy(dAtA[i:], *m.Embedding)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Embedding)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Stem != nil {
		i--
		if *m.Stem {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Lemma != nil {
		i--
		if *m.Lemma {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Pos != nil {
		i--
		if *m.Pos {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.StopWords != nil {
		i--
		if *m.StopWords {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Tokenizer != nil {
		i -= len(*m.Tokenizer)
		copy(dAtA[i:], *m.Tokenizer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Tokenizer)))
		i--
		dAtA[i] = 0x12
	}
	if m.Encoder != nil {
		i -= len(*m.Encoder)
		copy(dAtA[i:], *m.Encoder)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Encoder)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimeSeriesDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeSeriesDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeSeriesDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UncertaintySamples != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.UncertaintySamples))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.IntervalWidth != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.IntervalWidth))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	{
		size, err := m.ChangePoints.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	if len(m.CustomSeasonalities) > 0 {
		for iNdEx := len(m.CustomSeasonalities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomSeasonalities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.Regressors) > 0 {
		for iNdEx := len(m.Regressors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Regressors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.Growth != nil {
		i -= len(*m.Growth)
		copy(dAtA[i:], *m.Growth)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Growth)))
		i--
		dAtA[i] = 0x6a
	}
	{
		size, err := m.DailySeasonality.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.WeeklySeasonality.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.YearlySeasonality.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.Forecast != nil {
		{
			size, err := m.Forecast.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.History != nil {
		{
			size, err := m.History.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.SubSubGroupColumn != nil {
		i -= len(*m.SubSubGroupColumn)
		copy(dAtA[i:], *m.SubSubGroupColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SubSubGroupColumn)))
		i--
		dAtA[i] = 0x3a
	}
	if m.SubGroupColumn != nil {
		i -= len(*m.SubGroupColumn)
		copy(dAtA[i:], *m.SubGroupColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SubGroupColumn)))
		i--
		dAtA[i] = 0x32
	}
	if m.GroupColumn != nil {
		i -= len(*m.GroupColumn)
		copy(dAtA[i:], *m.GroupColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GroupColumn)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Holiday.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.DateTimeFormat != nil {
		i -= len(*m.DateTimeFormat)
		copy(dAtA[i:], *m.DateTimeFormat)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DateTimeFormat)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TargetColumn != nil {
		i -= len(*m.TargetColumn)
		copy(dAtA[i:], *m.TargetColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TargetColumn)))
		i--
		dAtA[i] = 0x12
	}
	if m.TimeColumn != nil {
		i -= len(*m.TimeColumn)
		copy(dAtA[i:], *m.TimeColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TimeColumn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrainingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrainingSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrainingSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Sample.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	if m.NodeCount != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.NodeCount))
		i--
		dAtA[i] = 0x70
	}
	if m.Dist != nil {
		i--
		if *m.Dist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Gpu != nil {
		i--
		if *m.Gpu {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Seed != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Seed))))
		i--
		dAtA[i] = 0x51
	}
	if m.SH != nil {
		{
			size, err := m.SH.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CheckpointInterval != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.CheckpointInterval))
		i--
		dAtA[i] = 0x38
	}
	if m.EarlyStop != nil {
		i--
		if *m.EarlyStop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.EvalMetrics) > 0 {
		for iNdEx := len(m.EvalMetrics) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EvalMetrics[iNdEx])
			copy(dAtA[i:], m.EvalMetrics[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.EvalMetrics[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Folds != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Folds))
		i--
		dAtA[i] = 0x20
	}
	if m.CV != nil {
		i--
		if *m.CV {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.CvType != nil {
		i -= len(*m.CvType)
		copy(dAtA[i:], *m.CvType)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.CvType)))
		i--
		dAtA[i] = 0x12
	}
	if m.Priority != nil {
		i -= len(*m.Priority)
		copy(dAtA[i:], *m.Priority)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Priority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrainingStageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrainingStageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrainingStageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Validations) > 0 {
		for iNdEx := len(m.Validations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.StudyTemplateName != nil {
		i -= len(*m.StudyTemplateName)
		copy(dAtA[i:], *m.StudyTemplateName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.StudyTemplateName)))
		i--
		dAtA[i] = 0x22
	}
	if m.LabName != nil {
		i -= len(*m.LabName)
		copy(dAtA[i:], *m.LabName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.LabName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NotebookName != nil {
		i -= len(*m.NotebookName)
		copy(dAtA[i:], *m.NotebookName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.NotebookName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UATStageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UATStageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UATStageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Validations) > 0 {
		for iNdEx := len(m.Validations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ServingSiteName != nil {
		i -= len(*m.ServingSiteName)
		copy(dAtA[i:], *m.ServingSiteName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ServingSiteName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VideoPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VideoPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Featurizer != nil {
		i -= len(*m.Featurizer)
		copy(dAtA[i:], *m.Featurizer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Featurizer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenerated(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenerated(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AlgorithmSearchSpaceSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllowList) > 0 {
		for _, s := range m.AllowList {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.VotingEnsemble != nil {
		n += 2
	}
	if m.StackingEnsemble != nil {
		n += 2
	}
	if m.AlgorithmFilter != nil {
		l = len(*m.AlgorithmFilter)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if len(m.Baselines) > 0 {
		for _, s := range m.Baselines {
			l = len(s)
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	if m.TestAll != nil {
		n += 3
	}
	return n
}

func (m *AudioPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Featurizer != nil {
		l = len(*m.Featurizer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *BacktestSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sliding != nil {
		n += 2
	}
	if m.TrainingWindowSize != nil {
		n += 1 + sovGenerated(uint64(*m.TrainingWindowSize))
	}
	if m.ForecastingWindowSize != nil {
		n += 1 + sovGenerated(uint64(*m.ForecastingWindowSize))
	}
	if m.SlidingSteps != nil {
		n += 1 + sovGenerated(uint64(*m.SlidingSteps))
	}
	return n
}

func (m *CapacityStageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.ServingSiteName != nil {
		l = len(*m.ServingSiteName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Validations) > 0 {
		for _, e := range m.Validations {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ChangePointSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.N != nil {
		n += 1 + sovGenerated(uint64(*m.N))
	}
	if m.Range != nil {
		n += 9
	}
	return n
}

func (m *ChatbotEstimatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = len(*m.Base)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ClassicalEstimatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AlgorithmName)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *CronReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *CronReportCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *CronReportList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *CronReportSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Schedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Range != nil {
		l = len(*m.Range)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Template.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Paused != nil {
		n += 2
	}
	l = m.Notification.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *CronReportStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastRun != nil {
		l = m.LastRun.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.LastUpdated != nil {
		l = m.LastUpdated.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *CustomReportBarChart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.X != nil {
		l = len(*m.X)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Y != nil {
		l = len(*m.Y)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Legend != nil {
		n += 2
	}
	if m.Sort != nil {
		n += 2
	}
	return n
}

func (m *CustomReportHistogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.X != nil {
		l = len(*m.X)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Bins != nil {
		n += 1 + sovGenerated(uint64(*m.Bins))
	}
	return n
}

func (m *CustomReportLineChart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.X != nil {
		l = len(*m.X)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Y != nil {
		l = len(*m.Y)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Legend != nil {
		n += 2
	}
	return n
}

func (m *CustomReportScatterPlot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.X != nil {
		l = len(*m.X)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Y != nil {
		l = len(*m.Y)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *CustomReportSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.LineCharts) > 0 {
		for _, e := range m.LineCharts {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.BarCharts) > 0 {
		for _, e := range m.BarCharts {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.HistCharts) > 0 {
		for _, e := range m.HistCharts {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.ScatterCharts) > 0 {
		for _, e := range m.ScatterCharts {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *CustomReportTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Filters) > 0 {
		for _, s := range m.Filters {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.GroupBy) > 0 {
		for _, s := range m.GroupBy {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Rows != nil {
		n += 1 + sovGenerated(uint64(*m.Rows))
	}
	if m.ShowIndex != nil {
		n += 2
	}
	if m.Border != nil {
		n += 2
	}
	return n
}

func (m *CustomReportValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Column != nil {
		l = len(*m.Column)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Row != nil {
		n += 1 + sovGenerated(uint64(*m.Row))
	}
	if m.Scalar != nil {
		l = len(*m.Scalar)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *CustomSeasonalitySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	n += 9
	if m.FourierOrder != nil {
		n += 1 + sovGenerated(uint64(*m.FourierOrder))
	}
	return n
}

func (m *DataHashes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrainingHash != nil {
		l = len(*m.TrainingHash)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TestingHash != nil {
		l = len(*m.TestingHash)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ValidationHash != nil {
		l = len(*m.ValidationHash)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *DataSplit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Auto != nil {
		n += 2
	}
	if m.Train != nil {
		n += 1 + sovGenerated(uint64(*m.Train))
	}
	if m.Validation != nil {
		n += 1 + sovGenerated(uint64(*m.Validation))
	}
	if m.Test != nil {
		n += 1 + sovGenerated(uint64(*m.Test))
	}
	if m.SplitPolicy != nil {
		l = len(*m.SplitPolicy)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SplitColumn != nil {
		l = len(*m.SplitColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Seed != nil {
		n += 1 + sovGenerated(uint64(*m.Seed))
	}
	return n
}

func (m *DataStageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.LabName != nil {
		l = len(*m.LabName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DataPipelineName != nil {
		l = len(*m.DataPipelineName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DatasourceName != nil {
		l = len(*m.DatasourceName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DockerImage != nil {
		l = len(*m.DockerImage)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *DeepEstimatorLayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.InputLayers) > 0 {
		for _, s := range m.InputLayers {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DeepEstimatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Layers) > 0 {
		for _, e := range m.Layers {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.BatchSize != nil {
		n += 1 + sovGenerated(uint64(*m.BatchSize))
	}
	if m.Epochs != nil {
		n += 1 + sovGenerated(uint64(*m.Epochs))
	}
	if m.ValidationSplit != nil {
		n += 1 + sovGenerated(uint64(*m.ValidationSplit))
	}
	if m.Seq != nil {
		n += 2
	}
	if m.Gpus != nil {
		n += 1 + sovGenerated(uint64(*m.Gpus))
	}
	l = len(m.Loss)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DeploymentStageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.ServingSiteName != nil {
		l = len(*m.ServingSiteName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ManualApproval != nil {
		n += 2
	}
	if len(m.Validations) > 0 {
		for _, e := range m.Validations {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *EnsembleRules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EnsembleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Base) > 0 {
		for _, s := range m.Base {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *FeatureEngineeringPipeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DataType)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Imputation != nil {
		l = len(*m.Imputation)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Encoding != nil {
		l = len(*m.Encoding)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Scaling != nil {
		l = len(*m.Scaling)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Discretisation != nil {
		l = len(*m.Discretisation)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.VariableTransformation != nil {
		l = len(*m.VariableTransformation)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.OutlierHandling != nil {
		l = len(*m.OutlierHandling)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DatetimeTransformation != nil {
		l = len(*m.DatetimeTransformation)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Audio != nil {
		l = m.Audio.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Genereted) > 0 {
		for _, e := range m.Genereted {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Custom) > 0 {
		for _, e := range m.Custom {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	if m.Drop != nil {
		n += 3
	}
	if m.Passtrough != nil {
		n += 3
	}
	return n
}

func (m *FeatureEngineeringSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if len(m.Pipelines) > 0 {
		for _, e := range m.Pipelines {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = m.FeatureSelection.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Estimator != nil {
		l = len(*m.Estimator)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.MaxModels != nil {
		n += 1 + sovGenerated(uint64(*m.MaxModels))
	}
	if m.MaxTimeSec != nil {
		n += 1 + sovGenerated(uint64(*m.MaxTimeSec))
	}
	if m.MaxTrainers != nil {
		n += 1 + sovGenerated(uint64(*m.MaxTrainers))
	}
	if m.SamplePct != nil {
		n += 1 + sovGenerated(uint64(*m.SamplePct))
	}
	return n
}

func (m *FeatureEngineeringStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BestPipeline.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *FeatureImportance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Feature)
	n += 1 + l + sovGenerated(uint64(l))
	n += 9
	return n
}

func (m *FeatureInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	n += 9
	return n
}

func (m *FeatureSelectionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.VarianceTresholdPct != nil {
		n += 1 + sovGenerated(uint64(*m.VarianceTresholdPct))
	}
	if m.CorrTreshold != nil {
		n += 1 + sovGenerated(uint64(*m.CorrTreshold))
	}
	if m.TopN != nil {
		n += 1 + sovGenerated(uint64(*m.TopN))
	}
	if m.CumulativeImportancePrecent != nil {
		n += 1 + sovGenerated(uint64(*m.CumulativeImportancePrecent))
	}
	if len(m.Reserved) > 0 {
		for _, s := range m.Reserved {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ForecastObj) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.LevelIndex))
	return n
}

func (m *ForecastPostProcessingSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectionName != nil {
		l = len(*m.ConnectionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Forecast != nil {
		n += 2
	}
	return n
}

func (m *ForecastSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Data.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.ConfidenceInterval != nil {
		n += 1 + sovGenerated(uint64(*m.ConfidenceInterval))
	}
	l = m.Backtest.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.PostPrecessing.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Plot != nil {
		n += 2
	}
	if m.PlotChangePoints != nil {
		n += 2
	}
	return n
}

func (m *FormatSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GeneratedColumnSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.DataType)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.First)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Second)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Expression)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *Hierarchy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.GroupLevels) > 0 {
		for _, e := range m.GroupLevels {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.ItemLevel != nil {
		l = m.ItemLevel.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.NotifierName != nil {
		l = len(*m.NotifierName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *HolidaySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HolidayColumn != nil {
		l = len(*m.HolidayColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Country != nil {
		l = len(*m.Country)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *HyperParameterValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ImagePipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Featurizer != nil {
		l = len(*m.Featurizer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *Level) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.Horizon))
	if m.Freq != nil {
		l = len(*m.Freq)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Aggregate != nil {
		l = len(*m.Aggregate)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *Model) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelAutobuilder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelAutobuilderCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelAutobuilderList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelAutobuilderSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataProductName != nil {
		l = len(*m.DataProductName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DataProductVersionName != nil {
		l = len(*m.DataProductVersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DataSourceName != nil {
		l = len(*m.DataSourceName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Task != nil {
		l = len(*m.Task)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Objective != nil {
		l = len(*m.Objective)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TargetColumn != nil {
		l = len(*m.TargetColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.MaxTime != nil {
		n += 1 + sovGenerated(uint64(*m.MaxTime))
	}
	if m.MaxModels != nil {
		n += 1 + sovGenerated(uint64(*m.MaxModels))
	}
	if m.AccessMethod != nil {
		l = len(*m.AccessMethod)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.AutoScale != nil {
		n += 2
	}
	if m.DataSourceSpec != nil {
		l = m.DataSourceSpec.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Trainers != nil {
		n += 1 + sovGenerated(uint64(*m.Trainers))
	}
	if m.Sampler != nil {
		l = len(*m.Sampler)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Aborted != nil {
		n += 3
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Workload != nil {
		l = len(*m.Workload)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.LabRef != nil {
		l = m.LabRef.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ModelAutobuilderStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FlatFileName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DataSourceName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DatasetName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.StudyName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.BestModelName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.PredictorName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ImageRepoName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.Rows))
	n += 1 + sovGenerated(uint64(m.Cols))
	n += 1 + sovGenerated(uint64(m.FileSize))
	n += 1 + sovGenerated(uint64(m.Models))
	n += 1 + sovGenerated(uint64(m.TrainedModels))
	n += 9
	if m.Estimator != nil {
		l = m.Estimator.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	n += 2 + sovGenerated(uint64(m.ObservedGeneration))
	l = len(m.LastError)
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelCompilerRun) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelCompilerRunCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelCompilerRunList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelCompilerRunSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ModelName != nil {
		l = len(*m.ModelName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Priority != nil {
		l = len(*m.Priority)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Compiler != nil {
		l = len(*m.Compiler)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Target != nil {
		l = len(*m.Target)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ModelCompilerRunStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CompletionTime != nil {
		l = m.CompletionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	n += 2 + sovGenerated(uint64(m.ObservedGeneration))
	l = len(m.Folder)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.LastError)
	n += 2 + l + sovGenerated(uint64(l))
	if m.Progress != nil {
		n += 2 + sovGenerated(uint64(*m.Progress))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelImageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exist != nil {
		n += 2
	}
	if m.ImageName != nil {
		l = len(*m.ImageName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.RegistryConnection != nil {
		l = len(*m.RegistryConnection)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ModelList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelPipeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelPipelineCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelPipelineList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelPipelineRun) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelPipelineRunCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelPipelineRunList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelPipelineRunSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Dataset != nil {
		l = len(*m.Dataset)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.PipelineName != nil {
		l = len(*m.PipelineName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Priority != nil {
		l = len(*m.Priority)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Paused != nil {
		n += 2
	}
	if m.Aborted != nil {
		n += 2
	}
	if m.TTL != nil {
		n += 1 + sovGenerated(uint64(*m.TTL))
	}
	return n
}

func (m *ModelPipelineRunStageStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	l = len(m.ApprovedBy)
	n += 1 + l + sovGenerated(uint64(l))
	if m.ApprovedAt != nil {
		l = m.ApprovedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = len(m.Error)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelPipelineRunStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stage)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DatasetName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.StudyName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ModelName)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.DataStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.TrainingStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.UATStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.CapacityStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.DeploymentStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.ReleaseStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.MonitoringStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.LabelingStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CompletionTime != nil {
		l = m.CompletionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	n += 2 + sovGenerated(uint64(m.ObservedGeneration))
	l = len(m.Folder)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.LastError)
	n += 2 + l + sovGenerated(uint64(l))
	if m.Progress != nil {
		n += 2 + sovGenerated(uint64(*m.Progress))
	}
	l = len(m.TriggeredBy)
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.DatasetSelector) > 0 {
		for k, v := range m.DatasetSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Training != nil {
		l = m.Training.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.UAT != nil {
		l = m.UAT.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Capacity != nil {
		l = m.Capacity.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Deployment != nil {
		l = m.Deployment.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Release != nil {
		l = m.Release.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Schedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ApproverAccountName != nil {
		l = len(*m.ApproverAccountName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	l = m.Notification.Size()
	n += 2 + l + sovGenerated(uint64(l))
	if m.BaselineModelName != nil {
		l = len(*m.BaselineModelName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Priority != nil {
		l = len(*m.Priority)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Paused != nil {
		n += 3
	}
	return n
}

func (m *ModelPipelineStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastRun != nil {
		l = m.LastRun.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if m.LastUpdated != nil {
		l = m.LastUpdated.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.LastError)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Alg)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Score != nil {
		n += 9
	}
	if m.Error != nil {
		n += 2
	}
	return n
}

func (m *ModelSearchSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sampler != nil {
		l = len(*m.Sampler)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Pruner != nil {
		l = m.Pruner.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.MaxCost != nil {
		n += 1 + sovGenerated(uint64(*m.MaxCost))
	}
	if m.MaxTime != nil {
		n += 1 + sovGenerated(uint64(*m.MaxTime))
	}
	if m.MaxModels != nil {
		n += 1 + sovGenerated(uint64(*m.MaxModels))
	}
	if m.MinScore != nil {
		n += 9
	}
	if m.Trainers != nil {
		n += 1 + sovGenerated(uint64(*m.Trainers))
	}
	if m.Test != nil {
		n += 1 + sovGenerated(uint64(*m.Test))
	}
	if m.RetainTop != nil {
		n += 1 + sovGenerated(uint64(*m.RetainTop))
	}
	if m.RetainFor != nil {
		n += 1 + sovGenerated(uint64(*m.RetainFor))
	}
	l = m.StudySchedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.SearchSpace.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.EarlyStopAfter != nil {
		n += 2 + sovGenerated(uint64(*m.EarlyStopAfter))
	}
	if m.KeepOnlyTopModel != nil {
		n += 3
	}
	return n
}

func (m *ModelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ModelVersion != nil {
		l = len(*m.ModelVersion)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.StudyName != nil {
		l = len(*m.StudyName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Task != nil {
		l = len(*m.Task)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Objective != nil {
		l = len(*m.Objective)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FeatureEngineering != nil {
		l = m.FeatureEngineering.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Estimator != nil {
		l = m.Estimator.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Dnn != nil {
		l = m.Dnn.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Chatbot != nil {
		l = m.Chatbot.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.NLPEstimator != nil {
		l = m.NLPEstimator.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Ensemble != nil {
		l = m.Ensemble.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Training != nil {
		l = m.Training.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Tested != nil {
		n += 3
	}
	if m.Aborted != nil {
		n += 3
	}
	if m.Packaged != nil {
		n += 3
	}
	if m.Published != nil {
		n += 3
	}
	if m.Pushed != nil {
		n += 3
	}
	if m.Reported != nil {
		n += 3
	}
	if m.Paused != nil {
		n += 3
	}
	if m.Profiled != nil {
		n += 3
	}
	if m.Archived != nil {
		n += 3
	}
	if m.Forecasted != nil {
		n += 3
	}
	if m.Released != nil {
		n += 3
	}
	if m.Benchmarked != nil {
		n += 3
	}
	if m.Baseline != nil {
		n += 3
	}
	if m.Flagged != nil {
		n += 3
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Forecasting != nil {
		l = m.Forecasting.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Compilation != nil {
		l = m.Compilation.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.ActiveDeadlineSeconds != nil {
		n += 2 + sovGenerated(uint64(*m.ActiveDeadlineSeconds))
	}
	if m.EstimatorType != nil {
		l = len(*m.EstimatorType)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.TTL != nil {
		n += 2 + sovGenerated(uint64(*m.TTL))
	}
	if m.FeatureEngineeringOnly != nil {
		n += 3
	}
	return n
}

func (m *ModelStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TrainingStartTime != nil {
		l = m.TrainingStartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TrainingEndTime != nil {
		l = m.TrainingEndTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TestingStartTime != nil {
		l = m.TestingStartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TestingEndTime != nil {
		l = m.TestingEndTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	n += 9
	n += 9
	n += 9
	n += 9
	n += 2
	if len(m.CV) > 0 {
		for _, e := range m.CV {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Train) > 0 {
		for _, e := range m.Train {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Test) > 0 {
		for _, e := range m.Test {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ReportName)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.ReportUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.ManifestUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.WeightsUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.LabelEncoderUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.LogsUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.ProfileUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.MisclassUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.TarUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.AppUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.ImageName)
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.Importance) > 0 {
		for _, e := range m.Importance {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	l = len(m.ForecastUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.PythonVersion)
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.PythonPackages) > 0 {
		for k, v := range m.PythonPackages {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 2 + sovGenerated(uint64(mapEntrySize))
		}
	}
	l = m.TrainDatasetLocation.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.TestDatasetLocation.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.ValidationDataset.Size()
	n += 2 + l + sovGenerated(uint64(l))
	n += 2 + sovGenerated(uint64(m.ObservedGeneration))
	if m.TrainingRows != nil {
		n += 2 + sovGenerated(uint64(*m.TrainingRows))
	}
	if m.TestingRows != nil {
		n += 2 + sovGenerated(uint64(*m.TestingRows))
	}
	if m.ValidationRows != nil {
		n += 2 + sovGenerated(uint64(*m.ValidationRows))
	}
	l = len(m.LastError)
	n += 2 + l + sovGenerated(uint64(l))
	if m.Progress != nil {
		n += 2 + sovGenerated(uint64(*m.Progress))
	}
	n += 2 + sovGenerated(uint64(m.SizeInBytes))
	n += 10
	l = len(m.URL)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.PredictorName)
	n += 2 + l + sovGenerated(uint64(l))
	if m.ReleasedAt != nil {
		l = m.ReleasedAt.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	l = len(m.TarFileHash)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.ImageHash)
	n += 2 + l + sovGenerated(uint64(l))
	l = m.TrainingDataHash.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.TrainingResources.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.TestingResources.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.TrainedBy)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.Team)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.TrainerImage)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.EndPoint)
	n += 2 + l + sovGenerated(uint64(l))
	l = m.Logs.Size()
	n += 2 + l + sovGenerated(uint64(l))
	if m.TrialID != nil {
		n += 2 + sovGenerated(uint64(*m.TrialID))
	}
	l = m.RocAucCurve.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.PRCurve.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.ConfusionMatrix.Size()
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	if m.PrevModel != nil {
		l = len(*m.PrevModel)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.DriftFreq)
	n += 1 + l + sovGenerated(uint64(l))
	if m.DriftInterval != nil {
		n += 1 + sovGenerated(uint64(*m.DriftInterval))
	}
	if m.Column != nil {
		l = len(*m.Column)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Metric != nil {
		l = len(*m.Metric)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Min != nil {
		n += 9
	}
	if m.Max != nil {
		n += 9
	}
	if m.MinPrecent != nil {
		n += 9
	}
	if m.MaxPrecent != nil {
		n += 9
	}
	if m.Agg != nil {
		l = len(*m.Agg)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ModelValidationResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DatasetName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ModelName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Column)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Error)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Metric != nil {
		l = len(*m.Metric)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ActualValue != nil {
		n += 9
	}
	n += 2
	if m.At != nil {
		l = m.At.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	n += 1 + sovGenerated(uint64(m.DurationInSec))
	return n
}

func (m *NLPEstimatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = len(*m.Base)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *NNLayerParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *Notebook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *NotebookCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *NotebookList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *NotebookRun) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *NotebookRunCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *NotebookRunList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *NotebookRunSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.NotebookName != nil {
		l = len(*m.NotebookName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TTL != nil {
		n += 1 + sovGenerated(uint64(*m.TTL))
	}
	return n
}

func (m *NotebookRunStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	l = len(m.LastError)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.TriggeredBy)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Logs.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *NotebookSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SchemaRef != nil {
		l = m.SchemaRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ImageName != nil {
		l = len(*m.ImageName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Requirements != nil {
		l = len(*m.Requirements)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DebPackages != nil {
		l = len(*m.DebPackages)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Vars) > 0 {
		for _, s := range m.Vars {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ActiveDeadlineSeconds != nil {
		n += 1 + sovGenerated(uint64(*m.ActiveDeadlineSeconds))
	}
	l = m.Schedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Priority != nil {
		l = len(*m.Priority)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Paused != nil {
		n += 2
	}
	return n
}

func (m *NotebookStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.URI)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if m.LastRun != nil {
		l = m.LastRun.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *NotebookVarValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *PeriodSeasonalitySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.Periods != nil {
		n += 1 + sovGenerated(uint64(*m.Periods))
	}
	if m.Mode != nil {
		l = len(*m.Mode)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *PeriodSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Interval != nil {
		l = len(*m.Interval)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Start != nil {
		n += 1 + sovGenerated(uint64(*m.Start))
	}
	if m.End != nil {
		n += 1 + sovGenerated(uint64(*m.End))
	}
	return n
}

func (m *PrunerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.StartupTrials != nil {
		n += 1 + sovGenerated(uint64(*m.StartupTrials))
	}
	if m.WramupTrials != nil {
		n += 1 + sovGenerated(uint64(*m.WramupTrials))
	}
	if m.MinimumTrials != nil {
		n += 1 + sovGenerated(uint64(*m.MinimumTrials))
	}
	if m.IntervalSteps != nil {
		n += 1 + sovGenerated(uint64(*m.IntervalSteps))
	}
	if m.Precentile != nil {
		n += 1 + sovGenerated(uint64(*m.Precentile))
	}
	if m.Lower != nil {
		n += 1 + sovGenerated(uint64(*m.Lower))
	}
	if m.Upper != nil {
		n += 1 + sovGenerated(uint64(*m.Upper))
	}
	if m.SHOptions != nil {
		l = m.SHOptions.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *RegressorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.PriorScale != nil {
		n += 9
	}
	if m.Standardize != nil {
		n += 2
	}
	return n
}

func (m *ReleaseStageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.ServingSiteName != nil {
		l = len(*m.ServingSiteName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.PredictorName != nil {
		l = len(*m.PredictorName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Template != nil {
		l = m.Template.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ManualApproval != nil {
		n += 2
	}
	if len(m.Validations) > 0 {
		for _, e := range m.Validations {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *Report) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ReportCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ReportList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ReportSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.EntityRef.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ReportType != nil {
		l = len(*m.ReportType)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Format != nil {
		l = len(*m.Format)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.NotifierName != nil {
		l = len(*m.NotifierName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ActiveDeadlineSeconds != nil {
		n += 1 + sovGenerated(uint64(*m.ActiveDeadlineSeconds))
	}
	if m.Custom != nil {
		l = m.Custom.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ReportStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.URI)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	l = len(m.LastError)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Logs.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ReportTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ResourceConsumption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 9
	n += 9
	return n
}

func (m *Study) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *StudyCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *StudyForecastSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hierarchy != nil {
		l = m.Hierarchy.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.ForecastTemplate != nil {
		l = m.ForecastTemplate.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *StudyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *StudyScheduleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.StartAt != nil {
		l = m.StartAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *StudySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.LabRef != nil {
		l = m.LabRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Task != nil {
		l = len(*m.Task)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Objective != nil {
		l = len(*m.Objective)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Objective2 != nil {
		l = len(*m.Objective2)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Search != nil {
		l = m.Search.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FeatureEngineering != nil {
		l = m.FeatureEngineering.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TrainingTemplate != nil {
		l = m.TrainingTemplate.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Split != nil {
		l = m.Split.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Aborted != nil {
		n += 2
	}
	if m.FeatureEngineered != nil {
		n += 2
	}
	if m.Reported != nil {
		n += 2
	}
	if m.Paused != nil {
		n += 3
	}
	if m.Profiled != nil {
		n += 3
	}
	if m.ModelPublished != nil {
		n += 3
	}
	if m.ModelImagePushed != nil {
		n += 3
	}
	if m.ModelBenchmarked != nil {
		n += 3
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.ActiveDeadlineSeconds != nil {
		n += 2 + sovGenerated(uint64(*m.ActiveDeadlineSeconds))
	}
	if m.Compilation != nil {
		l = m.Compilation.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Template != nil {
		n += 3
	}
	if m.Flagged != nil {
		n += 3
	}
	l = m.Notification.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.ModelImage.Size()
	n += 2 + l + sovGenerated(uint64(l))
	if m.TTL != nil {
		n += 2 + sovGenerated(uint64(*m.TTL))
	}
	l = m.ForecastSpec.Size()
	n += 2 + l + sovGenerated(uint64(l))
	return n
}

func (m *StudyStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.Models))
	n += 1 + sovGenerated(uint64(m.FeatureEngineeringModelWaiting))
	n += 1 + sovGenerated(uint64(m.FeatureEngineeringModelTraining))
	n += 1 + sovGenerated(uint64(m.FeatureEngineeringModeFailed))
	n += 1 + sovGenerated(uint64(m.FeatureEngineeringModelTrained))
	n += 1 + sovGenerated(uint64(m.SearchingModelWaiting))
	n += 1 + sovGenerated(uint64(m.SearchingModelsTraining))
	n += 1 + sovGenerated(uint64(m.SearchingModeFailed))
	n += 1 + sovGenerated(uint64(m.SearchingModeTrained))
	n += 1 + sovGenerated(uint64(m.TestingModelWaiting))
	n += 1 + sovGenerated(uint64(m.TestingModels))
	n += 1 + sovGenerated(uint64(m.TestingModeFailed))
	n += 1 + sovGenerated(uint64(m.TestedModels))
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FeatureEngineeringStartTime != nil {
		l = m.FeatureEngineeringStartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FeatureEngineerinEndTime != nil {
		l = m.FeatureEngineerinEndTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.SearchingStartTime != nil {
		l = m.SearchingStartTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.SearchingEndTime != nil {
		l = m.SearchingEndTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.TestingStartTime != nil {
		l = m.TestingStartTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.TestingEndTime != nil {
		l = m.TestingEndTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	l = len(m.BestModel)
	n += 2 + l + sovGenerated(uint64(l))
	n += 10
	l = len(m.ProfileUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.ReportName)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.Phase)
	n += 2 + l + sovGenerated(uint64(l))
	n += 2 + sovGenerated(uint64(m.ObservedGeneration))
	l = m.TrainDatasetLocation.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.TestDatasetLocation.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.ValidationDataset.Size()
	n += 2 + l + sovGenerated(uint64(l))
	if m.LastModelID != nil {
		n += 2 + sovGenerated(uint64(*m.LastModelID))
	}
	if m.LastError != nil {
		l = len(*m.LastError)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.TrainingRows != nil {
		n += 2 + sovGenerated(uint64(*m.TrainingRows))
	}
	if m.TestingRows != nil {
		n += 2 + sovGenerated(uint64(*m.TestingRows))
	}
	if m.ValidationRows != nil {
		n += 2 + sovGenerated(uint64(*m.ValidationRows))
	}
	if m.Progress != nil {
		n += 2 + sovGenerated(uint64(*m.Progress))
	}
	if m.BaslineModel != nil {
		l = len(*m.BaslineModel)
		n += 2 + l + sovGenerated(uint64(l))
	}
	l = m.TrainingDataHash.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.TriggeredBy)
	n += 2 + l + sovGenerated(uint64(l))
	l = m.Logs.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.FeatureEngineeringStatus.Size()
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *SuccessiveHalvingOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxBudget != nil {
		n += 1 + sovGenerated(uint64(*m.MaxBudget))
	}
	if m.EliminationRate != nil {
		n += 1 + sovGenerated(uint64(*m.EliminationRate))
	}
	if m.Modality != nil {
		l = len(*m.Modality)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *SuccessiveHalvingSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Budget != nil {
		n += 1 + sovGenerated(uint64(*m.Budget))
	}
	if m.Bracket != nil {
		n += 1 + sovGenerated(uint64(*m.Bracket))
	}
	if m.Rung != nil {
		n += 1 + sovGenerated(uint64(*m.Rung))
	}
	if m.ConfID != nil {
		n += 1 + sovGenerated(uint64(*m.ConfID))
	}
	if m.Modality != nil {
		l = len(*m.Modality)
		n += 2 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *TextPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Encoder != nil {
		l = len(*m.Encoder)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Tokenizer != nil {
		l = len(*m.Tokenizer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.StopWords != nil {
		n += 2
	}
	if m.Pos != nil {
		n += 2
	}
	if m.Lemma != nil {
		n += 2
	}
	if m.Stem != nil {
		n += 2
	}
	if m.Embedding != nil {
		l = len(*m.Embedding)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Svd != nil {
		n += 2
	}
	if m.MaxSvdComponents != nil {
		n += 1 + sovGenerated(uint64(*m.MaxSvdComponents))
	}
	return n
}

func (m *TimeSeriesDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimeColumn != nil {
		l = len(*m.TimeColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TargetColumn != nil {
		l = len(*m.TargetColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DateTimeFormat != nil {
		l = len(*m.DateTimeFormat)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Holiday.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.GroupColumn != nil {
		l = len(*m.GroupColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SubGroupColumn != nil {
		l = len(*m.SubGroupColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SubSubGroupColumn != nil {
		l = len(*m.SubSubGroupColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.History != nil {
		l = m.History.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Forecast != nil {
		l = m.Forecast.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.YearlySeasonality.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.WeeklySeasonality.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.DailySeasonality.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Growth != nil {
		l = len(*m.Growth)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Regressors) > 0 {
		for _, e := range m.Regressors {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.CustomSeasonalities) > 0 {
		for _, e := range m.CustomSeasonalities {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = m.ChangePoints.Size()
	n += 2 + l + sovGenerated(uint64(l))
	if m.IntervalWidth != nil {
		n += 10
	}
	if m.UncertaintySamples != nil {
		n += 2 + sovGenerated(uint64(*m.UncertaintySamples))
	}
	return n
}

func (m *TrainingSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != nil {
		l = len(*m.Priority)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CvType != nil {
		l = len(*m.CvType)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CV != nil {
		n += 2
	}
	if m.Folds != nil {
		n += 1 + sovGenerated(uint64(*m.Folds))
	}
	if len(m.EvalMetrics) > 0 {
		for _, s := range m.EvalMetrics {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.EarlyStop != nil {
		n += 2
	}
	if m.CheckpointInterval != nil {
		n += 1 + sovGenerated(uint64(*m.CheckpointInterval))
	}
	if m.SH != nil {
		l = m.SH.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Seed != nil {
		n += 9
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Gpu != nil {
		n += 2
	}
	if m.Dist != nil {
		n += 2
	}
	if m.NodeCount != nil {
		n += 1 + sovGenerated(uint64(*m.NodeCount))
	}
	l = m.Sample.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *TrainingStageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.NotebookName != nil {
		l = len(*m.NotebookName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.LabName != nil {
		l = len(*m.LabName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.StudyTemplateName != nil {
		l = len(*m.StudyTemplateName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Validations) > 0 {
		for _, e := range m.Validations {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *UATStageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.ServingSiteName != nil {
		l = len(*m.ServingSiteName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Validations) > 0 {
		for _, e := range m.Validations {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *VideoPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Featurizer != nil {
		l = len(*m.Featurizer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func sovGenerated(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenerated(x uint64) (n int) {
	return sovGenerated(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AlgorithmSearchSpaceSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AlgorithmSearchSpaceSpec{`,
		`AllowList:` + fmt.Sprintf("%v", this.AllowList) + `,`,
		`VotingEnsemble:` + valueToStringGenerated(this.VotingEnsemble) + `,`,
		`StackingEnsemble:` + valueToStringGenerated(this.StackingEnsemble) + `,`,
		`AlgorithmFilter:` + valueToStringGenerated(this.AlgorithmFilter) + `,`,
		`Baselines:` + fmt.Sprintf("%v", this.Baselines) + `,`,
		`TestAll:` + valueToStringGenerated(this.TestAll) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AudioPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AudioPipelineSpec{`,
		`Featurizer:` + valueToStringGenerated(this.Featurizer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BacktestSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BacktestSpec{`,
		`Sliding:` + valueToStringGenerated(this.Sliding) + `,`,
		`TrainingWindowSize:` + valueToStringGenerated(this.TrainingWindowSize) + `,`,
		`ForecastingWindowSize:` + valueToStringGenerated(this.ForecastingWindowSize) + `,`,
		`SlidingSteps:` + valueToStringGenerated(this.SlidingSteps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CapacityStageSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValidations := "[]ModelValidation{"
	for _, f := range this.Validations {
		repeatedStringForValidations += strings.Replace(strings.Replace(f.String(), "ModelValidation", "ModelValidation", 1), `&`, ``, 1) + ","
	}
	repeatedStringForValidations += "}"
	s := strings.Join([]string{`&CapacityStageSpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`ServingSiteName:` + valueToStringGenerated(this.ServingSiteName) + `,`,
		`Validations:` + repeatedStringForValidations + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChangePointSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChangePointSpec{`,
		`N:` + valueToStringGenerated(this.N) + `,`,
		`Range:` + valueToStringGenerated(this.Range) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChatbotEstimatorSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChatbotEstimatorSpec{`,
		`Base:` + valueToStringGenerated(this.Base) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClassicalEstimatorSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParameters := "[]HyperParameterValue{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "HyperParameterValue", "HyperParameterValue", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&ClassicalEstimatorSpec{`,
		`AlgorithmName:` + fmt.Sprintf("%v", this.AlgorithmName) + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`}`,
	}, "")
	return s
}
func (this *CronReport) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CronReport{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "CronReportSpec", "CronReportSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "CronReportStatus", "CronReportStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CronReportCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CronReportCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CronReportList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]CronReport{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "CronReport", "CronReport", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&CronReportList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *CronReportSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CronReportSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`Schedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Schedule), "RunSchedule", "v1alpha1.RunSchedule", 1), `&`, ``, 1) + `,`,
		`Range:` + valueToStringGenerated(this.Range) + `,`,
		`Template:` + strings.Replace(strings.Replace(this.Template.String(), "ReportTemplate", "ReportTemplate", 1), `&`, ``, 1) + `,`,
		`Paused:` + valueToStringGenerated(this.Paused) + `,`,
		`Notification:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Notification), "NotificationSpec", "v1alpha1.NotificationSpec", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CronReportStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]CronReportCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "CronReportCondition", "CronReportCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&CronReportStatus{`,
		`LastRun:` + strings.Replace(fmt.Sprintf("%v", this.LastRun), "Time", "v1.Time", 1) + `,`,
		`LastUpdated:` + strings.Replace(fmt.Sprintf("%v", this.LastUpdated), "Time", "v1.Time", 1) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomReportBarChart) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomReportBarChart{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`X:` + valueToStringGenerated(this.X) + `,`,
		`Y:` + valueToStringGenerated(this.Y) + `,`,
		`Legend:` + valueToStringGenerated(this.Legend) + `,`,
		`Sort:` + valueToStringGenerated(this.Sort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomReportHistogram) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomReportHistogram{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`X:` + valueToStringGenerated(this.X) + `,`,
		`Bins:` + valueToStringGenerated(this.Bins) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomReportLineChart) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomReportLineChart{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`X:` + valueToStringGenerated(this.X) + `,`,
		`Y:` + valueToStringGenerated(this.Y) + `,`,
		`Legend:` + valueToStringGenerated(this.Legend) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomReportScatterPlot) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomReportScatterPlot{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`X:` + valueToStringGenerated(this.X) + `,`,
		`Y:` + valueToStringGenerated(this.Y) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomReportSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValues := "[]CustomReportValue{"
	for _, f := range this.Values {
		repeatedStringForValues += strings.Replace(strings.Replace(f.String(), "CustomReportValue", "CustomReportValue", 1), `&`, ``, 1) + ","
	}
	repeatedStringForValues += "}"
	repeatedStringForTables := "[]CustomReportTable{"
	for _, f := range this.Tables {
		repeatedStringForTables += strings.Replace(strings.Replace(f.String(), "CustomReportTable", "CustomReportTable", 1), `&`, ``, 1) + ","
	}
	repeatedStringForTables += "}"
	repeatedStringForLineCharts := "[]CustomReportLineChart{"
	for _, f := range this.LineCharts {
		repeatedStringForLineCharts += strings.Replace(strings.Replace(f.String(), "CustomReportLineChart", "CustomReportLineChart", 1), `&`, ``, 1) + ","
	}
	repeatedStringForLineCharts += "}"
	repeatedStringForBarCharts := "[]CustomReportBarChart{"
	for _, f := range this.BarCharts {
		repeatedStringForBarCharts += strings.Replace(strings.Replace(f.String(), "CustomReportBarChart", "CustomReportBarChart", 1), `&`, ``, 1) + ","
	}
	repeatedStringForBarCharts += "}"
	repeatedStringForHistCharts := "[]CustomReportHistogram{"
	for _, f := range this.HistCharts {
		repeatedStringForHistCharts += strings.Replace(strings.Replace(f.String(), "CustomReportHistogram", "CustomReportHistogram", 1), `&`, ``, 1) + ","
	}
	repeatedStringForHistCharts += "}"
	repeatedStringForScatterCharts := "[]CustomReportHistogram{"
	for _, f := range this.ScatterCharts {
		repeatedStringForScatterCharts += strings.Replace(strings.Replace(f.String(), "CustomReportHistogram", "CustomReportHistogram", 1), `&`, ``, 1) + ","
	}
	repeatedStringForScatterCharts += "}"
	s := strings.Join([]string{`&CustomReportSpec{`,
		`Values:` + repeatedStringForValues + `,`,
		`Tables:` + repeatedStringForTables + `,`,
		`LineCharts:` + repeatedStringForLineCharts + `,`,
		`BarCharts:` + repeatedStringForBarCharts + `,`,
		`HistCharts:` + repeatedStringForHistCharts + `,`,
		`ScatterCharts:` + repeatedStringForScatterCharts + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomReportTable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomReportTable{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Filters:` + fmt.Sprintf("%v", this.Filters) + `,`,
		`GroupBy:` + fmt.Sprintf("%v", this.GroupBy) + `,`,
		`Rows:` + valueToStringGenerated(this.Rows) + `,`,
		`ShowIndex:` + valueToStringGenerated(this.ShowIndex) + `,`,
		`Border:` + valueToStringGenerated(this.Border) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomReportValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomReportValue{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Column:` + valueToStringGenerated(this.Column) + `,`,
		`Row:` + valueToStringGenerated(this.Row) + `,`,
		`Scalar:` + valueToStringGenerated(this.Scalar) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomSeasonalitySpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomSeasonalitySpec{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Period:` + fmt.Sprintf("%v", this.Period) + `,`,
		`FourierOrder:` + valueToStringGenerated(this.FourierOrder) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataHashes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataHashes{`,
		`TrainingHash:` + valueToStringGenerated(this.TrainingHash) + `,`,
		`TestingHash:` + valueToStringGenerated(this.TestingHash) + `,`,
		`ValidationHash:` + valueToStringGenerated(this.ValidationHash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSplit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSplit{`,
		`Auto:` + valueToStringGenerated(this.Auto) + `,`,
		`Train:` + valueToStringGenerated(this.Train) + `,`,
		`Validation:` + valueToStringGenerated(this.Validation) + `,`,
		`Test:` + valueToStringGenerated(this.Test) + `,`,
		`SplitPolicy:` + valueToStringGenerated(this.SplitPolicy) + `,`,
		`SplitColumn:` + valueToStringGenerated(this.SplitColumn) + `,`,
		`Seed:` + valueToStringGenerated(this.Seed) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataStageSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataStageSpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`LabName:` + valueToStringGenerated(this.LabName) + `,`,
		`DataPipelineName:` + valueToStringGenerated(this.DataPipelineName) + `,`,
		`DatasourceName:` + valueToStringGenerated(this.DatasourceName) + `,`,
		`DockerImage:` + valueToStringGenerated(this.DockerImage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeepEstimatorLayer) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParameters := "[]NNLayerParameter{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "NNLayerParameter", "NNLayerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&DeepEstimatorLayer{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`InputLayers:` + fmt.Sprintf("%v", this.InputLayers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeepEstimatorSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLayers := "[]DeepEstimatorLayer{"
	for _, f := range this.Layers {
		repeatedStringForLayers += strings.Replace(strings.Replace(f.String(), "DeepEstimatorLayer", "DeepEstimatorLayer", 1), `&`, ``, 1) + ","
	}
	repeatedStringForLayers += "}"
	s := strings.Join([]string{`&DeepEstimatorSpec{`,
		`Layers:` + repeatedStringForLayers + `,`,
		`Type:` + valueToStringGenerated(this.Type) + `,`,
		`BatchSize:` + valueToStringGenerated(this.BatchSize) + `,`,
		`Epochs:` + valueToStringGenerated(this.Epochs) + `,`,
		`ValidationSplit:` + valueToStringGenerated(this.ValidationSplit) + `,`,
		`Seq:` + valueToStringGenerated(this.Seq) + `,`,
		`Gpus:` + valueToStringGenerated(this.Gpus) + `,`,
		`Loss:` + fmt.Sprintf("%v", this.Loss) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeploymentStageSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValidations := "[]ModelValidation{"
	for _, f := range this.Validations {
		repeatedStringForValidations += strings.Replace(strings.Replace(f.String(), "ModelValidation", "ModelValidation", 1), `&`, ``, 1) + ","
	}
	repeatedStringForValidations += "}"
	s := strings.Join([]string{`&DeploymentStageSpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`ServingSiteName:` + valueToStringGenerated(this.ServingSiteName) + `,`,
		`ManualApproval:` + valueToStringGenerated(this.ManualApproval) + `,`,
		`Validations:` + repeatedStringForValidations + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EnsembleRules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EnsembleRules{`,
		`}`,
	}, "")
	return s
}
func (this *EnsembleSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EnsembleSpec{`,
		`Base:` + fmt.Sprintf("%v", this.Base) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureEngineeringPipeline) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGenereted := "[]GeneratedColumnSpec{"
	for _, f := range this.Genereted {
		repeatedStringForGenereted += strings.Replace(strings.Replace(f.String(), "GeneratedColumnSpec", "GeneratedColumnSpec", 1), `&`, ``, 1) + ","
	}
	repeatedStringForGenereted += "}"
	repeatedStringForCustom := "[]GeneratedColumnSpec{"
	for _, f := range this.Custom {
		repeatedStringForCustom += strings.Replace(strings.Replace(f.String(), "GeneratedColumnSpec", "GeneratedColumnSpec", 1), `&`, ``, 1) + ","
	}
	repeatedStringForCustom += "}"
	s := strings.Join([]string{`&FeatureEngineeringPipeline{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DataType:` + fmt.Sprintf("%v", this.DataType) + `,`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Imputation:` + valueToStringGenerated(this.Imputation) + `,`,
		`Encoding:` + valueToStringGenerated(this.Encoding) + `,`,
		`Scaling:` + valueToStringGenerated(this.Scaling) + `,`,
		`Discretisation:` + valueToStringGenerated(this.Discretisation) + `,`,
		`VariableTransformation:` + valueToStringGenerated(this.VariableTransformation) + `,`,
		`OutlierHandling:` + valueToStringGenerated(this.OutlierHandling) + `,`,
		`DatetimeTransformation:` + valueToStringGenerated(this.DatetimeTransformation) + `,`,
		`Text:` + strings.Replace(this.Text.String(), "TextPipelineSpec", "TextPipelineSpec", 1) + `,`,
		`Image:` + strings.Replace(this.Image.String(), "ImagePipelineSpec", "ImagePipelineSpec", 1) + `,`,
		`Audio:` + strings.Replace(this.Audio.String(), "AudioPipelineSpec", "AudioPipelineSpec", 1) + `,`,
		`Video:` + strings.Replace(this.Video.String(), "VideoPipelineSpec", "VideoPipelineSpec", 1) + `,`,
		`Genereted:` + repeatedStringForGenereted + `,`,
		`Custom:` + repeatedStringForCustom + `,`,
		`Drop:` + valueToStringGenerated(this.Drop) + `,`,
		`Passtrough:` + valueToStringGenerated(this.Passtrough) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureEngineeringSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPipelines := "[]FeatureEngineeringPipeline{"
	for _, f := range this.Pipelines {
		repeatedStringForPipelines += strings.Replace(strings.Replace(f.String(), "FeatureEngineeringPipeline", "FeatureEngineeringPipeline", 1), `&`, ``, 1) + ","
	}
	repeatedStringForPipelines += "}"
	s := strings.Join([]string{`&FeatureEngineeringSpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`Pipelines:` + repeatedStringForPipelines + `,`,
		`FeatureSelection:` + strings.Replace(strings.Replace(this.FeatureSelection.String(), "FeatureSelectionSpec", "FeatureSelectionSpec", 1), `&`, ``, 1) + `,`,
		`Estimator:` + valueToStringGenerated(this.Estimator) + `,`,
		`MaxModels:` + valueToStringGenerated(this.MaxModels) + `,`,
		`MaxTimeSec:` + valueToStringGenerated(this.MaxTimeSec) + `,`,
		`MaxTrainers:` + valueToStringGenerated(this.MaxTrainers) + `,`,
		`SamplePct:` + valueToStringGenerated(this.SamplePct) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureEngineeringStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeatureEngineeringStatus{`,
		`BestPipeline:` + strings.Replace(strings.Replace(this.BestPipeline.String(), "FeatureEngineeringPipeline", "FeatureEngineeringPipeline", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureImportance) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeatureImportance{`,
		`Feature:` + fmt.Sprintf("%v", this.Feature) + `,`,
		`Importance:` + fmt.Sprintf("%v", this.Importance) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeatureInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureSelectionSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeatureSelectionSpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`VarianceTresholdPct:` + valueToStringGenerated(this.VarianceTresholdPct) + `,`,
		`CorrTreshold:` + valueToStringGenerated(this.CorrTreshold) + `,`,
		`TopN:` + valueToStringGenerated(this.TopN) + `,`,
		`CumulativeImportancePrecent:` + valueToStringGenerated(this.CumulativeImportancePrecent) + `,`,
		`Reserved:` + fmt.Sprintf("%v", this.Reserved) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForecastObj) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForecastObj{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`LevelIndex:` + fmt.Sprintf("%v", this.LevelIndex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForecastPostProcessingSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForecastPostProcessingSpec{`,
		`ConnectionName:` + valueToStringGenerated(this.ConnectionName) + `,`,
		`Forecast:` + valueToStringGenerated(this.Forecast) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForecastSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForecastSpec{`,
		`Data:` + strings.Replace(strings.Replace(this.Data.String(), "TimeSeriesDataSpec", "TimeSeriesDataSpec", 1), `&`, ``, 1) + `,`,
		`ConfidenceInterval:` + valueToStringGenerated(this.ConfidenceInterval) + `,`,
		`Backtest:` + strings.Replace(strings.Replace(this.Backtest.String(), "BacktestSpec", "BacktestSpec", 1), `&`, ``, 1) + `,`,
		`PostPrecessing:` + strings.Replace(strings.Replace(this.PostPrecessing.String(), "ForecastPostProcessingSpec", "ForecastPostProcessingSpec", 1), `&`, ``, 1) + `,`,
		`Plot:` + valueToStringGenerated(this.Plot) + `,`,
		`PlotChangePoints:` + valueToStringGenerated(this.PlotChangePoints) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FormatSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FormatSpec{`,
		`}`,
	}, "")
	return s
}
func (this *GeneratedColumnSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GeneratedColumnSpec{`,
		`Name:` + valueToStringGenerated(this.Name) + `,`,
		`DataType:` + fmt.Sprintf("%v", this.DataType) + `,`,
		`First:` + fmt.Sprintf("%v", this.First) + `,`,
		`Second:` + fmt.Sprintf("%v", this.Second) + `,`,
		`Expression:` + fmt.Sprintf("%v", this.Expression) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Hierarchy) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGroupLevels := "[]Level{"
	for _, f := range this.GroupLevels {
		repeatedStringForGroupLevels += strings.Replace(strings.Replace(f.String(), "Level", "Level", 1), `&`, ``, 1) + ","
	}
	repeatedStringForGroupLevels += "}"
	s := strings.Join([]string{`&Hierarchy{`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`GroupLevels:` + repeatedStringForGroupLevels + `,`,
		`ItemLevel:` + strings.Replace(this.ItemLevel.String(), "Level", "Level", 1) + `,`,
		`NotifierName:` + valueToStringGenerated(this.NotifierName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HolidaySpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HolidaySpec{`,
		`HolidayColumn:` + valueToStringGenerated(this.HolidayColumn) + `,`,
		`Country:` + valueToStringGenerated(this.Country) + `,`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HyperParameterValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HyperParameterValue{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImagePipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImagePipelineSpec{`,
		`Featurizer:` + valueToStringGenerated(this.Featurizer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Level) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Level{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Horizon:` + fmt.Sprintf("%v", this.Horizon) + `,`,
		`Freq:` + valueToStringGenerated(this.Freq) + `,`,
		`Aggregate:` + valueToStringGenerated(this.Aggregate) + `,`,
		`Values:` + fmt.Sprintf("%v", this.Values) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Model) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Model{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "ModelSpec", "ModelSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "ModelStatus", "ModelStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelAutobuilder) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelAutobuilder{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "ModelAutobuilderSpec", "ModelAutobuilderSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "ModelAutobuilderStatus", "ModelAutobuilderStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelAutobuilderCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelAutobuilderCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelAutobuilderList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]ModelAutobuilder{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "ModelAutobuilder", "ModelAutobuilder", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ModelAutobuilderList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelAutobuilderSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelAutobuilderSpec{`,
		`DataProductName:` + valueToStringGenerated(this.DataProductName) + `,`,
		`DataProductVersionName:` + valueToStringGenerated(this.DataProductVersionName) + `,`,
		`DataSourceName:` + valueToStringGenerated(this.DataSourceName) + `,`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha11.DataLocation", 1) + `,`,
		`Task:` + valueToStringGenerated(this.Task) + `,`,
		`Objective:` + valueToStringGenerated(this.Objective) + `,`,
		`TargetColumn:` + valueToStringGenerated(this.TargetColumn) + `,`,
		`MaxTime:` + valueToStringGenerated(this.MaxTime) + `,`,
		`MaxModels:` + valueToStringGenerated(this.MaxModels) + `,`,
		`AccessMethod:` + valueToStringGenerated(this.AccessMethod) + `,`,
		`AutoScale:` + valueToStringGenerated(this.AutoScale) + `,`,
		`DataSourceSpec:` + strings.Replace(fmt.Sprintf("%v", this.DataSourceSpec), "DataSourceSpec", "v1alpha11.DataSourceSpec", 1) + `,`,
		`Trainers:` + valueToStringGenerated(this.Trainers) + `,`,
		`Sampler:` + valueToStringGenerated(this.Sampler) + `,`,
		`Aborted:` + valueToStringGenerated(this.Aborted) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`Workload:` + valueToStringGenerated(this.Workload) + `,`,
		`LabRef:` + strings.Replace(fmt.Sprintf("%v", this.LabRef), "ObjectReference", "v11.ObjectReference", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelAutobuilderStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]ModelAutobuilderCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "ModelAutobuilderCondition", "ModelAutobuilderCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&ModelAutobuilderStatus{`,
		`FlatFileName:` + fmt.Sprintf("%v", this.FlatFileName) + `,`,
		`DataSourceName:` + fmt.Sprintf("%v", this.DataSourceName) + `,`,
		`DatasetName:` + fmt.Sprintf("%v", this.DatasetName) + `,`,
		`StudyName:` + fmt.Sprintf("%v", this.StudyName) + `,`,
		`BestModelName:` + fmt.Sprintf("%v", this.BestModelName) + `,`,
		`PredictorName:` + fmt.Sprintf("%v", this.PredictorName) + `,`,
		`ImageRepoName:` + fmt.Sprintf("%v", this.ImageRepoName) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`Rows:` + fmt.Sprintf("%v", this.Rows) + `,`,
		`Cols:` + fmt.Sprintf("%v", this.Cols) + `,`,
		`FileSize:` + fmt.Sprintf("%v", this.FileSize) + `,`,
		`Models:` + fmt.Sprintf("%v", this.Models) + `,`,
		`TrainedModels:` + fmt.Sprintf("%v", this.TrainedModels) + `,`,
		`BestModelScore:` + fmt.Sprintf("%v", this.BestModelScore) + `,`,
		`Estimator:` + strings.Replace(this.Estimator.String(), "ClassicalEstimatorSpec", "ClassicalEstimatorSpec", 1) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Time", "v1.Time", 1) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`LastError:` + fmt.Sprintf("%v", this.LastError) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelCompilerRun) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelCompilerRun{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "ModelCompilerRunSpec", "ModelCompilerRunSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "ModelCompilerRunStatus", "ModelCompilerRunStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelCompilerRunCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelCompilerRunCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelCompilerRunList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]ModelCompilerRun{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "ModelCompilerRun", "ModelCompilerRun", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ModelCompilerRunList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelCompilerRunSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelCompilerRunSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`ModelName:` + valueToStringGenerated(this.ModelName) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`Priority:` + valueToStringGenerated(this.Priority) + `,`,
		`Compiler:` + valueToStringGenerated(this.Compiler) + `,`,
		`Target:` + valueToStringGenerated(this.Target) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelCompilerRunStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]ModelCompilerRunCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "ModelCompilerRunCondition", "ModelCompilerRunCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&ModelCompilerRunStatus{`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`CompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.CompletionTime), "Time", "v1.Time", 1) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`Folder:` + fmt.Sprintf("%v", this.Folder) + `,`,
		`LastError:` + fmt.Sprintf("%v", this.LastError) + `,`,
		`Progress:` + valueToStringGenerated(this.Progress) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelImageSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelImageSpec{`,
		`Exist:` + valueToStringGenerated(this.Exist) + `,`,
		`ImageName:` + valueToStringGenerated(this.ImageName) + `,`,
		`RegistryConnection:` + valueToStringGenerated(this.RegistryConnection) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]Model{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "Model", "Model", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ModelList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipeline) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelPipeline{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "ModelPipelineSpec", "ModelPipelineSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "ModelPipelineStatus", "ModelPipelineStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelPipelineCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]ModelPipeline{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "ModelPipeline", "ModelPipeline", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ModelPipelineList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineRun) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelPipelineRun{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "ModelPipelineRunSpec", "ModelPipelineRunSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "ModelPipelineRunStatus", "ModelPipelineRunStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineRunCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelPipelineRunCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineRunList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]ModelPipelineRun{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "ModelPipelineRun", "ModelPipelineRun", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ModelPipelineRunList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineRunSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelPipelineRunSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`Dataset:` + valueToStringGenerated(this.Dataset) + `,`,
		`PipelineName:` + valueToStringGenerated(this.PipelineName) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`Priority:` + valueToStringGenerated(this.Priority) + `,`,
		`Paused:` + valueToStringGenerated(this.Paused) + `,`,
		`Aborted:` + valueToStringGenerated(this.Aborted) + `,`,
		`TTL:` + valueToStringGenerated(this.TTL) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineRunStageStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResults := "[]ModelValidationResult{"
	for _, f := range this.Results {
		repeatedStringForResults += strings.Replace(strings.Replace(f.String(), "ModelValidationResult", "ModelValidationResult", 1), `&`, ``, 1) + ","
	}
	repeatedStringForResults += "}"
	s := strings.Join([]string{`&ModelPipelineRunStageStatus{`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`Approved:` + fmt.Sprintf("%v", this.Approved) + `,`,
		`ApprovedBy:` + fmt.Sprintf("%v", this.ApprovedBy) + `,`,
		`ApprovedAt:` + strings.Replace(fmt.Sprintf("%v", this.ApprovedAt), "Time", "v1.Time", 1) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Time", "v1.Time", 1) + `,`,
		`Results:` + repeatedStringForResults + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineRunStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]ModelPipelineRunCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "ModelPipelineRunCondition", "ModelPipelineRunCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&ModelPipelineRunStatus{`,
		`Stage:` + fmt.Sprintf("%v", this.Stage) + `,`,
		`DatasetName:` + fmt.Sprintf("%v", this.DatasetName) + `,`,
		`StudyName:` + fmt.Sprintf("%v", this.StudyName) + `,`,
		`ModelName:` + fmt.Sprintf("%v", this.ModelName) + `,`,
		`DataStatus:` + strings.Replace(strings.Replace(this.DataStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`TrainingStatus:` + strings.Replace(strings.Replace(this.TrainingStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`UATStatus:` + strings.Replace(strings.Replace(this.UATStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`CapacityStatus:` + strings.Replace(strings.Replace(this.CapacityStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`DeploymentStatus:` + strings.Replace(strings.Replace(this.DeploymentStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`ReleaseStatus:` + strings.Replace(strings.Replace(this.ReleaseStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`MonitoringStatus:` + strings.Replace(strings.Replace(this.MonitoringStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`LabelingStatus:` + strings.Replace(strings.Replace(this.LabelingStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`CompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.CompletionTime), "Time", "v1.Time", 1) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`Folder:` + fmt.Sprintf("%v", this.Folder) + `,`,
		`LastError:` + fmt.Sprintf("%v", this.LastError) + `,`,
		`Progress:` + valueToStringGenerated(this.Progress) + `,`,
		`TriggeredBy:` + fmt.Sprintf("%v", this.TriggeredBy) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	keysForDatasetSelector := make([]string, 0, len(this.DatasetSelector))
	for k := range this.DatasetSelector {
		keysForDatasetSelector = append(keysForDatasetSelector, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDatasetSelector)
	mapStringForDatasetSelector := "map[string]string{"
	for _, k := range keysForDatasetSelector {
		mapStringForDatasetSelector += fmt.Sprintf("%v: %v,", k, this.DatasetSelector[k])
	}
	mapStringForDatasetSelector += "}"
	s := strings.Join([]string{`&ModelPipelineSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`DatasetSelector:` + mapStringForDatasetSelector + `,`,
		`Data:` + strings.Replace(this.Data.String(), "DataStageSpec", "DataStageSpec", 1) + `,`,
		`Training:` + strings.Replace(this.Training.String(), "TrainingStageSpec", "TrainingStageSpec", 1) + `,`,
		`UAT:` + strings.Replace(this.UAT.String(), "UATStageSpec", "UATStageSpec", 1) + `,`,
		`Capacity:` + strings.Replace(this.Capacity.String(), "CapacityStageSpec", "CapacityStageSpec", 1) + `,`,
		`Deployment:` + strings.Replace(this.Deployment.String(), "DeploymentStageSpec", "DeploymentStageSpec", 1) + `,`,
		`Release:` + strings.Replace(this.Release.String(), "ReleaseStageSpec", "ReleaseStageSpec", 1) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha11.DataLocation", 1) + `,`,
		`Schedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Schedule), "RunSchedule", "v1alpha1.RunSchedule", 1), `&`, ``, 1) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`ApproverAccountName:` + valueToStringGenerated(this.ApproverAccountName) + `,`,
		`Notification:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Notification), "NotificationSpec", "v1alpha1.NotificationSpec", 1), `&`, ``, 1) + `,`,
		`BaselineModelName:` + valueToStringGenerated(this.BaselineModelName) + `,`,
		`Priority:` + valueToStringGenerated(this.Priority) + `,`,
		`Paused:` + valueToStringGenerated(this.Paused) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]ModelPipelineCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "ModelPipelineCondition", "ModelPipelineCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&ModelPipelineStatus{`,
		`LastRun:` + strings.Replace(fmt.Sprintf("%v", this.LastRun), "Time", "v1.Time", 1) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`LastUpdated:` + strings.Replace(fmt.Sprintf("%v", this.LastUpdated), "Time", "v1.Time", 1) + `,`,
		`LastError:` + fmt.Sprintf("%v", this.LastError) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelResult{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Alg:` + fmt.Sprintf("%v", this.Alg) + `,`,
		`Score:` + valueToStringGenerated(this.Score) + `,`,
		`Error:` + valueToStringGenerated(this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelSearchSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelSearchSpec{`,
		`Sampler:` + valueToStringGenerated(this.Sampler) + `,`,
		`Pruner:` + strings.Replace(this.Pruner.String(), "PrunerSpec", "PrunerSpec", 1) + `,`,
		`MaxCost:` + valueToStringGenerated(this.MaxCost) + `,`,
		`MaxTime:` + valueToStringGenerated(this.MaxTime) + `,`,
		`MaxModels:` + valueToStringGenerated(this.MaxModels) + `,`,
		`MinScore:` + valueToStringGenerated(this.MinScore) + `,`,
		`Trainers:` + valueToStringGenerated(this.Trainers) + `,`,
		`Test:` + valueToStringGenerated(this.Test) + `,`,
		`RetainTop:` + valueToStringGenerated(this.RetainTop) + `,`,
		`RetainFor:` + valueToStringGenerated(this.RetainFor) + `,`,
		`StudySchedule:` + strings.Replace(strings.Replace(this.StudySchedule.String(), "StudyScheduleSpec", "StudyScheduleSpec", 1), `&`, ``, 1) + `,`,
		`SearchSpace:` + strings.Replace(strings.Replace(this.SearchSpace.String(), "AlgorithmSearchSpaceSpec", "AlgorithmSearchSpaceSpec", 1), `&`, ``, 1) + `,`,
		`EarlyStopAfter:` + valueToStringGenerated(this.EarlyStopAfter) + `,`,
		`KeepOnlyTopModel:` + valueToStringGenerated(this.KeepOnlyTopModel) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelSpec{`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`ModelVersion:` + valueToStringGenerated(this.ModelVersion) + `,`,
		`StudyName:` + valueToStringGenerated(this.StudyName) + `,`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Task:` + valueToStringGenerated(this.Task) + `,`,
		`Objective:` + valueToStringGenerated(this.Objective) + `,`,
		`FeatureEngineering:` + strings.Replace(this.FeatureEngineering.String(), "FeatureEngineeringSpec", "FeatureEngineeringSpec", 1) + `,`,
		`Estimator:` + strings.Replace(this.Estimator.String(), "ClassicalEstimatorSpec", "ClassicalEstimatorSpec", 1) + `,`,
		`Dnn:` + strings.Replace(this.Dnn.String(), "DeepEstimatorSpec", "DeepEstimatorSpec", 1) + `,`,
		`Chatbot:` + strings.Replace(this.Chatbot.String(), "ChatbotEstimatorSpec", "ChatbotEstimatorSpec", 1) + `,`,
		`NLPEstimator:` + strings.Replace(this.NLPEstimator.String(), "NLPEstimatorSpec", "NLPEstimatorSpec", 1) + `,`,
		`Ensemble:` + strings.Replace(this.Ensemble.String(), "EnsembleSpec", "EnsembleSpec", 1) + `,`,
		`Training:` + strings.Replace(this.Training.String(), "TrainingSpec", "TrainingSpec", 1) + `,`,
		`Tested:` + valueToStringGenerated(this.Tested) + `,`,
		`Aborted:` + valueToStringGenerated(this.Aborted) + `,`,
		`Packaged:` + valueToStringGenerated(this.Packaged) + `,`,
		`Published:` + valueToStringGenerated(this.Published) + `,`,
		`Pushed:` + valueToStringGenerated(this.Pushed) + `,`,
		`Reported:` + valueToStringGenerated(this.Reported) + `,`,
		`Paused:` + valueToStringGenerated(this.Paused) + `,`,
		`Profiled:` + valueToStringGenerated(this.Profiled) + `,`,
		`Archived:` + valueToStringGenerated(this.Archived) + `,`,
		`Forecasted:` + valueToStringGenerated(this.Forecasted) + `,`,
		`Released:` + valueToStringGenerated(this.Released) + `,`,
		`Benchmarked:` + valueToStringGenerated(this.Benchmarked) + `,`,
		`Baseline:` + valueToStringGenerated(this.Baseline) + `,`,
		`Flagged:` + valueToStringGenerated(this.Flagged) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha11.DataLocation", 1) + `,`,
		`Forecasting:` + strings.Replace(this.Forecasting.String(), "ForecastSpec", "ForecastSpec", 1) + `,`,
		`Compilation:` + strings.Replace(fmt.Sprintf("%v", this.Compilation), "CompilerSpec", "v1alpha1.CompilerSpec", 1) + `,`,
		`ActiveDeadlineSeconds:` + valueToStringGenerated(this.ActiveDeadlineSeconds) + `,`,
		`EstimatorType:` + valueToStringGenerated(this.EstimatorType) + `,`,
		`TTL:` + valueToStringGenerated(this.TTL) + `,`,
		`FeatureEngineeringOnly:` + valueToStringGenerated(this.FeatureEngineeringOnly) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCV := "[]Measurement{"
	for _, f := range this.CV {
		repeatedStringForCV += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForCV += "}"
	repeatedStringForTrain := "[]Measurement{"
	for _, f := range this.Train {
		repeatedStringForTrain += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForTrain += "}"
	repeatedStringForTest := "[]Measurement{"
	for _, f := range this.Test {
		repeatedStringForTest += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForTest += "}"
	repeatedStringForImportance := "[]FeatureImportance{"
	for _, f := range this.Importance {
		repeatedStringForImportance += strings.Replace(strings.Replace(f.String(), "FeatureImportance", "FeatureImportance", 1), `&`, ``, 1) + ","
	}
	repeatedStringForImportance += "}"
	repeatedStringForConditions := "[]ModelCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "ModelCondition", "ModelCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	keysForPythonPackages := make([]string, 0, len(this.PythonPackages))
	for k := range this.PythonPackages {
		keysForPythonPackages = append(keysForPythonPackages, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPythonPackages)
	mapStringForPythonPackages := "map[string]string{"
	for _, k := range keysForPythonPackages {
		mapStringForPythonPackages += fmt.Sprintf("%v: %v,", k, this.PythonPackages[k])
	}
	mapStringForPythonPackages += "}"
	s := strings.Join([]string{`&ModelStatus{`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`TrainingStartTime:` + strings.Replace(fmt.Sprintf("%v", this.TrainingStartTime), "Time", "v1.Time", 1) + `,`,
		`TrainingEndTime:` + strings.Replace(fmt.Sprintf("%v", this.TrainingEndTime), "Time", "v1.Time", 1) + `,`,
		`TestingStartTime:` + strings.Replace(fmt.Sprintf("%v", this.TestingStartTime), "Time", "v1.Time", 1) + `,`,
		`TestingEndTime:` + strings.Replace(fmt.Sprintf("%v", this.TestingEndTime), "Time", "v1.Time", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Time", "v1.Time", 1) + `,`,
		`CVScore:` + fmt.Sprintf("%v", this.CVScore) + `,`,
		`TrainingScore:` + fmt.Sprintf("%v", this.TrainingScore) + `,`,
		`TestScore:` + fmt.Sprintf("%v", this.TestScore) + `,`,
		`Cost:` + fmt.Sprintf("%v", this.Cost) + `,`,
		`Best:` + fmt.Sprintf("%v", this.Best) + `,`,
		`CV:` + repeatedStringForCV + `,`,
		`Train:` + repeatedStringForTrain + `,`,
		`Test:` + repeatedStringForTest + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`ReportName:` + fmt.Sprintf("%v", this.ReportName) + `,`,
		`ReportUri:` + fmt.Sprintf("%v", this.ReportUri) + `,`,
		`ManifestUri:` + fmt.Sprintf("%v", this.ManifestUri) + `,`,
		`WeightsUri:` + fmt.Sprintf("%v", this.WeightsUri) + `,`,
		`LabelEncoderUri:` + fmt.Sprintf("%v", this.LabelEncoderUri) + `,`,
		`LogsUri:` + fmt.Sprintf("%v", this.LogsUri) + `,`,
		`ProfileUri:` + fmt.Sprintf("%v", this.ProfileUri) + `,`,
		`MisclassUri:` + fmt.Sprintf("%v", this.MisclassUri) + `,`,
		`TarUri:` + fmt.Sprintf("%v", this.TarUri) + `,`,
		`AppUri:` + fmt.Sprintf("%v", this.AppUri) + `,`,
		`ImageName:` + fmt.Sprintf("%v", this.ImageName) + `,`,
		`Importance:` + repeatedStringForImportance + `,`,
		`ForecastUri:` + fmt.Sprintf("%v", this.ForecastUri) + `,`,
		`PythonVersion:` + fmt.Sprintf("%v", this.PythonVersion) + `,`,
		`PythonPackages:` + mapStringForPythonPackages + `,`,
		`TrainDatasetLocation:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.TrainDatasetLocation), "DataLocation", "v1alpha11.DataLocation", 1), `&`, ``, 1) + `,`,
		`TestDatasetLocation:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.TestDatasetLocation), "DataLocation", "v1alpha11.DataLocation", 1), `&`, ``, 1) + `,`,
		`ValidationDataset:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ValidationDataset), "DataLocation", "v1alpha11.DataLocation", 1), `&`, ``, 1) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`TrainingRows:` + valueToStringGenerated(this.TrainingRows) + `,`,
		`TestingRows:` + valueToStringGenerated(this.TestingRows) + `,`,
		`ValidationRows:` + valueToStringGenerated(this.ValidationRows) + `,`,
		`LastError:` + fmt.Sprintf("%v", this.LastError) + `,`,
		`Progress:` + valueToStringGenerated(this.Progress) + `,`,
		`SizeInBytes:` + fmt.Sprintf("%v", this.SizeInBytes) + `,`,
		`Latency:` + fmt.Sprintf("%v", this.Latency) + `,`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`PredictorName:` + fmt.Sprintf("%v", this.PredictorName) + `,`,
		`ReleasedAt:` + strings.Replace(fmt.Sprintf("%v", this.ReleasedAt), "Time", "v1.Time", 1) + `,`,
		`TarFileHash:` + fmt.Sprintf("%v", this.TarFileHash) + `,`,
		`ImageHash:` + fmt.Sprintf("%v", this.ImageHash) + `,`,
		`TrainingDataHash:` + strings.Replace(strings.Replace(this.TrainingDataHash.String(), "DataHashes", "DataHashes", 1), `&`, ``, 1) + `,`,
		`TrainingResources:` + strings.Replace(strings.Replace(this.TrainingResources.String(), "ResourceConsumption", "ResourceConsumption", 1), `&`, ``, 1) + `,`,
		`TestingResources:` + strings.Replace(strings.Replace(this.TestingResources.String(), "ResourceConsumption", "ResourceConsumption", 1), `&`, ``, 1) + `,`,
		`TrainedBy:` + fmt.Sprintf("%v", this.TrainedBy) + `,`,
		`Team:` + fmt.Sprintf("%v", this.Team) + `,`,
		`TrainerImage:` + fmt.Sprintf("%v", this.TrainerImage) + `,`,
		`EndPoint:` + fmt.Sprintf("%v", this.EndPoint) + `,`,
		`Logs:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Logs), "Logs", "v1alpha1.Logs", 1), `&`, ``, 1) + `,`,
		`TrialID:` + valueToStringGenerated(this.TrialID) + `,`,
		`RocAucCurve:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.RocAucCurve), "RocAucCurve", "v1alpha1.RocAucCurve", 1), `&`, ``, 1) + `,`,
		`PRCurve:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.PRCurve), "PRCurve", "v1alpha1.PRCurve", 1), `&`, ``, 1) + `,`,
		`ConfusionMatrix:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ConfusionMatrix), "ConfusionMatrix", "v1alpha1.ConfusionMatrix", 1), `&`, ``, 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelValidation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelValidation{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`PrevModel:` + valueToStringGenerated(this.PrevModel) + `,`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`DriftFreq:` + fmt.Sprintf("%v", this.DriftFreq) + `,`,
		`DriftInterval:` + valueToStringGenerated(this.DriftInterval) + `,`,
		`Column:` + valueToStringGenerated(this.Column) + `,`,
		`Metric:` + valueToStringGenerated(this.Metric) + `,`,
		`Min:` + valueToStringGenerated(this.Min) + `,`,
		`Max:` + valueToStringGenerated(this.Max) + `,`,
		`MinPrecent:` + valueToStringGenerated(this.MinPrecent) + `,`,
		`MaxPrecent:` + valueToStringGenerated(this.MaxPrecent) + `,`,
		`Agg:` + valueToStringGenerated(this.Agg) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelValidationResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelValidationResult{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`DatasetName:` + fmt.Sprintf("%v", this.DatasetName) + `,`,
		`ModelName:` + fmt.Sprintf("%v", this.ModelName) + `,`,
		`Column:` + fmt.Sprintf("%v", this.Column) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`Metric:` + valueToStringGenerated(this.Metric) + `,`,
		`ActualValue:` + valueToStringGenerated(this.ActualValue) + `,`,
		`Passed:` + fmt.Sprintf("%v", this.Passed) + `,`,
		`At:` + strings.Replace(fmt.Sprintf("%v", this.At), "Time", "v1.Time", 1) + `,`,
		`DurationInSec:` + fmt.Sprintf("%v", this.DurationInSec) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NLPEstimatorSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NLPEstimatorSpec{`,
		`Base:` + valueToStringGenerated(this.Base) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NNLayerParameter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NNLayerParameter{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Notebook) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Notebook{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "NotebookSpec", "NotebookSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "NotebookStatus", "NotebookStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NotebookCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]Notebook{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "Notebook", "Notebook", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&NotebookList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookRun) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NotebookRun{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "NotebookRunSpec", "NotebookRunSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "NotebookRunStatus", "NotebookRunStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookRunCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NotebookRunCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookRunList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]NotebookRun{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "NotebookRun", "NotebookRun", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&NotebookRunList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookRunSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValues := "[]NotebookVarValue{"
	for _, f := range this.Values {
		repeatedStringForValues += strings.Replace(strings.Replace(f.String(), "NotebookVarValue", "NotebookVarValue", 1), `&`, ``, 1) + ","
	}
	repeatedStringForValues += "}"
	s := strings.Join([]string{`&NotebookRunSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`NotebookName:` + valueToStringGenerated(this.NotebookName) + `,`,
		`Values:` + repeatedStringForValues + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`TTL:` + valueToStringGenerated(this.TTL) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookRunStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]NotebookRunCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "NotebookRunCondition", "NotebookRunCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&NotebookRunStatus{`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Time", "v1.Time", 1) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`LastError:` + fmt.Sprintf("%v", this.LastError) + `,`,
		`TriggeredBy:` + fmt.Sprintf("%v", this.TriggeredBy) + `,`,
		`Logs:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Logs), "Logs", "v1alpha1.Logs", 1), `&`, ``, 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NotebookSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`SchemaRef:` + strings.Replace(fmt.Sprintf("%v", this.SchemaRef), "ObjectReference", "v11.ObjectReference", 1) + `,`,
		`ImageName:` + valueToStringGenerated(this.ImageName) + `,`,
		`Requirements:` + valueToStringGenerated(this.Requirements) + `,`,
		`DebPackages:` + valueToStringGenerated(this.DebPackages) + `,`,
		`Vars:` + fmt.Sprintf("%v", this.Vars) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha11.DataLocation", 1) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`ActiveDeadlineSeconds:` + valueToStringGenerated(this.ActiveDeadlineSeconds) + `,`,
		`Schedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Schedule), "RunSchedule", "v1alpha1.RunSchedule", 1), `&`, ``, 1) + `,`,
		`Priority:` + valueToStringGenerated(this.Priority) + `,`,
		`Paused:` + valueToStringGenerated(this.Paused) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]NotebookCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "NotebookCondition", "NotebookCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&NotebookStatus{`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`URI:` + fmt.Sprintf("%v", this.URI) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`LastRun:` + strings.Replace(fmt.Sprintf("%v", this.LastRun), "Time", "v1.Time", 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookVarValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NotebookVarValue{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PeriodSeasonalitySpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PeriodSeasonalitySpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`Periods:` + valueToStringGenerated(this.Periods) + `,`,
		`Mode:` + valueToStringGenerated(this.Mode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PeriodSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PeriodSpec{`,
		`Interval:` + valueToStringGenerated(this.Interval) + `,`,
		`Start:` + valueToStringGenerated(this.Start) + `,`,
		`End:` + valueToStringGenerated(this.End) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrunerSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrunerSpec{`,
		`Type:` + valueToStringGenerated(this.Type) + `,`,
		`StartupTrials:` + valueToStringGenerated(this.StartupTrials) + `,`,
		`WramupTrials:` + valueToStringGenerated(this.WramupTrials) + `,`,
		`MinimumTrials:` + valueToStringGenerated(this.MinimumTrials) + `,`,
		`IntervalSteps:` + valueToStringGenerated(this.IntervalSteps) + `,`,
		`Precentile:` + valueToStringGenerated(this.Precentile) + `,`,
		`Lower:` + valueToStringGenerated(this.Lower) + `,`,
		`Upper:` + valueToStringGenerated(this.Upper) + `,`,
		`SHOptions:` + strings.Replace(this.SHOptions.String(), "SuccessiveHalvingOptions", "SuccessiveHalvingOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegressorSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegressorSpec{`,
		`Name:` + valueToStringGenerated(this.Name) + `,`,
		`PriorScale:` + valueToStringGenerated(this.PriorScale) + `,`,
		`Standardize:` + valueToStringGenerated(this.Standardize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReleaseStageSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValidations := "[]ModelValidation{"
	for _, f := range this.Validations {
		repeatedStringForValidations += strings.Replace(strings.Replace(f.String(), "ModelValidation", "ModelValidation", 1), `&`, ``, 1) + ","
	}
	repeatedStringForValidations += "}"
	s := strings.Join([]string{`&ReleaseStageSpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`ServingSiteName:` + valueToStringGenerated(this.ServingSiteName) + `,`,
		`PredictorName:` + valueToStringGenerated(this.PredictorName) + `,`,
		`Template:` + strings.Replace(fmt.Sprintf("%v", this.Template), "ModelDeploymentSpec", "v1alpha1.ModelDeploymentSpec", 1) + `,`,
		`ManualApproval:` + valueToStringGenerated(this.ManualApproval) + `,`,
		`Validations:` + repeatedStringForValidations + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Report) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Report{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "ReportSpec", "ReportSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "ReportStatus", "ReportStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReportCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReportCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReportList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]Report{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "Report", "Report", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ReportList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReportSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReportSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`EntityRef:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.EntityRef), "ObjectReference", "v11.ObjectReference", 1), `&`, ``, 1) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha11.DataLocation", 1) + `,`,
		`ReportType:` + valueToStringGenerated(this.ReportType) + `,`,
		`Format:` + valueToStringGenerated(this.Format) + `,`,
		`NotifierName:` + valueToStringGenerated(this.NotifierName) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`ActiveDeadlineSeconds:` + valueToStringGenerated(this.ActiveDeadlineSeconds) + `,`,
		`Custom:` + strings.Replace(this.Custom.String(), "CustomReportSpec", "CustomReportSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReportStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]ReportCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "ReportCondition", "ReportCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&ReportStatus{`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Time", "v1.Time", 1) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`URI:` + fmt.Sprintf("%v", this.URI) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`LastError:` + fmt.Sprintf("%v", this.LastError) + `,`,
		`Logs:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Logs), "Logs", "v1alpha1.Logs", 1), `&`, ``, 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReportTemplate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReportTemplate{`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "ReportSpec", "ReportSpec", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceConsumption) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceConsumption{`,
		`Cpu:` + fmt.Sprintf("%v", this.Cpu) + `,`,
		`Mem:` + fmt.Sprintf("%v", this.Mem) + `,`,
		`Gpu:` + fmt.Sprintf("%v", this.Gpu) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Study) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Study{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "StudySpec", "StudySpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "StudyStatus", "StudyStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StudyCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StudyCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StudyForecastSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StudyForecastSpec{`,
		`Hierarchy:` + strings.Replace(this.Hierarchy.String(), "Hierarchy", "Hierarchy", 1) + `,`,
		`ForecastTemplate:` + strings.Replace(this.ForecastTemplate.String(), "ForecastSpec", "ForecastSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StudyList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]Study{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "Study", "Study", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&StudyList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *StudyScheduleSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StudyScheduleSpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`StartAt:` + strings.Replace(fmt.Sprintf("%v", this.StartAt), "Time", "v1.Time", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StudySpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StudySpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`LabRef:` + strings.Replace(fmt.Sprintf("%v", this.LabRef), "ObjectReference", "v11.ObjectReference", 1) + `,`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Task:` + valueToStringGenerated(this.Task) + `,`,
		`Objective:` + valueToStringGenerated(this.Objective) + `,`,
		`Objective2:` + valueToStringGenerated(this.Objective2) + `,`,
		`Search:` + strings.Replace(this.Search.String(), "ModelSearchSpec", "ModelSearchSpec", 1) + `,`,
		`FeatureEngineering:` + strings.Replace(this.FeatureEngineering.String(), "FeatureEngineeringSpec", "FeatureEngineeringSpec", 1) + `,`,
		`TrainingTemplate:` + strings.Replace(this.TrainingTemplate.String(), "TrainingSpec", "TrainingSpec", 1) + `,`,
		`Split:` + strings.Replace(this.Split.String(), "DataSplit", "DataSplit", 1) + `,`,
		`Aborted:` + valueToStringGenerated(this.Aborted) + `,`,
		`FeatureEngineered:` + valueToStringGenerated(this.FeatureEngineered) + `,`,
		`Reported:` + valueToStringGenerated(this.Reported) + `,`,
		`Paused:` + valueToStringGenerated(this.Paused) + `,`,
		`Profiled:` + valueToStringGenerated(this.Profiled) + `,`,
		`ModelPublished:` + valueToStringGenerated(this.ModelPublished) + `,`,
		`ModelImagePushed:` + valueToStringGenerated(this.ModelImagePushed) + `,`,
		`ModelBenchmarked:` + valueToStringGenerated(this.ModelBenchmarked) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha11.DataLocation", 1) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`ActiveDeadlineSeconds:` + valueToStringGenerated(this.ActiveDeadlineSeconds) + `,`,
		`Compilation:` + strings.Replace(fmt.Sprintf("%v", this.Compilation), "CompilerSpec", "v1alpha1.CompilerSpec", 1) + `,`,
		`Template:` + valueToStringGenerated(this.Template) + `,`,
		`Flagged:` + valueToStringGenerated(this.Flagged) + `,`,
		`Notification:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Notification), "NotificationSpec", "v1alpha1.NotificationSpec", 1), `&`, ``, 1) + `,`,
		`ModelImage:` + strings.Replace(strings.Replace(this.ModelImage.String(), "ModelImageSpec", "ModelImageSpec", 1), `&`, ``, 1) + `,`,
		`TTL:` + valueToStringGenerated(this.TTL) + `,`,
		`ForecastSpec:` + strings.Replace(strings.Replace(this.ForecastSpec.String(), "StudyForecastSpec", "StudyForecastSpec", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StudyStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]StudyCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "StudyCondition", "StudyCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&StudyStatus{`,
		`Models:` + fmt.Sprintf("%v", this.Models) + `,`,
		`FeatureEngineeringModelWaiting:` + fmt.Sprintf("%v", this.FeatureEngineeringModelWaiting) + `,`,
		`FeatureEngineeringModelTraining:` + fmt.Sprintf("%v", this.FeatureEngineeringModelTraining) + `,`,
		`FeatureEngineeringModeFailed:` + fmt.Sprintf("%v", this.FeatureEngineeringModeFailed) + `,`,
		`FeatureEngineeringModelTrained:` + fmt.Sprintf("%v", this.FeatureEngineeringModelTrained) + `,`,
		`SearchingModelWaiting:` + fmt.Sprintf("%v", this.SearchingModelWaiting) + `,`,
		`SearchingModelsTraining:` + fmt.Sprintf("%v", this.SearchingModelsTraining) + `,`,
		`SearchingModeFailed:` + fmt.Sprintf("%v", this.SearchingModeFailed) + `,`,
		`SearchingModeTrained:` + fmt.Sprintf("%v", this.SearchingModeTrained) + `,`,
		`TestingModelWaiting:` + fmt.Sprintf("%v", this.TestingModelWaiting) + `,`,
		`TestingModels:` + fmt.Sprintf("%v", this.TestingModels) + `,`,
		`TestingModeFailed:` + fmt.Sprintf("%v", this.TestingModeFailed) + `,`,
		`TestedModels:` + fmt.Sprintf("%v", this.TestedModels) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`FeatureEngineeringStartTime:` + strings.Replace(fmt.Sprintf("%v", this.FeatureEngineeringStartTime), "Time", "v1.Time", 1) + `,`,
		`FeatureEngineerinEndTime:` + strings.Replace(fmt.Sprintf("%v", this.FeatureEngineerinEndTime), "Time", "v1.Time", 1) + `,`,
		`SearchingStartTime:` + strings.Replace(fmt.Sprintf("%v", this.SearchingStartTime), "Time", "v1.Time", 1) + `,`,
		`SearchingEndTime:` + strings.Replace(fmt.Sprintf("%v", this.SearchingEndTime), "Time", "v1.Time", 1) + `,`,
		`TestingStartTime:` + strings.Replace(fmt.Sprintf("%v", this.TestingStartTime), "Time", "v1.Time", 1) + `,`,
		`TestingEndTime:` + strings.Replace(fmt.Sprintf("%v", this.TestingEndTime), "Time", "v1.Time", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Time", "v1.Time", 1) + `,`,
		`BestModel:` + fmt.Sprintf("%v", this.BestModel) + `,`,
		`BestModelScore:` + fmt.Sprintf("%v", this.BestModelScore) + `,`,
		`ProfileUri:` + fmt.Sprintf("%v", this.ProfileUri) + `,`,
		`ReportName:` + fmt.Sprintf("%v", this.ReportName) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`TrainDatasetLocation:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.TrainDatasetLocation), "DataLocation", "v1alpha11.DataLocation", 1), `&`, ``, 1) + `,`,
		`TestDatasetLocation:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.TestDatasetLocation), "DataLocation", "v1alpha11.DataLocation", 1), `&`, ``, 1) + `,`,
		`ValidationDataset:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ValidationDataset), "DataLocation", "v1alpha11.DataLocation", 1), `&`, ``, 1) + `,`,
		`LastModelID:` + valueToStringGenerated(this.LastModelID) + `,`,
		`LastError:` + valueToStringGenerated(this.LastError) + `,`,
		`TrainingRows:` + valueToStringGenerated(this.TrainingRows) + `,`,
		`TestingRows:` + valueToStringGenerated(this.TestingRows) + `,`,
		`ValidationRows:` + valueToStringGenerated(this.ValidationRows) + `,`,
		`Progress:` + valueToStringGenerated(this.Progress) + `,`,
		`BaslineModel:` + valueToStringGenerated(this.BaslineModel) + `,`,
		`TrainingDataHash:` + strings.Replace(strings.Replace(this.TrainingDataHash.String(), "DataHashes", "DataHashes", 1), `&`, ``, 1) + `,`,
		`TriggeredBy:` + fmt.Sprintf("%v", this.TriggeredBy) + `,`,
		`Logs:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Logs), "Logs", "v1alpha1.Logs", 1), `&`, ``, 1) + `,`,
		`FeatureEngineeringStatus:` + strings.Replace(strings.Replace(this.FeatureEngineeringStatus.String(), "FeatureEngineeringStatus", "FeatureEngineeringStatus", 1), `&`, ``, 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuccessiveHalvingOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SuccessiveHalvingOptions{`,
		`MaxBudget:` + valueToStringGenerated(this.MaxBudget) + `,`,
		`EliminationRate:` + valueToStringGenerated(this.EliminationRate) + `,`,
		`Modality:` + valueToStringGenerated(this.Modality) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuccessiveHalvingSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SuccessiveHalvingSpec{`,
		`Budget:` + valueToStringGenerated(this.Budget) + `,`,
		`Bracket:` + valueToStringGenerated(this.Bracket) + `,`,
		`Rung:` + valueToStringGenerated(this.Rung) + `,`,
		`ConfID:` + valueToStringGenerated(this.ConfID) + `,`,
		`Modality:` + valueToStringGenerated(this.Modality) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TextPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TextPipelineSpec{`,
		`Encoder:` + valueToStringGenerated(this.Encoder) + `,`,
		`Tokenizer:` + valueToStringGenerated(this.Tokenizer) + `,`,
		`StopWords:` + valueToStringGenerated(this.StopWords) + `,`,
		`Pos:` + valueToStringGenerated(this.Pos) + `,`,
		`Lemma:` + valueToStringGenerated(this.Lemma) + `,`,
		`Stem:` + valueToStringGenerated(this.Stem) + `,`,
		`Embedding:` + valueToStringGenerated(this.Embedding) + `,`,
		`Svd:` + valueToStringGenerated(this.Svd) + `,`,
		`MaxSvdComponents:` + valueToStringGenerated(this.MaxSvdComponents) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimeSeriesDataSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRegressors := "[]RegressorSpec{"
	for _, f := range this.Regressors {
		repeatedStringForRegressors += strings.Replace(strings.Replace(f.String(), "RegressorSpec", "RegressorSpec", 1), `&`, ``, 1) + ","
	}
	repeatedStringForRegressors += "}"
	repeatedStringForCustomSeasonalities := "[]CustomSeasonalitySpec{"
	for _, f := range this.CustomSeasonalities {
		repeatedStringForCustomSeasonalities += strings.Replace(strings.Replace(f.String(), "CustomSeasonalitySpec", "CustomSeasonalitySpec", 1), `&`, ``, 1) + ","
	}
	repeatedStringForCustomSeasonalities += "}"
	s := strings.Join([]string{`&TimeSeriesDataSpec{`,
		`TimeColumn:` + valueToStringGenerated(this.TimeColumn) + `,`,
		`TargetColumn:` + valueToStringGenerated(this.TargetColumn) + `,`,
		`DateTimeFormat:` + valueToStringGenerated(this.DateTimeFormat) + `,`,
		`Holiday:` + strings.Replace(strings.Replace(this.Holiday.String(), "HolidaySpec", "HolidaySpec", 1), `&`, ``, 1) + `,`,
		`GroupColumn:` + valueToStringGenerated(this.GroupColumn) + `,`,
		`SubGroupColumn:` + valueToStringGenerated(this.SubGroupColumn) + `,`,
		`SubSubGroupColumn:` + valueToStringGenerated(this.SubSubGroupColumn) + `,`,
		`History:` + strings.Replace(this.History.String(), "PeriodSpec", "PeriodSpec", 1) + `,`,
		`Forecast:` + strings.Replace(this.Forecast.String(), "PeriodSpec", "PeriodSpec", 1) + `,`,
		`YearlySeasonality:` + strings.Replace(strings.Replace(this.YearlySeasonality.String(), "PeriodSeasonalitySpec", "PeriodSeasonalitySpec", 1), `&`, ``, 1) + `,`,
		`WeeklySeasonality:` + strings.Replace(strings.Replace(this.WeeklySeasonality.String(), "PeriodSeasonalitySpec", "PeriodSeasonalitySpec", 1), `&`, ``, 1) + `,`,
		`DailySeasonality:` + strings.Replace(strings.Replace(this.DailySeasonality.String(), "PeriodSeasonalitySpec", "PeriodSeasonalitySpec", 1), `&`, ``, 1) + `,`,
		`Growth:` + valueToStringGenerated(this.Growth) + `,`,
		`Regressors:` + repeatedStringForRegressors + `,`,
		`CustomSeasonalities:` + repeatedStringForCustomSeasonalities + `,`,
		`ChangePoints:` + strings.Replace(strings.Replace(this.ChangePoints.String(), "ChangePointSpec", "ChangePointSpec", 1), `&`, ``, 1) + `,`,
		`IntervalWidth:` + valueToStringGenerated(this.IntervalWidth) + `,`,
		`UncertaintySamples:` + valueToStringGenerated(this.UncertaintySamples) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrainingSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrainingSpec{`,
		`Priority:` + valueToStringGenerated(this.Priority) + `,`,
		`CvType:` + valueToStringGenerated(this.CvType) + `,`,
		`CV:` + valueToStringGenerated(this.CV) + `,`,
		`Folds:` + valueToStringGenerated(this.Folds) + `,`,
		`EvalMetrics:` + fmt.Sprintf("%v", this.EvalMetrics) + `,`,
		`EarlyStop:` + valueToStringGenerated(this.EarlyStop) + `,`,
		`CheckpointInterval:` + valueToStringGenerated(this.CheckpointInterval) + `,`,
		`SH:` + strings.Replace(this.SH.String(), "SuccessiveHalvingSpec", "SuccessiveHalvingSpec", 1) + `,`,
		`Seed:` + valueToStringGenerated(this.Seed) + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`Gpu:` + valueToStringGenerated(this.Gpu) + `,`,
		`Dist:` + valueToStringGenerated(this.Dist) + `,`,
		`NodeCount:` + valueToStringGenerated(this.NodeCount) + `,`,
		`Sample:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Sample), "SampleSpec", "v1alpha11.SampleSpec", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrainingStageSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValidations := "[]ModelValidation{"
	for _, f := range this.Validations {
		repeatedStringForValidations += strings.Replace(strings.Replace(f.String(), "ModelValidation", "ModelValidation", 1), `&`, ``, 1) + ","
	}
	repeatedStringForValidations += "}"
	s := strings.Join([]string{`&TrainingStageSpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`NotebookName:` + valueToStringGenerated(this.NotebookName) + `,`,
		`LabName:` + valueToStringGenerated(this.LabName) + `,`,
		`StudyTemplateName:` + valueToStringGenerated(this.StudyTemplateName) + `,`,
		`Validations:` + repeatedStringForValidations + `,`,
		`}`,
	}, "")
	return s
}
func (this *UATStageSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValidations := "[]ModelValidation{"
	for _, f := range this.Validations {
		repeatedStringForValidations += strings.Replace(strings.Replace(f.String(), "ModelValidation", "ModelValidation", 1), `&`, ``, 1) + ","
	}
	repeatedStringForValidations += "}"
	s := strings.Join([]string{`&UATStageSpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`ServingSiteName:` + valueToStringGenerated(this.ServingSiteName) + `,`,
		`Validations:` + repeatedStringForValidations + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VideoPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoPipelineSpec{`,
		`Featurizer:` + valueToStringGenerated(this.Featurizer) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGenerated(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AlgorithmSearchSpaceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlgorithmSearchSpaceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlgorithmSearchSpaceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowList = append(m.AllowList, github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.ClassicEstimatorName(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingEnsemble", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.VotingEnsemble = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StackingEnsemble", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.StackingEnsemble = &b
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgorithmFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := AlgorithmFilterName(dAtA[iNdEx:postIndex])
			m.AlgorithmFilter = &s
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baselines", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Baselines = append(m.Baselines, github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.ClassicEstimatorName(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TestAll = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudioPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Featurizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.AudioFeaturizer(dAtA[iNdEx:postIndex])
			m.Featurizer = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BacktestSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BacktestSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BacktestSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sliding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Sliding = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingWindowSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrainingWindowSize = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForecastingWindowSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForecastingWindowSize = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlidingSteps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SlidingSteps = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapacityStageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CapacityStageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CapacityStageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServingSiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServingSiteName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validations = append(m.Validations, ModelValidation{})
			if err := m.Validations[len(m.Validations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePointSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePointSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePointSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.N = &v
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Range = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatbotEstimatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatbotEstimatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatbotEstimatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Base = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassicalEstimatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassicalEstimatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassicalEstimatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgorithmName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlgorithmName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, HyperParameterValue{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronReportCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronReportCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronReportCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = CronReportConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronReportList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronReportList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronReportList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, CronReport{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronReportSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronReportSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronReportSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := ReportRange(dAtA[iNdEx:postIndex])
			m.Range = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Template.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Paused = &b
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Notification.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronReportStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronReportStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronReportStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRun", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastRun == nil {
				m.LastRun = &v1.Time{}
			}
			if err := m.LastRun.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdated == nil {
				m.LastUpdated = &v1.Time{}
			}
			if err := m.LastUpdated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, CronReportCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomReportBarChart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomReportBarChart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomReportBarChart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.X = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Y = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Legend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Legend = &b
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Sort = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomReportHistogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomReportHistogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomReportHistogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.X = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bins", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bins = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomReportLineChart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomReportLineChart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomReportLineChart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.X = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Y = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Legend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Legend = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomReportScatterPlot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomReportScatterPlot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomReportScatterPlot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.X = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Y = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomReportSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomReportSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomReportSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, CustomReportValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, CustomReportTable{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineCharts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LineCharts = append(m.LineCharts, CustomReportLineChart{})
			if err := m.LineCharts[len(m.LineCharts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BarCharts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BarCharts = append(m.BarCharts, CustomReportBarChart{})
			if err := m.BarCharts[len(m.BarCharts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistCharts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistCharts = append(m.HistCharts, CustomReportHistogram{})
			if err := m.HistCharts[len(m.HistCharts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScatterCharts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScatterCharts = append(m.ScatterCharts, CustomReportHistogram{})
			if err := m.ScatterCharts[len(m.ScatterCharts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomReportTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomReportTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomReportTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rows = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ShowIndex = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Border", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Border = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomReportValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomReportValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomReportValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Column = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Row", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Row = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scalar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Scalar = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomSeasonalitySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomSeasonalitySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomSeasonalitySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Period = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FourierOrder", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FourierOrder = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataHashes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataHashes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataHashes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TrainingHash = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TestingHash = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ValidationHash = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSplit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSplit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSplit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Auto = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Train", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Train = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validation", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Validation = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Test", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Test = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.SplitType(dAtA[iNdEx:postIndex])
			m.SplitPolicy = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SplitColumn = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Seed = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataStageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataStageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataStageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LabName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPipelineName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DataPipelineName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasourceName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DockerImage = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeepEstimatorLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeepEstimatorLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeepEstimatorLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = NNLayerName(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, NNLayerParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputLayers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputLayers = append(m.InputLayers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeepEstimatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeepEstimatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeepEstimatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layers = append(m.Layers, DeepEstimatorLayer{})
			if err := m.Layers[len(m.Layers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := DNNTypeName(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BatchSize = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epochs", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Epochs = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationSplit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidationSplit = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Seq = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpus", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gpus = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loss", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Loss = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentStageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentStageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentStageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServingSiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServingSiteName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualApproval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ManualApproval = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validations = append(m.Validations, ModelValidation{})
			if err := m.Validations[len(m.Validations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnsembleRules) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnsembleRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnsembleRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnsembleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnsembleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnsembleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Base = append(m.Base, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureEngineeringPipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureEngineeringPipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureEngineeringPipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataType = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.DataType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imputation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Imputation(dAtA[iNdEx:postIndex])
			m.Imputation = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.CategoricalEncoding(dAtA[iNdEx:postIndex])
			m.Encoding = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scaling", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Scaling(dAtA[iNdEx:postIndex])
			m.Scaling = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discretisation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Discretisation(dAtA[iNdEx:postIndex])
			m.Discretisation = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariableTransformation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.VariableTransformation(dAtA[iNdEx:postIndex])
			m.VariableTransformation = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutlierHandling", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.OutlierHandling(dAtA[iNdEx:postIndex])
			m.OutlierHandling = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatetimeTransformation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.DatatimeTransformation(dAtA[iNdEx:postIndex])
			m.DatetimeTransformation = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Text == nil {
				m.Text = &TextPipelineSpec{}
			}
			if err := m.Text.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &ImagePipelineSpec{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Audio == nil {
				m.Audio = &AudioPipelineSpec{}
			}
			if err := m.Audio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &VideoPipelineSpec{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genereted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Genereted = append(m.Genereted, GeneratedColumnSpec{})
			if err := m.Genereted[len(m.Genereted)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Custom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Custom = append(m.Custom, GeneratedColumnSpec{})
			if err := m.Custom[len(m.Custom)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Drop = &b
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passtrough", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Passtrough = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureEngineeringSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureEngineeringSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureEngineeringSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipelines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pipelines = append(m.Pipelines, FeatureEngineeringPipeline{})
			if err := m.Pipelines[len(m.Pipelines)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureSelection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeatureSelection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Estimator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.ClassicEstimatorName(dAtA[iNdEx:postIndex])
			m.Estimator = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxModels", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxModels = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimeSec", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxTimeSec = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTrainers", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxTrainers = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplePct", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SamplePct = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureEngineeringStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureEngineeringStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureEngineeringStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestPipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BestPipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureImportance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureImportance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureImportance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Feature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Importance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Importance = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureSelectionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureSelectionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureSelectionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VarianceTresholdPct", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VarianceTresholdPct = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrTreshold", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CorrTreshold = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopN", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TopN = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeImportancePrecent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CumulativeImportancePrecent = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserved = append(m.Reserved, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForecastObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForecastObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForecastObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelIndex", wireType)
			}
			m.LevelIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LevelIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForecastPostProcessingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForecastPostProcessingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForecastPostProcessingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ConnectionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forecast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Forecast = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForecastSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForecastSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForecastSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfidenceInterval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConfidenceInterval = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backtest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Backtest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostPrecessing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PostPrecessing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Plot = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlotChangePoints", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PlotChangePoints = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FormatSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FormatSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FormatSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneratedColumnSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneratedColumnSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneratedColumnSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataType = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.DataType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.First = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Second", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Second = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Hierarchy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hierarchy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hierarchy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupLevels = append(m.GroupLevels, Level{})
			if err := m.GroupLevels[len(m.GroupLevels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemLevel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemLevel == nil {
				m.ItemLevel = &Level{}
			}
			if err := m.ItemLevel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NotifierName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HolidaySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HolidaySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HolidaySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HolidayColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HolidayColumn = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.HolidayCountry(dAtA[iNdEx:postIndex])
			m.Country = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HyperParameterValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HyperParameterValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HyperParameterValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImagePipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImagePipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImagePipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Featurizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.ImageFeaturizer(dAtA[iNdEx:postIndex])
			m.Featurizer = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Level) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Level: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Level: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Horizon", wireType)
			}
			m.Horizon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Horizon |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Freq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Freq(dAtA[iNdEx:postIndex])
			m.Freq = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Aggregate(dAtA[iNdEx:postIndex])
			m.Aggregate = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelAutobuilder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelAutobuilder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelAutobuilder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelAutobuilderCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelAutobuilderCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelAutobuilderCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = ModelAutobuilderConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelAutobuilderList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelAutobuilderList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelAutobuilderList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, ModelAutobuilder{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelAutobuilderSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelAutobuilderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelAutobuilderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DataProductName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProductVersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DataProductVersionName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DataSourceName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha11.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.MLTask(dAtA[iNdEx:postIndex])
			m.Task = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objective", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex])
			m.Objective = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TargetColumn = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxTime = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxModels", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxModels = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.AccessType(dAtA[iNdEx:postIndex])
			m.AccessMethod = &s
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoScale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AutoScale = &b
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataSourceSpec == nil {
				m.DataSourceSpec = &v1alpha11.DataSourceSpec{}
			}
			if err := m.DataSourceSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trainers", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Trainers = &v
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sampler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := SamplerName(dAtA[iNdEx:postIndex])
			m.Sampler = &s
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aborted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Aborted = &b
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Workload = &s
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabRef == nil {
				m.LabRef = &v11.ObjectReference{}
			}
			if err := m.LabRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelAutobuilderStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelAutobuilderStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelAutobuilderStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlatFileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlatFileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataSourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BestModelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredictorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageRepoName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageRepoName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = ModelAutobuilderPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Models", wireType)
			}
			m.Models = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Models |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainedModels", wireType)
			}
			m.TrainedModels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainedModels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestModelScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BestModelScore = float64(math.Float64frombits(v))
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Estimator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Estimator == nil {
				m.Estimator = &ClassicalEstimatorSpec{}
			}
			if err := m.Estimator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &v1.Time{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, ModelAutobuilderCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelCompilerRun) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelCompilerRun: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelCompilerRun: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelCompilerRunCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelCompilerRunCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelCompilerRunCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = ModelCompilerRunConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelCompilerRunList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelCompilerRunList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelCompilerRunList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, ModelCompilerRun{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelCompilerRunSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelCompilerRunSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelCompilerRunSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.PriorityLevel(dAtA[iNdEx:postIndex])
			m.Priority = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compiler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.CompilerName(dAtA[iNdEx:postIndex])
			m.Compiler = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.HardwareTarget(dAtA[iNdEx:postIndex])
			m.Target = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelCompilerRunStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelCompilerRunStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelCompilerRunStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletionTime == nil {
				m.CompletionTime = &v1.Time{}
			}
			if err := m.CompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = CompilerPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Folder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Folder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Progress = &v
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, ModelCompilerRunCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = ModelConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelImageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelImageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelImageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Exist = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ImageName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistryConnection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RegistryConnection = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Model{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = ModelPipelineConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, ModelPipeline{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineRun) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineRun: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineRun: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineRunCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineRunCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineRunCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = PipelineRunConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineRunList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineRunList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineRunList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, ModelPipelineRun{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineRunSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineRunSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineRunSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dataset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Dataset = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PipelineName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.PriorityLevel(dAtA[iNdEx:postIndex])
			m.Priority = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Paused = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aborted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Aborted = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TTL = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineRunStageStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineRunStageStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineRunStageStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = StageStatusPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Approved = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovedAt == nil {
				m.ApprovedAt = &v1.Time{}
			}
			if err := m.ApprovedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &v1.Time{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, ModelValidationResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineRunStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineRunStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineRunStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stage = ModelPipelineStage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DataStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TrainingStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UATStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UATStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacityStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CapacityStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeploymentStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReleaseStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitoringStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MonitoringStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelingStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LabelingStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletionTime == nil {
				m.CompletionTime = &v1.Time{}
			}
			if err := m.CompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = PipelinePhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Folder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Folder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Progress = &v
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggeredBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggeredBy = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.TriggerType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, ModelPipelineRunCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatasetSelector == nil {
				m.DatasetSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DatasetSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &DataStageSpec{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Training", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Training == nil {
				m.Training = &TrainingStageSpec{}
			}
			if err := m.Training.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UAT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UAT == nil {
				m.UAT = &UATStageSpec{}
			}
			if err := m.UAT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capacity == nil {
				m.Capacity = &CapacityStageSpec{}
			}
			if err := m.Capacity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deployment == nil {
				m.Deployment = &DeploymentStageSpec{}
			}
			if err := m.Deployment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Release", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Release == nil {
				m.Release = &ReleaseStageSpec{}
			}
			if err := m.Release.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha11.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproverAccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ApproverAccountName = &s
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Notification.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaselineModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BaselineModelName = &s
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.PriorityLevel(dAtA[iNdEx:postIndex])
			m.Priority = &s
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Paused = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRun", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastRun == nil {
				m.LastRun = &v1.Time{}
			}
			if err := m.LastRun.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdated == nil {
				m.LastUpdated = &v1.Time{}
			}
			if err := m.LastUpdated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, ModelPipelineCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Score = &v2
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Error = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelSearchSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelSearchSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelSearchSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sampler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := SamplerName(dAtA[iNdEx:postIndex])
			m.Sampler = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pruner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pruner == nil {
				m.Pruner = &PrunerSpec{}
			}
			if err := m.Pruner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCost", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxCost = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxTime = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxModels", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxModels = &v
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.MinScore = &v2
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trainers", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Trainers = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Test", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Test = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetainTop", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetainTop = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetainFor", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetainFor = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudySchedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StudySchedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchSpace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SearchSpace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarlyStopAfter", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EarlyStopAfter = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepOnlyTopModel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.KeepOnlyTopModel = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelVersion = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.StudyName = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.MLTask(dAtA[iNdEx:postIndex])
			m.Task = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objective", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex])
			m.Objective = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureEngineering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeatureEngineering == nil {
				m.FeatureEngineering = &FeatureEngineeringSpec{}
			}
			if err := m.FeatureEngineering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Estimator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Estimator == nil {
				m.Estimator = &ClassicalEstimatorSpec{}
			}
			if err := m.Estimator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dnn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dnn == nil {
				m.Dnn = &DeepEstimatorSpec{}
			}
			if err := m.Dnn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chatbot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chatbot == nil {
				m.Chatbot = &ChatbotEstimatorSpec{}
			}
			if err := m.Chatbot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NLPEstimator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NLPEstimator == nil {
				m.NLPEstimator = &NLPEstimatorSpec{}
			}
			if err := m.NLPEstimator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ensemble", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ensemble == nil {
				m.Ensemble = &EnsembleSpec{}
			}
			if err := m.Ensemble.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Training", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Training == nil {
				m.Training = &TrainingSpec{}
			}
			if err := m.Training.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Tested = &b
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aborted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Aborted = &b
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packaged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Packaged = &b
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Published", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Published = &b
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pushed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Pushed = &b
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reported = &b
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Paused = &b
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profiled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Profiled = &b
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Archived = &b
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forecasted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Forecasted = &b
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Released", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Released = &b
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Benchmarked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Benchmarked = &b
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baseline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Baseline = &b
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flagged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Flagged = &b
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha11.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forecasting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Forecasting == nil {
				m.Forecasting = &ForecastSpec{}
			}
			if err := m.Forecasting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compilation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Compilation == nil {
				m.Compilation = &v1alpha1.CompilerSpec{}
			}
			if err := m.Compilation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDeadlineSeconds", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ActiveDeadlineSeconds = &v
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.ModelType(dAtA[iNdEx:postIndex])
			m.EstimatorType = &s
			iNdEx = postIndex
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TTL = &v
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureEngineeringOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FeatureEngineeringOnly = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrainingStartTime == nil {
				m.TrainingStartTime = &v1.Time{}
			}
			if err := m.TrainingStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrainingEndTime == nil {
				m.TrainingEndTime = &v1.Time{}
			}
			if err := m.TrainingEndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestingStartTime == nil {
				m.TestingStartTime = &v1.Time{}
			}
			if err := m.TestingStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestingEndTime == nil {
				m.TestingEndTime = &v1.Time{}
			}
			if err := m.TestingEndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &v1.Time{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CVScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CVScore = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TrainingScore = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TestScore = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Cost = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Best", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Best = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CV = append(m.CV, v1alpha1.Measurement{})
			if err := m.CV[len(m.CV)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Train", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Train = append(m.Train, v1alpha1.Measurement{})
			if err := m.Train[len(m.Train)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Test", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Test = append(m.Test, v1alpha1.Measurement{})
			if err := m.Test[len(m.Test)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = ModelPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManifestUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManifestUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightsUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeightsUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelEncoderUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelEncoderUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogsUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MisclassUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MisclassUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TarUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TarUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Importance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Importance = append(m.Importance, FeatureImportance{})
			if err := m.Importance[len(m.Importance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForecastUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForecastUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PythonVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PythonVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PythonPackages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PythonPackages == nil {
				m.PythonPackages = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PythonPackages[mapkey] = mapvalue
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainDatasetLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TrainDatasetLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestDatasetLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TestDatasetLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationDataset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValidationDataset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingRows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrainingRows = &v
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingRows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TestingRows = &v
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationRows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidationRows = &v
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Progress = &v
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeInBytes", wireType)
			}
			m.SizeInBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeInBytes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latency", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latency = float64(math.Float64frombits(v))
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredictorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleasedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReleasedAt == nil {
				m.ReleasedAt = &v1.Time{}
			}
			if err := m.ReleasedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TarFileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TarFileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingDataHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TrainingDataHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TrainingResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TestingResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrainedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Team = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainerImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrainerImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndPoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Logs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrialID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrialID = &v
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocAucCurve", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RocAucCurve.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PRCurve", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PRCurve.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfusionMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConfusionMatrix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, ModelCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = ModelValidationName(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PrevModel = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriftFreq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriftFreq = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Freq(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriftInterval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DriftInterval = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Column = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex])
			m.Metric = &s
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Min = &v2
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Max = &v2
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPrecent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.MinPrecent = &v2
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPrecent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.MaxPrecent = &v2
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Aggregate(dAtA[iNdEx:postIndex])
			m.Agg = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelValidationResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelValidationResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelValidationResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Column = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex])
			m.Metric = &s
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.ActualValue = &v2
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Passed = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field At", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.At == nil {
				m.At = &v1.Time{}
			}
			if err := m.At.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationInSec", wireType)
			}
			m.DurationInSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationInSec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NLPEstimatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NLPEstimatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NLPEstimatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Base = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NNLayerParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NNLayerParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NNLayerParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Notebook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notebook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notebook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = NotebookConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Notebook{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookRun) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookRun: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookRun: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookRunCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookRunCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookRunCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = NotebookRunConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookRunList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookRunList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookRunList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, NotebookRun{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookRunSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookRunSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookRunSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotebookName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NotebookName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, NotebookVarValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TTL = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookRunStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookRunStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookRunStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = NotebookRunPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &v1.Time{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggeredBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggeredBy = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.TriggerType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Logs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, NotebookRunCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchemaRef == nil {
				m.SchemaRef = &v11.ObjectReference{}
			}
			if err := m.SchemaRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ImageName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Requirements = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebPackages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DebPackages = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vars", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vars = append(m.Vars, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha11.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDeadlineSeconds", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ActiveDeadlineSeconds = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.PriorityLevel(dAtA[iNdEx:postIndex])
			m.Priority = &s
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Paused = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRun", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastRun == nil {
				m.LastRun = &v1.Time{}
			}
			if err := m.LastRun.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, NotebookCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookVarValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookVarValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookVarValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeriodSeasonalitySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeriodSeasonalitySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeriodSeasonalitySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Periods", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Periods = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.SeasonalityMode(dAtA[iNdEx:postIndex])
			m.Mode = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeriodSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeriodSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeriodSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Freq(dAtA[iNdEx:postIndex])
			m.Interval = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Start = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrunerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrunerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrunerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := PrunerName(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartupTrials", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartupTrials = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WramupTrials", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WramupTrials = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumTrials", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinimumTrials = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSteps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntervalSteps = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precentile", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Precentile = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lower = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Upper = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SHOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SHOptions == nil {
				m.SHOptions = &SuccessiveHalvingOptions{}
			}
			if err := m.SHOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegressorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegressorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegressorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorScale", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.PriorScale = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Standardize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Standardize = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReleaseStageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReleaseStageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReleaseStageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServingSiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServingSiteName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PredictorName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Template == nil {
				m.Template = &v1alpha1.ModelDeploymentSpec{}
			}
			if err := m.Template.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualApproval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ManualApproval = &b
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validations = append(m.Validations, ModelValidation{})
			if err := m.Validations[len(m.Validations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Report) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Report: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Report: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = ReportConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Report{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EntityRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha11.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := ReportType(dAtA[iNdEx:postIndex])
			m.ReportType = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := ReportFormat(dAtA[iNdEx:postIndex])
			m.Format = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NotifierName = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDeadlineSeconds", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ActiveDeadlineSeconds = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Custom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Custom == nil {
				m.Custom = &CustomReportSpec{}
			}
			if err := m.Custom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &v1.Time{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = ReportPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Logs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, ReportCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceConsumption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceConsumption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceConsumption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Cpu = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mem", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mem = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpu", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gpu = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Study) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Study: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Study: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StudyCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StudyCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StudyCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = StudyConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StudyForecastSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StudyForecastSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StudyForecastSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hierarchy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hierarchy == nil {
				m.Hierarchy = &Hierarchy{}
			}
			if err := m.Hierarchy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForecastTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForecastTemplate == nil {
				m.ForecastTemplate = &ForecastSpec{}
			}
			if err := m.ForecastTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StudyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StudyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StudyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Study{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StudyScheduleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StudyScheduleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StudyScheduleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartAt == nil {
				m.StartAt = &v1.Time{}
			}
			if err := m.StartAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StudySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StudySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StudySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabRef == nil {
				m.LabRef = &v11.ObjectReference{}
			}
			if err := m.LabRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.MLTask(dAtA[iNdEx:postIndex])
			m.Task = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objective", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex])
			m.Objective = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objective2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex])
			m.Objective2 = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Search == nil {
				m.Search = &ModelSearchSpec{}
			}
			if err := m.Search.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureEngineering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeatureEngineering == nil {
				m.FeatureEngineering = &FeatureEngineeringSpec{}
			}
			if err := m.FeatureEngineering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrainingTemplate == nil {
				m.TrainingTemplate = &TrainingSpec{}
			}
			if err := m.TrainingTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Split", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Split == nil {
				m.Split = &DataSplit{}
			}
			if err := m.Split.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aborted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Aborted = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureEngineered", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FeatureEngineered = &b
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reported = &b
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Paused = &b
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profiled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Profiled = &b
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelPublished", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ModelPublished = &b
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelImagePushed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ModelImagePushed = &b
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelBenchmarked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ModelBenchmarked = &b
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha11.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDeadlineSeconds", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ActiveDeadlineSeconds = &v
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compilation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Compilation == nil {
				m.Compilation = &v1alpha1.CompilerSpec{}
			}
			if err := m.Compilation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Template = &b
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flagged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Flagged = &b
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Notification.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelImage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ModelImage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TTL = &v
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForecastSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ForecastSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StudyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StudyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StudyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Models", wireType)
			}
			m.Models = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Models |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureEngineeringModelWaiting", wireType)
			}
			m.FeatureEngineeringModelWaiting = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeatureEngineeringModelWaiting |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureEngineeringModelTraining", wireType)
			}
			m.FeatureEngineeringModelTraining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeatureEngineeringModelTraining |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureEngineeringModeFailed", wireType)
			}
			m.FeatureEngineeringModeFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeatureEngineeringModeFailed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureEngineeringModelTrained", wireType)
			}
			m.FeatureEngineeringModelTrained = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeatureEngineeringModelTrained |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchingModelWaiting", wireType)
			}
			m.SearchingModelWaiting = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SearchingModelWaiting |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchingModelsTraining", wireType)
			}
			m.SearchingModelsTraining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SearchingModelsTraining |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchingModeFailed", wireType)
			}
			m.SearchingModeFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SearchingModeFailed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchingModeTrained", wireType)
			}
			m.SearchingModeTrained = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SearchingModeTrained |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingModelWaiting", wireType)
			}
			m.TestingModelWaiting = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestingModelWaiting |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingModels", wireType)
			}
			m.TestingModels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestingModels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingModeFailed", wireType)
			}
			m.TestingModeFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestingModeFailed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestedModels", wireType)
			}
			m.TestedModels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestedModels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureEngineeringStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeatureEngineeringStartTime == nil {
				m.FeatureEngineeringStartTime = &v1.Time{}
			}
			if err := m.FeatureEngineeringStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureEngineerinEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeatureEngineerinEndTime == nil {
				m.FeatureEngineerinEndTime = &v1.Time{}
			}
			if err := m.FeatureEngineerinEndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchingStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchingStartTime == nil {
				m.SearchingStartTime = &v1.Time{}
			}
			if err := m.SearchingStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchingEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchingEndTime == nil {
				m.SearchingEndTime = &v1.Time{}
			}
			if err := m.SearchingEndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestingStartTime == nil {
				m.TestingStartTime = &v1.Time{}
			}
			if err := m.TestingStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestingEndTime == nil {
				m.TestingEndTime = &v1.Time{}
			}
			if err := m.TestingEndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &v1.Time{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BestModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestModelScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BestModelScore = float64(math.Float64frombits(v))
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = StudyPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainDatasetLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TrainDatasetLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestDatasetLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TestDatasetLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationDataset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValidationDataset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModelID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastModelID = &v
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LastError = &s
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingRows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrainingRows = &v
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingRows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TestingRows = &v
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationRows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidationRows = &v
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Progress = &v
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaslineModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.ClassicEstimatorName(dAtA[iNdEx:postIndex])
			m.BaslineModel = &s
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingDataHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TrainingDataHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggeredBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggeredBy = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.TriggerType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Logs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureEngineeringStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeatureEngineeringStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, StudyCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuccessiveHalvingOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuccessiveHalvingOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuccessiveHalvingOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBudget", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxBudget = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EliminationRate", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EliminationRate = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.ModalityType(dAtA[iNdEx:postIndex])
			m.Modality = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuccessiveHalvingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuccessiveHalvingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuccessiveHalvingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Budget", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Budget = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bracket", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bracket = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rung", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rung = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConfID = &v
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.ModalityType(dAtA[iNdEx:postIndex])
			m.Modality = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.TextEncoding(dAtA[iNdEx:postIndex])
			m.Encoder = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokenizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Tokenizer = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopWords", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.StopWords = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Pos = &b
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lemma", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Lemma = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stem", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Stem = &b
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Embedding = &s
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Svd = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSvdComponents", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxSvdComponents = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeSeriesDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeSeriesDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeSeriesDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TimeColumn = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TargetColumn = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTimeFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DateTimeFormat = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holiday", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Holiday.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GroupColumn = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubGroupColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SubGroupColumn = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubSubGroupColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SubSubGroupColumn = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.History == nil {
				m.History = &PeriodSpec{}
			}
			if err := m.History.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forecast", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Forecast == nil {
				m.Forecast = &PeriodSpec{}
			}
			if err := m.Forecast.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YearlySeasonality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YearlySeasonality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeeklySeasonality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WeeklySeasonality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailySeasonality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DailySeasonality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Growth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := GrowthMode(dAtA[iNdEx:postIndex])
			m.Growth = &s
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regressors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regressors = append(m.Regressors, RegressorSpec{})
			if err := m.Regressors[len(m.Regressors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomSeasonalities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomSeasonalities = append(m.CustomSeasonalities, CustomSeasonalitySpec{})
			if err := m.CustomSeasonalities[len(m.CustomSeasonalities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChangePoints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalWidth", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.IntervalWidth = &v2
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncertaintySamples", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UncertaintySamples = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrainingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrainingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrainingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.PriorityLevel(dAtA[iNdEx:postIndex])
			m.Priority = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.CvType(dAtA[iNdEx:postIndex])
			m.CvType = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CV", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CV = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Folds", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Folds = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvalMetrics", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvalMetrics = append(m.EvalMetrics, github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarlyStop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.EarlyStop = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckpointInterval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckpointInterval = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SH", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SH == nil {
				m.SH = &SuccessiveHalvingSpec{}
			}
			if err := m.SH.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Seed = &v2
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpu", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Gpu = &b
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Dist = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodeCount = &v
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sample", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Sample.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrainingStageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrainingStageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrainingStageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotebookName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NotebookName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LabName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudyTemplateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.StudyTemplateName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validations = append(m.Validations, ModelValidation{})
			if err := m.Validations[len(m.Validations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UATStageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UATStageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UATStageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServingSiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServingSiteName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validations = append(m.Validations, ModelValidation{})
			if err := m.Validations[len(m.Validations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Featurizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.VideoFeaturizer(dAtA[iNdEx:postIndex])
			m.Featurizer = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenerated(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenerated
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenerated
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenerated
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenerated        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenerated          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenerated = fmt.Errorf("proto: unexpected end of group")
)
