/**
*
* Copyright (C) 2017 modeld authors
* For license information, see LICENSE.txt
 */ // Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/metaprov/modeldapi/pkg/apis/training/v1alpha1/generated.proto

package v1alpha1

import (
	encoding_binary "encoding/binary"
	fmt "fmt"

	proto "github.com/gogo/protobuf/proto"
	github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1 "github.com/metaprov/modeldapi/pkg/apis/catalog/v1alpha1"
	v1alpha11 "github.com/metaprov/modeldapi/pkg/apis/catalog/v1alpha1"
	v1alpha1 "github.com/metaprov/modeldapi/pkg/apis/data/v1alpha1"

	io "io"

	github_com_metaprov_modeldapi_pkg_apis_inference_v1alpha1 "github.com/metaprov/modeldapi/pkg/apis/inference/v1alpha1"
	k8s_io_api_core_v1 "k8s.io/api/core/v1"
	v11 "k8s.io/api/core/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

func (m *AudioPipelineSpec) Reset()      { *m = AudioPipelineSpec{} }
func (*AudioPipelineSpec) ProtoMessage() {}
func (*AudioPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{0}
}
func (m *AudioPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AudioPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AudioPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AudioPipelineSpec.Merge(m, src)
}
func (m *AudioPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *AudioPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AudioPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AudioPipelineSpec proto.InternalMessageInfo

func (m *BacktestSpec) Reset()      { *m = BacktestSpec{} }
func (*BacktestSpec) ProtoMessage() {}
func (*BacktestSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{1}
}
func (m *BacktestSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BacktestSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BacktestSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BacktestSpec.Merge(m, src)
}
func (m *BacktestSpec) XXX_Size() int {
	return m.Size()
}
func (m *BacktestSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BacktestSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BacktestSpec proto.InternalMessageInfo

func (m *CapacityStageSpec) Reset()      { *m = CapacityStageSpec{} }
func (*CapacityStageSpec) ProtoMessage() {}
func (*CapacityStageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{2}
}
func (m *CapacityStageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CapacityStageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CapacityStageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapacityStageSpec.Merge(m, src)
}
func (m *CapacityStageSpec) XXX_Size() int {
	return m.Size()
}
func (m *CapacityStageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CapacityStageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CapacityStageSpec proto.InternalMessageInfo

func (m *CategoricalPipelineSpec) Reset()      { *m = CategoricalPipelineSpec{} }
func (*CategoricalPipelineSpec) ProtoMessage() {}
func (*CategoricalPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{3}
}
func (m *CategoricalPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CategoricalPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CategoricalPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CategoricalPipelineSpec.Merge(m, src)
}
func (m *CategoricalPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *CategoricalPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CategoricalPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CategoricalPipelineSpec proto.InternalMessageInfo

func (m *ClassicalEstimatorSpec) Reset()      { *m = ClassicalEstimatorSpec{} }
func (*ClassicalEstimatorSpec) ProtoMessage() {}
func (*ClassicalEstimatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{4}
}
func (m *ClassicalEstimatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassicalEstimatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClassicalEstimatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassicalEstimatorSpec.Merge(m, src)
}
func (m *ClassicalEstimatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *ClassicalEstimatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassicalEstimatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ClassicalEstimatorSpec proto.InternalMessageInfo

func (m *CompilerSpec) Reset()      { *m = CompilerSpec{} }
func (*CompilerSpec) ProtoMessage() {}
func (*CompilerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{5}
}
func (m *CompilerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompilerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompilerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompilerSpec.Merge(m, src)
}
func (m *CompilerSpec) XXX_Size() int {
	return m.Size()
}
func (m *CompilerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CompilerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CompilerSpec proto.InternalMessageInfo

func (m *DataSplit) Reset()      { *m = DataSplit{} }
func (*DataSplit) ProtoMessage() {}
func (*DataSplit) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{6}
}
func (m *DataSplit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSplit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataSplit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSplit.Merge(m, src)
}
func (m *DataSplit) XXX_Size() int {
	return m.Size()
}
func (m *DataSplit) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSplit.DiscardUnknown(m)
}

var xxx_messageInfo_DataSplit proto.InternalMessageInfo

func (m *DataStageSpec) Reset()      { *m = DataStageSpec{} }
func (*DataStageSpec) ProtoMessage() {}
func (*DataStageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{7}
}
func (m *DataStageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataStageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataStageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataStageSpec.Merge(m, src)
}
func (m *DataStageSpec) XXX_Size() int {
	return m.Size()
}
func (m *DataStageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DataStageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DataStageSpec proto.InternalMessageInfo

func (m *DateTimePipelineSpec) Reset()      { *m = DateTimePipelineSpec{} }
func (*DateTimePipelineSpec) ProtoMessage() {}
func (*DateTimePipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{8}
}
func (m *DateTimePipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DateTimePipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DateTimePipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DateTimePipelineSpec.Merge(m, src)
}
func (m *DateTimePipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *DateTimePipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DateTimePipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DateTimePipelineSpec proto.InternalMessageInfo

func (m *DeepEstimatorLayer) Reset()      { *m = DeepEstimatorLayer{} }
func (*DeepEstimatorLayer) ProtoMessage() {}
func (*DeepEstimatorLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{9}
}
func (m *DeepEstimatorLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeepEstimatorLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeepEstimatorLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeepEstimatorLayer.Merge(m, src)
}
func (m *DeepEstimatorLayer) XXX_Size() int {
	return m.Size()
}
func (m *DeepEstimatorLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_DeepEstimatorLayer.DiscardUnknown(m)
}

var xxx_messageInfo_DeepEstimatorLayer proto.InternalMessageInfo

func (m *DeepEstimatorSpec) Reset()      { *m = DeepEstimatorSpec{} }
func (*DeepEstimatorSpec) ProtoMessage() {}
func (*DeepEstimatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{10}
}
func (m *DeepEstimatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeepEstimatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeepEstimatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeepEstimatorSpec.Merge(m, src)
}
func (m *DeepEstimatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *DeepEstimatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DeepEstimatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DeepEstimatorSpec proto.InternalMessageInfo

func (m *DimensionValue) Reset()      { *m = DimensionValue{} }
func (*DimensionValue) ProtoMessage() {}
func (*DimensionValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{11}
}
func (m *DimensionValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DimensionValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DimensionValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DimensionValue.Merge(m, src)
}
func (m *DimensionValue) XXX_Size() int {
	return m.Size()
}
func (m *DimensionValue) XXX_DiscardUnknown() {
	xxx_messageInfo_DimensionValue.DiscardUnknown(m)
}

var xxx_messageInfo_DimensionValue proto.InternalMessageInfo

func (m *EnsembleRules) Reset()      { *m = EnsembleRules{} }
func (*EnsembleRules) ProtoMessage() {}
func (*EnsembleRules) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{12}
}
func (m *EnsembleRules) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnsembleRules) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnsembleRules) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnsembleRules.Merge(m, src)
}
func (m *EnsembleRules) XXX_Size() int {
	return m.Size()
}
func (m *EnsembleRules) XXX_DiscardUnknown() {
	xxx_messageInfo_EnsembleRules.DiscardUnknown(m)
}

var xxx_messageInfo_EnsembleRules proto.InternalMessageInfo

func (m *EnsembleSpec) Reset()      { *m = EnsembleSpec{} }
func (*EnsembleSpec) ProtoMessage() {}
func (*EnsembleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{13}
}
func (m *EnsembleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnsembleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnsembleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnsembleSpec.Merge(m, src)
}
func (m *EnsembleSpec) XXX_Size() int {
	return m.Size()
}
func (m *EnsembleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_EnsembleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_EnsembleSpec proto.InternalMessageInfo

func (m *ForecastObj) Reset()      { *m = ForecastObj{} }
func (*ForecastObj) ProtoMessage() {}
func (*ForecastObj) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{14}
}
func (m *ForecastObj) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForecastObj) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForecastObj) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForecastObj.Merge(m, src)
}
func (m *ForecastObj) XXX_Size() int {
	return m.Size()
}
func (m *ForecastObj) XXX_DiscardUnknown() {
	xxx_messageInfo_ForecastObj.DiscardUnknown(m)
}

var xxx_messageInfo_ForecastObj proto.InternalMessageInfo

func (m *ForecastingSpec) Reset()      { *m = ForecastingSpec{} }
func (*ForecastingSpec) ProtoMessage() {}
func (*ForecastingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{15}
}
func (m *ForecastingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForecastingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForecastingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForecastingSpec.Merge(m, src)
}
func (m *ForecastingSpec) XXX_Size() int {
	return m.Size()
}
func (m *ForecastingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ForecastingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ForecastingSpec proto.InternalMessageInfo

func (m *FreqSpec) Reset()      { *m = FreqSpec{} }
func (*FreqSpec) ProtoMessage() {}
func (*FreqSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{16}
}
func (m *FreqSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FreqSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FreqSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FreqSpec.Merge(m, src)
}
func (m *FreqSpec) XXX_Size() int {
	return m.Size()
}
func (m *FreqSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FreqSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FreqSpec proto.InternalMessageInfo

func (m *Hierarchy) Reset()      { *m = Hierarchy{} }
func (*Hierarchy) ProtoMessage() {}
func (*Hierarchy) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{17}
}
func (m *Hierarchy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Hierarchy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Hierarchy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Hierarchy.Merge(m, src)
}
func (m *Hierarchy) XXX_Size() int {
	return m.Size()
}
func (m *Hierarchy) XXX_DiscardUnknown() {
	xxx_messageInfo_Hierarchy.DiscardUnknown(m)
}

var xxx_messageInfo_Hierarchy proto.InternalMessageInfo

func (m *HyperParameterValue) Reset()      { *m = HyperParameterValue{} }
func (*HyperParameterValue) ProtoMessage() {}
func (*HyperParameterValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{18}
}
func (m *HyperParameterValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HyperParameterValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HyperParameterValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HyperParameterValue.Merge(m, src)
}
func (m *HyperParameterValue) XXX_Size() int {
	return m.Size()
}
func (m *HyperParameterValue) XXX_DiscardUnknown() {
	xxx_messageInfo_HyperParameterValue.DiscardUnknown(m)
}

var xxx_messageInfo_HyperParameterValue proto.InternalMessageInfo

func (m *ImagePipelineSpec) Reset()      { *m = ImagePipelineSpec{} }
func (*ImagePipelineSpec) ProtoMessage() {}
func (*ImagePipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{19}
}
func (m *ImagePipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImagePipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ImagePipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImagePipelineSpec.Merge(m, src)
}
func (m *ImagePipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *ImagePipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ImagePipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ImagePipelineSpec proto.InternalMessageInfo

func (m *Level) Reset()      { *m = Level{} }
func (*Level) ProtoMessage() {}
func (*Level) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{20}
}
func (m *Level) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Level) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Level) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Level.Merge(m, src)
}
func (m *Level) XXX_Size() int {
	return m.Size()
}
func (m *Level) XXX_DiscardUnknown() {
	xxx_messageInfo_Level.DiscardUnknown(m)
}

var xxx_messageInfo_Level proto.InternalMessageInfo

func (m *Model) Reset()      { *m = Model{} }
func (*Model) ProtoMessage() {}
func (*Model) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{21}
}
func (m *Model) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Model) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model.Merge(m, src)
}
func (m *Model) XXX_Size() int {
	return m.Size()
}
func (m *Model) XXX_DiscardUnknown() {
	xxx_messageInfo_Model.DiscardUnknown(m)
}

var xxx_messageInfo_Model proto.InternalMessageInfo

func (m *ModelAutobuilder) Reset()      { *m = ModelAutobuilder{} }
func (*ModelAutobuilder) ProtoMessage() {}
func (*ModelAutobuilder) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{22}
}
func (m *ModelAutobuilder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelAutobuilder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelAutobuilder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAutobuilder.Merge(m, src)
}
func (m *ModelAutobuilder) XXX_Size() int {
	return m.Size()
}
func (m *ModelAutobuilder) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAutobuilder.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAutobuilder proto.InternalMessageInfo

func (m *ModelAutobuilderCondition) Reset()      { *m = ModelAutobuilderCondition{} }
func (*ModelAutobuilderCondition) ProtoMessage() {}
func (*ModelAutobuilderCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{23}
}
func (m *ModelAutobuilderCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelAutobuilderCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelAutobuilderCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAutobuilderCondition.Merge(m, src)
}
func (m *ModelAutobuilderCondition) XXX_Size() int {
	return m.Size()
}
func (m *ModelAutobuilderCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAutobuilderCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAutobuilderCondition proto.InternalMessageInfo

func (m *ModelAutobuilderList) Reset()      { *m = ModelAutobuilderList{} }
func (*ModelAutobuilderList) ProtoMessage() {}
func (*ModelAutobuilderList) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{24}
}
func (m *ModelAutobuilderList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelAutobuilderList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelAutobuilderList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAutobuilderList.Merge(m, src)
}
func (m *ModelAutobuilderList) XXX_Size() int {
	return m.Size()
}
func (m *ModelAutobuilderList) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAutobuilderList.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAutobuilderList proto.InternalMessageInfo

func (m *ModelAutobuilderSpec) Reset()      { *m = ModelAutobuilderSpec{} }
func (*ModelAutobuilderSpec) ProtoMessage() {}
func (*ModelAutobuilderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{25}
}
func (m *ModelAutobuilderSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelAutobuilderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelAutobuilderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAutobuilderSpec.Merge(m, src)
}
func (m *ModelAutobuilderSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelAutobuilderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAutobuilderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAutobuilderSpec proto.InternalMessageInfo

func (m *ModelAutobuilderStatus) Reset()      { *m = ModelAutobuilderStatus{} }
func (*ModelAutobuilderStatus) ProtoMessage() {}
func (*ModelAutobuilderStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{26}
}
func (m *ModelAutobuilderStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelAutobuilderStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelAutobuilderStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAutobuilderStatus.Merge(m, src)
}
func (m *ModelAutobuilderStatus) XXX_Size() int {
	return m.Size()
}
func (m *ModelAutobuilderStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAutobuilderStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAutobuilderStatus proto.InternalMessageInfo

func (m *ModelCondition) Reset()      { *m = ModelCondition{} }
func (*ModelCondition) ProtoMessage() {}
func (*ModelCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{27}
}
func (m *ModelCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelCondition.Merge(m, src)
}
func (m *ModelCondition) XXX_Size() int {
	return m.Size()
}
func (m *ModelCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ModelCondition proto.InternalMessageInfo

func (m *ModelList) Reset()      { *m = ModelList{} }
func (*ModelList) ProtoMessage() {}
func (*ModelList) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{28}
}
func (m *ModelList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelList.Merge(m, src)
}
func (m *ModelList) XXX_Size() int {
	return m.Size()
}
func (m *ModelList) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelList.DiscardUnknown(m)
}

var xxx_messageInfo_ModelList proto.InternalMessageInfo

func (m *ModelPipeline) Reset()      { *m = ModelPipeline{} }
func (*ModelPipeline) ProtoMessage() {}
func (*ModelPipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{29}
}
func (m *ModelPipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipeline.Merge(m, src)
}
func (m *ModelPipeline) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipeline.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipeline proto.InternalMessageInfo

func (m *ModelPipelineCondition) Reset()      { *m = ModelPipelineCondition{} }
func (*ModelPipelineCondition) ProtoMessage() {}
func (*ModelPipelineCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{30}
}
func (m *ModelPipelineCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineCondition.Merge(m, src)
}
func (m *ModelPipelineCondition) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineCondition proto.InternalMessageInfo

func (m *ModelPipelineList) Reset()      { *m = ModelPipelineList{} }
func (*ModelPipelineList) ProtoMessage() {}
func (*ModelPipelineList) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{31}
}
func (m *ModelPipelineList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineList.Merge(m, src)
}
func (m *ModelPipelineList) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineList) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineList.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineList proto.InternalMessageInfo

func (m *ModelPipelineRun) Reset()      { *m = ModelPipelineRun{} }
func (*ModelPipelineRun) ProtoMessage() {}
func (*ModelPipelineRun) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{32}
}
func (m *ModelPipelineRun) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineRun) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineRun) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineRun.Merge(m, src)
}
func (m *ModelPipelineRun) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineRun) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineRun.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineRun proto.InternalMessageInfo

func (m *ModelPipelineRunCondition) Reset()      { *m = ModelPipelineRunCondition{} }
func (*ModelPipelineRunCondition) ProtoMessage() {}
func (*ModelPipelineRunCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{33}
}
func (m *ModelPipelineRunCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineRunCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineRunCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineRunCondition.Merge(m, src)
}
func (m *ModelPipelineRunCondition) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineRunCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineRunCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineRunCondition proto.InternalMessageInfo

func (m *ModelPipelineRunList) Reset()      { *m = ModelPipelineRunList{} }
func (*ModelPipelineRunList) ProtoMessage() {}
func (*ModelPipelineRunList) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{34}
}
func (m *ModelPipelineRunList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineRunList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineRunList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineRunList.Merge(m, src)
}
func (m *ModelPipelineRunList) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineRunList) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineRunList.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineRunList proto.InternalMessageInfo

func (m *ModelPipelineRunSpec) Reset()      { *m = ModelPipelineRunSpec{} }
func (*ModelPipelineRunSpec) ProtoMessage() {}
func (*ModelPipelineRunSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{35}
}
func (m *ModelPipelineRunSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineRunSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineRunSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineRunSpec.Merge(m, src)
}
func (m *ModelPipelineRunSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineRunSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineRunSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineRunSpec proto.InternalMessageInfo

func (m *ModelPipelineRunStageStatus) Reset()      { *m = ModelPipelineRunStageStatus{} }
func (*ModelPipelineRunStageStatus) ProtoMessage() {}
func (*ModelPipelineRunStageStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{36}
}
func (m *ModelPipelineRunStageStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineRunStageStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineRunStageStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineRunStageStatus.Merge(m, src)
}
func (m *ModelPipelineRunStageStatus) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineRunStageStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineRunStageStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineRunStageStatus proto.InternalMessageInfo

func (m *ModelPipelineRunStatus) Reset()      { *m = ModelPipelineRunStatus{} }
func (*ModelPipelineRunStatus) ProtoMessage() {}
func (*ModelPipelineRunStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{37}
}
func (m *ModelPipelineRunStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineRunStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineRunStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineRunStatus.Merge(m, src)
}
func (m *ModelPipelineRunStatus) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineRunStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineRunStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineRunStatus proto.InternalMessageInfo

func (m *ModelPipelineSpec) Reset()      { *m = ModelPipelineSpec{} }
func (*ModelPipelineSpec) ProtoMessage() {}
func (*ModelPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{38}
}
func (m *ModelPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineSpec.Merge(m, src)
}
func (m *ModelPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineSpec proto.InternalMessageInfo

func (m *ModelPipelineStatus) Reset()      { *m = ModelPipelineStatus{} }
func (*ModelPipelineStatus) ProtoMessage() {}
func (*ModelPipelineStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{39}
}
func (m *ModelPipelineStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPipelineStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelPipelineStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPipelineStatus.Merge(m, src)
}
func (m *ModelPipelineStatus) XXX_Size() int {
	return m.Size()
}
func (m *ModelPipelineStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPipelineStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPipelineStatus proto.InternalMessageInfo

func (m *ModelResult) Reset()      { *m = ModelResult{} }
func (*ModelResult) ProtoMessage() {}
func (*ModelResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{40}
}
func (m *ModelResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelResult.Merge(m, src)
}
func (m *ModelResult) XXX_Size() int {
	return m.Size()
}
func (m *ModelResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelResult.DiscardUnknown(m)
}

var xxx_messageInfo_ModelResult proto.InternalMessageInfo

func (m *ModelSearchSpec) Reset()      { *m = ModelSearchSpec{} }
func (*ModelSearchSpec) ProtoMessage() {}
func (*ModelSearchSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{41}
}
func (m *ModelSearchSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelSearchSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelSearchSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelSearchSpec.Merge(m, src)
}
func (m *ModelSearchSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelSearchSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelSearchSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelSearchSpec proto.InternalMessageInfo

func (m *ModelSpec) Reset()      { *m = ModelSpec{} }
func (*ModelSpec) ProtoMessage() {}
func (*ModelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{42}
}
func (m *ModelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelSpec.Merge(m, src)
}
func (m *ModelSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelSpec proto.InternalMessageInfo

func (m *ModelStatus) Reset()      { *m = ModelStatus{} }
func (*ModelStatus) ProtoMessage() {}
func (*ModelStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{43}
}
func (m *ModelStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelStatus.Merge(m, src)
}
func (m *ModelStatus) XXX_Size() int {
	return m.Size()
}
func (m *ModelStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ModelStatus proto.InternalMessageInfo

func (m *ModelTestResult) Reset()      { *m = ModelTestResult{} }
func (*ModelTestResult) ProtoMessage() {}
func (*ModelTestResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{44}
}
func (m *ModelTestResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelTestResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelTestResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelTestResult.Merge(m, src)
}
func (m *ModelTestResult) XXX_Size() int {
	return m.Size()
}
func (m *ModelTestResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelTestResult.DiscardUnknown(m)
}

var xxx_messageInfo_ModelTestResult proto.InternalMessageInfo

func (m *ModelTestSpec) Reset()      { *m = ModelTestSpec{} }
func (*ModelTestSpec) ProtoMessage() {}
func (*ModelTestSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{45}
}
func (m *ModelTestSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelTestSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModelTestSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelTestSpec.Merge(m, src)
}
func (m *ModelTestSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelTestSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelTestSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelTestSpec proto.InternalMessageInfo

func (m *NNLayerParameter) Reset()      { *m = NNLayerParameter{} }
func (*NNLayerParameter) ProtoMessage() {}
func (*NNLayerParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{46}
}
func (m *NNLayerParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NNLayerParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NNLayerParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NNLayerParameter.Merge(m, src)
}
func (m *NNLayerParameter) XXX_Size() int {
	return m.Size()
}
func (m *NNLayerParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_NNLayerParameter.DiscardUnknown(m)
}

var xxx_messageInfo_NNLayerParameter proto.InternalMessageInfo

func (m *Notebook) Reset()      { *m = Notebook{} }
func (*Notebook) ProtoMessage() {}
func (*Notebook) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{47}
}
func (m *Notebook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notebook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Notebook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notebook.Merge(m, src)
}
func (m *Notebook) XXX_Size() int {
	return m.Size()
}
func (m *Notebook) XXX_DiscardUnknown() {
	xxx_messageInfo_Notebook.DiscardUnknown(m)
}

var xxx_messageInfo_Notebook proto.InternalMessageInfo

func (m *NotebookCondition) Reset()      { *m = NotebookCondition{} }
func (*NotebookCondition) ProtoMessage() {}
func (*NotebookCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{48}
}
func (m *NotebookCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookCondition.Merge(m, src)
}
func (m *NotebookCondition) XXX_Size() int {
	return m.Size()
}
func (m *NotebookCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookCondition.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookCondition proto.InternalMessageInfo

func (m *NotebookList) Reset()      { *m = NotebookList{} }
func (*NotebookList) ProtoMessage() {}
func (*NotebookList) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{49}
}
func (m *NotebookList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookList.Merge(m, src)
}
func (m *NotebookList) XXX_Size() int {
	return m.Size()
}
func (m *NotebookList) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookList.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookList proto.InternalMessageInfo

func (m *NotebookRun) Reset()      { *m = NotebookRun{} }
func (*NotebookRun) ProtoMessage() {}
func (*NotebookRun) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{50}
}
func (m *NotebookRun) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookRun) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookRun) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookRun.Merge(m, src)
}
func (m *NotebookRun) XXX_Size() int {
	return m.Size()
}
func (m *NotebookRun) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookRun.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookRun proto.InternalMessageInfo

func (m *NotebookRunCondition) Reset()      { *m = NotebookRunCondition{} }
func (*NotebookRunCondition) ProtoMessage() {}
func (*NotebookRunCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{51}
}
func (m *NotebookRunCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookRunCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookRunCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookRunCondition.Merge(m, src)
}
func (m *NotebookRunCondition) XXX_Size() int {
	return m.Size()
}
func (m *NotebookRunCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookRunCondition.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookRunCondition proto.InternalMessageInfo

func (m *NotebookRunList) Reset()      { *m = NotebookRunList{} }
func (*NotebookRunList) ProtoMessage() {}
func (*NotebookRunList) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{52}
}
func (m *NotebookRunList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookRunList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookRunList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookRunList.Merge(m, src)
}
func (m *NotebookRunList) XXX_Size() int {
	return m.Size()
}
func (m *NotebookRunList) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookRunList.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookRunList proto.InternalMessageInfo

func (m *NotebookRunSpec) Reset()      { *m = NotebookRunSpec{} }
func (*NotebookRunSpec) ProtoMessage() {}
func (*NotebookRunSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{53}
}
func (m *NotebookRunSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookRunSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookRunSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookRunSpec.Merge(m, src)
}
func (m *NotebookRunSpec) XXX_Size() int {
	return m.Size()
}
func (m *NotebookRunSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookRunSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookRunSpec proto.InternalMessageInfo

func (m *NotebookRunStatus) Reset()      { *m = NotebookRunStatus{} }
func (*NotebookRunStatus) ProtoMessage() {}
func (*NotebookRunStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{54}
}
func (m *NotebookRunStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookRunStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookRunStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookRunStatus.Merge(m, src)
}
func (m *NotebookRunStatus) XXX_Size() int {
	return m.Size()
}
func (m *NotebookRunStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookRunStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookRunStatus proto.InternalMessageInfo

func (m *NotebookSpec) Reset()      { *m = NotebookSpec{} }
func (*NotebookSpec) ProtoMessage() {}
func (*NotebookSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{55}
}
func (m *NotebookSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookSpec.Merge(m, src)
}
func (m *NotebookSpec) XXX_Size() int {
	return m.Size()
}
func (m *NotebookSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookSpec proto.InternalMessageInfo

func (m *NotebookStatus) Reset()      { *m = NotebookStatus{} }
func (*NotebookStatus) ProtoMessage() {}
func (*NotebookStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{56}
}
func (m *NotebookStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookStatus.Merge(m, src)
}
func (m *NotebookStatus) XXX_Size() int {
	return m.Size()
}
func (m *NotebookStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookStatus proto.InternalMessageInfo

func (m *NotebookVarValue) Reset()      { *m = NotebookVarValue{} }
func (*NotebookVarValue) ProtoMessage() {}
func (*NotebookVarValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{57}
}
func (m *NotebookVarValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookVarValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NotebookVarValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookVarValue.Merge(m, src)
}
func (m *NotebookVarValue) XXX_Size() int {
	return m.Size()
}
func (m *NotebookVarValue) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookVarValue.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookVarValue proto.InternalMessageInfo

func (m *NumericPipelineSpec) Reset()      { *m = NumericPipelineSpec{} }
func (*NumericPipelineSpec) ProtoMessage() {}
func (*NumericPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{58}
}
func (m *NumericPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumericPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NumericPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumericPipelineSpec.Merge(m, src)
}
func (m *NumericPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *NumericPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NumericPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NumericPipelineSpec proto.InternalMessageInfo

func (m *PipelineTrigger) Reset()      { *m = PipelineTrigger{} }
func (*PipelineTrigger) ProtoMessage() {}
func (*PipelineTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{59}
}
func (m *PipelineTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PipelineTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineTrigger.Merge(m, src)
}
func (m *PipelineTrigger) XXX_Size() int {
	return m.Size()
}
func (m *PipelineTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineTrigger proto.InternalMessageInfo

func (m *PreprocessingSpec) Reset()      { *m = PreprocessingSpec{} }
func (*PreprocessingSpec) ProtoMessage() {}
func (*PreprocessingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{60}
}
func (m *PreprocessingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreprocessingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PreprocessingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreprocessingSpec.Merge(m, src)
}
func (m *PreprocessingSpec) XXX_Size() int {
	return m.Size()
}
func (m *PreprocessingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PreprocessingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PreprocessingSpec proto.InternalMessageInfo

func (m *ProdStageSpec) Reset()      { *m = ProdStageSpec{} }
func (*ProdStageSpec) ProtoMessage() {}
func (*ProdStageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{61}
}
func (m *ProdStageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProdStageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProdStageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProdStageSpec.Merge(m, src)
}
func (m *ProdStageSpec) XXX_Size() int {
	return m.Size()
}
func (m *ProdStageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ProdStageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ProdStageSpec proto.InternalMessageInfo

func (m *Report) Reset()      { *m = Report{} }
func (*Report) ProtoMessage() {}
func (*Report) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{62}
}
func (m *Report) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Report) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Report) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Report.Merge(m, src)
}
func (m *Report) XXX_Size() int {
	return m.Size()
}
func (m *Report) XXX_DiscardUnknown() {
	xxx_messageInfo_Report.DiscardUnknown(m)
}

var xxx_messageInfo_Report proto.InternalMessageInfo

func (m *ReportCondition) Reset()      { *m = ReportCondition{} }
func (*ReportCondition) ProtoMessage() {}
func (*ReportCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{63}
}
func (m *ReportCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReportCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportCondition.Merge(m, src)
}
func (m *ReportCondition) XXX_Size() int {
	return m.Size()
}
func (m *ReportCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ReportCondition proto.InternalMessageInfo

func (m *ReportList) Reset()      { *m = ReportList{} }
func (*ReportList) ProtoMessage() {}
func (*ReportList) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{64}
}
func (m *ReportList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReportList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportList.Merge(m, src)
}
func (m *ReportList) XXX_Size() int {
	return m.Size()
}
func (m *ReportList) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportList.DiscardUnknown(m)
}

var xxx_messageInfo_ReportList proto.InternalMessageInfo

func (m *ReportSpec) Reset()      { *m = ReportSpec{} }
func (*ReportSpec) ProtoMessage() {}
func (*ReportSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{65}
}
func (m *ReportSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReportSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportSpec.Merge(m, src)
}
func (m *ReportSpec) XXX_Size() int {
	return m.Size()
}
func (m *ReportSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ReportSpec proto.InternalMessageInfo

func (m *ReportStatus) Reset()      { *m = ReportStatus{} }
func (*ReportStatus) ProtoMessage() {}
func (*ReportStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{66}
}
func (m *ReportStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReportStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportStatus.Merge(m, src)
}
func (m *ReportStatus) XXX_Size() int {
	return m.Size()
}
func (m *ReportStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ReportStatus proto.InternalMessageInfo

func (m *Study) Reset()      { *m = Study{} }
func (*Study) ProtoMessage() {}
func (*Study) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{67}
}
func (m *Study) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Study) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Study) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Study.Merge(m, src)
}
func (m *Study) XXX_Size() int {
	return m.Size()
}
func (m *Study) XXX_DiscardUnknown() {
	xxx_messageInfo_Study.DiscardUnknown(m)
}

var xxx_messageInfo_Study proto.InternalMessageInfo

func (m *StudyCondition) Reset()      { *m = StudyCondition{} }
func (*StudyCondition) ProtoMessage() {}
func (*StudyCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{68}
}
func (m *StudyCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StudyCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StudyCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StudyCondition.Merge(m, src)
}
func (m *StudyCondition) XXX_Size() int {
	return m.Size()
}
func (m *StudyCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_StudyCondition.DiscardUnknown(m)
}

var xxx_messageInfo_StudyCondition proto.InternalMessageInfo

func (m *StudyList) Reset()      { *m = StudyList{} }
func (*StudyList) ProtoMessage() {}
func (*StudyList) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{69}
}
func (m *StudyList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StudyList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StudyList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StudyList.Merge(m, src)
}
func (m *StudyList) XXX_Size() int {
	return m.Size()
}
func (m *StudyList) XXX_DiscardUnknown() {
	xxx_messageInfo_StudyList.DiscardUnknown(m)
}

var xxx_messageInfo_StudyList proto.InternalMessageInfo

func (m *StudySpec) Reset()      { *m = StudySpec{} }
func (*StudySpec) ProtoMessage() {}
func (*StudySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{70}
}
func (m *StudySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StudySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StudySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StudySpec.Merge(m, src)
}
func (m *StudySpec) XXX_Size() int {
	return m.Size()
}
func (m *StudySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StudySpec.DiscardUnknown(m)
}

var xxx_messageInfo_StudySpec proto.InternalMessageInfo

func (m *StudyStatus) Reset()      { *m = StudyStatus{} }
func (*StudyStatus) ProtoMessage() {}
func (*StudyStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{71}
}
func (m *StudyStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StudyStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StudyStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StudyStatus.Merge(m, src)
}
func (m *StudyStatus) XXX_Size() int {
	return m.Size()
}
func (m *StudyStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_StudyStatus.DiscardUnknown(m)
}

var xxx_messageInfo_StudyStatus proto.InternalMessageInfo

func (m *SuccessiveHalvingOptions) Reset()      { *m = SuccessiveHalvingOptions{} }
func (*SuccessiveHalvingOptions) ProtoMessage() {}
func (*SuccessiveHalvingOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{72}
}
func (m *SuccessiveHalvingOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuccessiveHalvingOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SuccessiveHalvingOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuccessiveHalvingOptions.Merge(m, src)
}
func (m *SuccessiveHalvingOptions) XXX_Size() int {
	return m.Size()
}
func (m *SuccessiveHalvingOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SuccessiveHalvingOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SuccessiveHalvingOptions proto.InternalMessageInfo

func (m *SuccessiveHalvingSpec) Reset()      { *m = SuccessiveHalvingSpec{} }
func (*SuccessiveHalvingSpec) ProtoMessage() {}
func (*SuccessiveHalvingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{73}
}
func (m *SuccessiveHalvingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuccessiveHalvingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SuccessiveHalvingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuccessiveHalvingSpec.Merge(m, src)
}
func (m *SuccessiveHalvingSpec) XXX_Size() int {
	return m.Size()
}
func (m *SuccessiveHalvingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SuccessiveHalvingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SuccessiveHalvingSpec proto.InternalMessageInfo

func (m *TestScore) Reset()      { *m = TestScore{} }
func (*TestScore) ProtoMessage() {}
func (*TestScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{74}
}
func (m *TestScore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TestScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestScore.Merge(m, src)
}
func (m *TestScore) XXX_Size() int {
	return m.Size()
}
func (m *TestScore) XXX_DiscardUnknown() {
	xxx_messageInfo_TestScore.DiscardUnknown(m)
}

var xxx_messageInfo_TestScore proto.InternalMessageInfo

func (m *TextPipelineSpec) Reset()      { *m = TextPipelineSpec{} }
func (*TextPipelineSpec) ProtoMessage() {}
func (*TextPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{75}
}
func (m *TextPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TextPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TextPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextPipelineSpec.Merge(m, src)
}
func (m *TextPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *TextPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TextPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TextPipelineSpec proto.InternalMessageInfo

func (m *TrainingResourceRequest) Reset()      { *m = TrainingResourceRequest{} }
func (*TrainingResourceRequest) ProtoMessage() {}
func (*TrainingResourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{76}
}
func (m *TrainingResourceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrainingResourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TrainingResourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrainingResourceRequest.Merge(m, src)
}
func (m *TrainingResourceRequest) XXX_Size() int {
	return m.Size()
}
func (m *TrainingResourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TrainingResourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TrainingResourceRequest proto.InternalMessageInfo

func (m *TrainingSpec) Reset()      { *m = TrainingSpec{} }
func (*TrainingSpec) ProtoMessage() {}
func (*TrainingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{77}
}
func (m *TrainingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrainingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TrainingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrainingSpec.Merge(m, src)
}
func (m *TrainingSpec) XXX_Size() int {
	return m.Size()
}
func (m *TrainingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TrainingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TrainingSpec proto.InternalMessageInfo

func (m *TrainingStageSpec) Reset()      { *m = TrainingStageSpec{} }
func (*TrainingStageSpec) ProtoMessage() {}
func (*TrainingStageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{78}
}
func (m *TrainingStageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrainingStageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TrainingStageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrainingStageSpec.Merge(m, src)
}
func (m *TrainingStageSpec) XXX_Size() int {
	return m.Size()
}
func (m *TrainingStageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TrainingStageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TrainingStageSpec proto.InternalMessageInfo

func (m *UATStageSpec) Reset()      { *m = UATStageSpec{} }
func (*UATStageSpec) ProtoMessage() {}
func (*UATStageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{79}
}
func (m *UATStageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UATStageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UATStageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UATStageSpec.Merge(m, src)
}
func (m *UATStageSpec) XXX_Size() int {
	return m.Size()
}
func (m *UATStageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_UATStageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_UATStageSpec proto.InternalMessageInfo

func (m *VideoPipelineSpec) Reset()      { *m = VideoPipelineSpec{} }
func (*VideoPipelineSpec) ProtoMessage() {}
func (*VideoPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_26c54310f0109c27, []int{80}
}
func (m *VideoPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VideoPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoPipelineSpec.Merge(m, src)
}
func (m *VideoPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *VideoPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VideoPipelineSpec proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AudioPipelineSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.AudioPipelineSpec")
	proto.RegisterType((*BacktestSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.BacktestSpec")
	proto.RegisterType((*CapacityStageSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.CapacityStageSpec")
	proto.RegisterType((*CategoricalPipelineSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.CategoricalPipelineSpec")
	proto.RegisterType((*ClassicalEstimatorSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ClassicalEstimatorSpec")
	proto.RegisterType((*CompilerSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.CompilerSpec")
	proto.RegisterType((*DataSplit)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.DataSplit")
	proto.RegisterType((*DataStageSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.DataStageSpec")
	proto.RegisterType((*DateTimePipelineSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.DateTimePipelineSpec")
	proto.RegisterType((*DeepEstimatorLayer)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.DeepEstimatorLayer")
	proto.RegisterType((*DeepEstimatorSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.DeepEstimatorSpec")
	proto.RegisterType((*DimensionValue)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.DimensionValue")
	proto.RegisterType((*EnsembleRules)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.EnsembleRules")
	proto.RegisterType((*EnsembleSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.EnsembleSpec")
	proto.RegisterType((*ForecastObj)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ForecastObj")
	proto.RegisterType((*ForecastingSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ForecastingSpec")
	proto.RegisterType((*FreqSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.FreqSpec")
	proto.RegisterType((*Hierarchy)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.Hierarchy")
	proto.RegisterType((*HyperParameterValue)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.HyperParameterValue")
	proto.RegisterType((*ImagePipelineSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ImagePipelineSpec")
	proto.RegisterType((*Level)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.Level")
	proto.RegisterType((*Model)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.Model")
	proto.RegisterType((*ModelAutobuilder)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelAutobuilder")
	proto.RegisterType((*ModelAutobuilderCondition)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelAutobuilderCondition")
	proto.RegisterType((*ModelAutobuilderList)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelAutobuilderList")
	proto.RegisterType((*ModelAutobuilderSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelAutobuilderSpec")
	proto.RegisterType((*ModelAutobuilderStatus)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelAutobuilderStatus")
	proto.RegisterType((*ModelCondition)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelCondition")
	proto.RegisterType((*ModelList)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelList")
	proto.RegisterType((*ModelPipeline)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelPipeline")
	proto.RegisterType((*ModelPipelineCondition)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelPipelineCondition")
	proto.RegisterType((*ModelPipelineList)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelPipelineList")
	proto.RegisterType((*ModelPipelineRun)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelPipelineRun")
	proto.RegisterType((*ModelPipelineRunCondition)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelPipelineRunCondition")
	proto.RegisterType((*ModelPipelineRunList)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelPipelineRunList")
	proto.RegisterType((*ModelPipelineRunSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelPipelineRunSpec")
	proto.RegisterType((*ModelPipelineRunStageStatus)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelPipelineRunStageStatus")
	proto.RegisterType((*ModelPipelineRunStatus)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelPipelineRunStatus")
	proto.RegisterType((*ModelPipelineSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelPipelineSpec")
	proto.RegisterType((*ModelPipelineStatus)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelPipelineStatus")
	proto.RegisterType((*ModelResult)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelResult")
	proto.RegisterType((*ModelSearchSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelSearchSpec")
	proto.RegisterType((*ModelSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelSpec")
	proto.RegisterType((*ModelStatus)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelStatus")
	proto.RegisterType((*ModelTestResult)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelTestResult")
	proto.RegisterType((*ModelTestSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ModelTestSpec")
	proto.RegisterType((*NNLayerParameter)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.NNLayerParameter")
	proto.RegisterType((*Notebook)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.Notebook")
	proto.RegisterType((*NotebookCondition)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.NotebookCondition")
	proto.RegisterType((*NotebookList)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.NotebookList")
	proto.RegisterType((*NotebookRun)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.NotebookRun")
	proto.RegisterType((*NotebookRunCondition)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.NotebookRunCondition")
	proto.RegisterType((*NotebookRunList)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.NotebookRunList")
	proto.RegisterType((*NotebookRunSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.NotebookRunSpec")
	proto.RegisterType((*NotebookRunStatus)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.NotebookRunStatus")
	proto.RegisterType((*NotebookSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.NotebookSpec")
	proto.RegisterType((*NotebookStatus)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.NotebookStatus")
	proto.RegisterType((*NotebookVarValue)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.NotebookVarValue")
	proto.RegisterType((*NumericPipelineSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.NumericPipelineSpec")
	proto.RegisterType((*PipelineTrigger)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.PipelineTrigger")
	proto.RegisterType((*PreprocessingSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.PreprocessingSpec")
	proto.RegisterType((*ProdStageSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ProdStageSpec")
	proto.RegisterType((*Report)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.Report")
	proto.RegisterType((*ReportCondition)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ReportCondition")
	proto.RegisterType((*ReportList)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ReportList")
	proto.RegisterType((*ReportSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ReportSpec")
	proto.RegisterType((*ReportStatus)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.ReportStatus")
	proto.RegisterType((*Study)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.Study")
	proto.RegisterType((*StudyCondition)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.StudyCondition")
	proto.RegisterType((*StudyList)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.StudyList")
	proto.RegisterType((*StudySpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.StudySpec")
	proto.RegisterType((*StudyStatus)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.StudyStatus")
	proto.RegisterType((*SuccessiveHalvingOptions)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.SuccessiveHalvingOptions")
	proto.RegisterType((*SuccessiveHalvingSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.SuccessiveHalvingSpec")
	proto.RegisterType((*TestScore)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.TestScore")
	proto.RegisterType((*TextPipelineSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.TextPipelineSpec")
	proto.RegisterType((*TrainingResourceRequest)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.TrainingResourceRequest")
	proto.RegisterType((*TrainingSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.TrainingSpec")
	proto.RegisterType((*TrainingStageSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.TrainingStageSpec")
	proto.RegisterType((*UATStageSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.UATStageSpec")
	proto.RegisterType((*VideoPipelineSpec)(nil), "github.com.metaprov.modeldapi.pkg.apis.training.v1alpha1.VideoPipelineSpec")
}

func init() {
	proto.RegisterFile("github.com/metaprov/modeldapi/pkg/apis/training/v1alpha1/generated.proto", fileDescriptor_26c54310f0109c27)
}

var fileDescriptor_26c54310f0109c27 = []byte{
	// 7303 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0xef, 0x6f, 0x63, 0xc7,
	0x75, 0xa8, 0x49, 0x91, 0x12, 0x79, 0xa8, 0x1f, 0xab, 0xd9, 0x1f, 0xa6, 0x1d, 0x7b, 0xe9, 0x47,
	0xc7, 0xc1, 0x26, 0x76, 0xb4, 0xf1, 0xc2, 0x49, 0x9c, 0xc4, 0x71, 0x22, 0x4a, 0xab, 0x5d, 0xd9,
	0xd2, 0x5a, 0x1e, 0xd1, 0xbb, 0x2f, 0x81, 0xf3, 0x5e, 0xae, 0xc8, 0x11, 0x75, 0xad, 0xcb, 0x7b,
	0xe9, 0x7b, 0x2f, 0xb5, 0x2b, 0x3b, 0xbf, 0xde, 0x83, 0xe1, 0xf7, 0x2b, 0x2f, 0x08, 0xde, 0x43,
	0x83, 0x16, 0x28, 0x0a, 0x14, 0x2d, 0x8a, 0xf6, 0x0f, 0xf0, 0xd7, 0xa6, 0xed, 0x27, 0x7f, 0x68,
	0xd3, 0x04, 0x68, 0xd0, 0x00, 0x45, 0xe8, 0x44, 0x69, 0x51, 0xf4, 0x43, 0x8b, 0x16, 0xed, 0xa7,
	0xfd, 0x10, 0x14, 0x73, 0x66, 0xe6, 0xce, 0xcc, 0x25, 0xa9, 0xa5, 0x44, 0xad, 0x6a, 0x03, 0xfe,
	0x46, 0x9e, 0x73, 0xe6, 0x9c, 0xb9, 0x73, 0xcf, 0x9c, 0x39, 0xe7, 0xcc, 0x99, 0xb9, 0x70, 0xbd,
	0xe5, 0xc6, 0x3b, 0xdd, 0xad, 0x85, 0x46, 0xd0, 0xbe, 0xdc, 0x66, 0xb1, 0xd3, 0x09, 0x83, 0xbd,
	0xcb, 0xed, 0xa0, 0xc9, 0xbc, 0xa6, 0xd3, 0x71, 0x2f, 0x77, 0x76, 0x5b, 0x97, 0x9d, 0x8e, 0x1b,
	0x5d, 0x8e, 0x43, 0xc7, 0xf5, 0x5d, 0xbf, 0x75, 0x79, 0xef, 0x69, 0xc7, 0xeb, 0xec, 0x38, 0x4f,
	0x5f, 0x6e, 0x31, 0x9f, 0x85, 0x4e, 0xcc, 0x9a, 0x0b, 0x9d, 0x30, 0x88, 0x03, 0xf2, 0xac, 0xe6,
	0xb4, 0xa0, 0x38, 0x2d, 0x24, 0x9c, 0x16, 0x3a, 0xbb, 0xad, 0x05, 0xce, 0x69, 0x41, 0x71, 0x5a,
	0x50, 0x9c, 0x1e, 0xfe, 0xa4, 0xd1, 0x87, 0x56, 0xd0, 0x0a, 0x2e, 0x23, 0xc3, 0xad, 0xee, 0x36,
	0xfe, 0xc3, 0x3f, 0xf8, 0x4b, 0x08, 0x7a, 0xf8, 0xda, 0x88, 0x5d, 0x6e, 0x38, 0xb1, 0xe3, 0x05,
	0xc3, 0x7b, 0xfc, 0xf0, 0xf2, 0x88, 0x8c, 0x9a, 0x4e, 0xec, 0x0c, 0xe7, 0xb2, 0x3a, 0x22, 0x17,
	0xd7, 0xdf, 0x66, 0x21, 0xf3, 0x1b, 0x6c, 0x38, 0xab, 0xea, 0xee, 0xb3, 0xd1, 0x82, 0x1b, 0x70,
	0xfa, 0xcb, 0x8d, 0x20, 0xe4, 0x94, 0x7d, 0x34, 0xcf, 0x68, 0x9a, 0xb6, 0xd3, 0xd8, 0x71, 0x7d,
	0x16, 0xee, 0x6b, 0x21, 0xbc, 0x03, 0x83, 0x5a, 0x5d, 0x1e, 0xd6, 0x2a, 0xec, 0xfa, 0xb1, 0xdb,
	0x66, 0x7d, 0x0d, 0x3e, 0x73, 0xaf, 0x06, 0x51, 0x63, 0x87, 0xb5, 0x9d, 0x74, 0xbb, 0xea, 0x3b,
	0x19, 0x98, 0x5f, 0xec, 0x36, 0xdd, 0x60, 0xc3, 0xed, 0x30, 0xcf, 0xf5, 0xd9, 0x66, 0x87, 0x35,
	0xc8, 0x13, 0x30, 0xd5, 0x08, 0xbc, 0x6e, 0xdb, 0x8f, 0xca, 0x99, 0xc7, 0x26, 0x2e, 0x15, 0x6b,
	0xa5, 0x83, 0x5e, 0x65, 0x6a, 0x49, 0x80, 0xa8, 0xc2, 0x91, 0x7d, 0x80, 0x6d, 0xe6, 0xc4, 0xdd,
	0xd0, 0x7d, 0x83, 0x85, 0xe5, 0xec, 0x63, 0x99, 0x4b, 0xc5, 0xda, 0x57, 0x0e, 0x7a, 0x15, 0x58,
	0x49, 0xa0, 0x77, 0x7b, 0x95, 0xe3, 0xbe, 0xff, 0x05, 0xec, 0x97, 0x66, 0x45, 0x0d, 0x61, 0xd5,
	0x57, 0x61, 0xba, 0xe6, 0x34, 0x76, 0x63, 0x16, 0xc5, 0xaa, 0xc7, 0xae, 0xef, 0xc6, 0xae, 0xe3,
	0x95, 0x33, 0x8f, 0x65, 0x2e, 0xe5, 0x45, 0x8f, 0x57, 0x05, 0x88, 0x2a, 0x1c, 0x27, 0xbb, 0xed,
	0xfa, 0xcd, 0xe0, 0x76, 0x84, 0xdd, 0x95, 0x64, 0xb7, 0x04, 0x88, 0x2a, 0x5c, 0xf5, 0x4f, 0xb3,
	0x30, 0xbf, 0xe4, 0x74, 0x9c, 0x86, 0x1b, 0xef, 0x6f, 0xc6, 0x4e, 0x4b, 0x8c, 0xca, 0x17, 0x61,
	0x2e, 0x62, 0xe1, 0x9e, 0xeb, 0xb7, 0x36, 0xdd, 0x98, 0xdd, 0x70, 0xda, 0x0c, 0x65, 0x15, 0x6b,
	0x67, 0x0f, 0x7a, 0x95, 0xb9, 0x4d, 0x1b, 0x45, 0xd3, 0xb4, 0xc4, 0x83, 0x3c, 0xef, 0x2e, 0x97,
	0x3c, 0x71, 0xa9, 0x74, 0xe5, 0xda, 0xc2, 0x71, 0x27, 0xe0, 0xc2, 0x3a, 0x27, 0xaa, 0xcb, 0x47,
	0xaf, 0xcd, 0xbc, 0xdb, 0xab, 0x3c, 0x70, 0xd0, 0xab, 0xe4, 0x39, 0x24, 0xa2, 0x42, 0x08, 0xf9,
	0x3c, 0xcc, 0xb6, 0x1d, 0xbf, 0xeb, 0x78, 0x8b, 0x1d, 0xce, 0xd8, 0xf1, 0xca, 0xf9, 0xc7, 0x32,
	0x97, 0x0a, 0x35, 0x72, 0xd0, 0xab, 0xcc, 0xae, 0x5b, 0x18, 0x9a, 0xa2, 0x24, 0x4b, 0x30, 0x7f,
	0x3b, 0x08, 0x77, 0xbd, 0xc0, 0x69, 0x2e, 0x79, 0x4e, 0x14, 0xe1, 0xa3, 0xe6, 0xf0, 0x51, 0xcf,
	0x1f, 0xf4, 0x2a, 0xf3, 0xb7, 0xd2, 0x48, 0xda, 0x4f, 0x5f, 0xfd, 0xad, 0x2c, 0x3c, 0xb8, 0xe4,
	0xc4, 0xac, 0x15, 0x84, 0x6e, 0xc3, 0xf1, 0x8e, 0xa3, 0x5f, 0xaf, 0xc1, 0x94, 0xdb, 0xee, 0x74,
	0xe3, 0x44, 0xb9, 0x36, 0xf0, 0xa5, 0x0a, 0xd0, 0xdd, 0x5e, 0x65, 0xf1, 0xb8, 0x9a, 0x85, 0x2c,
	0x9c, 0x38, 0x08, 0xa9, 0x12, 0x40, 0x76, 0x61, 0x8a, 0xf9, 0x8d, 0xa0, 0xc9, 0xc2, 0xf2, 0x04,
	0xca, 0x7a, 0x99, 0xcb, 0xba, 0x2a, 0x40, 0x77, 0x7b, 0x95, 0xda, 0x71, 0x65, 0x2d, 0x39, 0xb1,
	0xe4, 0x42, 0x95, 0x84, 0xea, 0x3f, 0x67, 0xe0, 0x02, 0x8e, 0x14, 0x1f, 0x99, 0xab, 0x51, 0xec,
	0xb6, 0x79, 0x67, 0x70, 0x68, 0xbe, 0x00, 0x33, 0x8e, 0xc7, 0xc7, 0x2c, 0xde, 0x69, 0x1b, 0x2a,
	0x76, 0x5e, 0xbe, 0xe4, 0x99, 0x45, 0x13, 0x49, 0x6d, 0x5a, 0xf2, 0x9b, 0x19, 0x80, 0x8e, 0x13,
	0x3a, 0x6d, 0x16, 0xb3, 0x50, 0x29, 0xda, 0xfa, 0xf1, 0x15, 0xed, 0xfa, 0x7e, 0x87, 0x85, 0x1b,
	0x8a, 0xe1, 0x4d, 0xc7, 0xeb, 0xb2, 0xda, 0xc7, 0x65, 0x4f, 0x20, 0x81, 0x47, 0x77, 0x7b, 0x95,
	0xb3, 0x03, 0x48, 0xa9, 0xd1, 0x97, 0xea, 0xbf, 0x64, 0x60, 0x7a, 0x29, 0x68, 0x77, 0x5c, 0x8f,
	0x89, 0x07, 0xed, 0x40, 0xa1, 0x21, 0xff, 0xcb, 0x67, 0xac, 0x1f, 0xf4, 0x2a, 0x05, 0x45, 0x73,
	0xb7, 0x57, 0x59, 0x3e, 0xf6, 0x90, 0x4b, 0x1e, 0x38, 0x44, 0x89, 0x14, 0x12, 0xc0, 0x54, 0xec,
	0x84, 0x2d, 0x26, 0xa7, 0x60, 0xb1, 0xf6, 0x0a, 0x7f, 0xc5, 0x75, 0x01, 0xba, 0xdb, 0xab, 0xac,
	0x1c, 0x57, 0xde, 0x75, 0x27, 0x6c, 0xde, 0x76, 0x42, 0x26, 0x58, 0x51, 0x25, 0xa5, 0xfa, 0x47,
	0x59, 0x28, 0x2e, 0x3b, 0xb1, 0xb3, 0xd9, 0xf1, 0xdc, 0x98, 0x3c, 0x02, 0x39, 0xa7, 0x1b, 0x07,
	0xf8, 0xb0, 0x85, 0x5a, 0xe1, 0xa0, 0x57, 0xc9, 0x2d, 0x76, 0xe3, 0x80, 0x22, 0x94, 0x54, 0x20,
	0x8f, 0xe3, 0x2f, 0xed, 0x52, 0x11, 0x27, 0x34, 0x07, 0x50, 0x01, 0x27, 0x0b, 0x00, 0x7b, 0x8e,
	0xe7, 0x36, 0x9d, 0xd8, 0x0d, 0x7c, 0xd4, 0xd1, 0x7c, 0x6d, 0x96, 0xbf, 0x87, 0x9b, 0x09, 0x94,
	0x1a, 0x14, 0x5c, 0x1c, 0xb7, 0x04, 0x38, 0x6f, 0xf3, 0x42, 0x1c, 0x37, 0x10, 0x14, 0xa1, 0xe4,
	0x79, 0x28, 0x45, 0xbc, 0x57, 0x1b, 0x81, 0xe7, 0x36, 0xf6, 0xd1, 0x36, 0x14, 0x6b, 0x8f, 0x1c,
	0xf4, 0x2a, 0xa5, 0x4d, 0x0d, 0xbe, 0xdb, 0xab, 0x14, 0xf1, 0x6f, 0x7d, 0xbf, 0xc3, 0xa8, 0xd9,
	0x80, 0x3c, 0x2d, 0xdb, 0x8b, 0x39, 0x5b, 0x9e, 0xc4, 0xf6, 0x73, 0x49, 0x7b, 0x01, 0xa6, 0x26,
	0x0d, 0xef, 0x50, 0xc4, 0x58, 0xb3, 0x3c, 0xf5, 0x58, 0xe6, 0x52, 0x46, 0x74, 0x68, 0x93, 0xb1,
	0x26, 0x45, 0x68, 0xf5, 0xbb, 0x19, 0x98, 0xc1, 0xb1, 0x4a, 0xcc, 0xed, 0xa7, 0xa1, 0xc4, 0x57,
	0xf2, 0x88, 0xc5, 0xa6, 0xa9, 0x95, 0xda, 0x57, 0x5a, 0xd6, 0x28, 0x6a, 0xd2, 0x91, 0x65, 0x38,
	0xc3, 0xff, 0x76, 0xa4, 0xbd, 0xc1, 0xb6, 0xc2, 0x7a, 0x94, 0x65, 0xdb, 0x33, 0xbc, 0xed, 0x86,
	0x81, 0xa7, 0x7d, 0x2d, 0xaa, 0x7f, 0x91, 0x81, 0x73, 0xcb, 0x4e, 0xcc, 0xea, 0x6e, 0x9b, 0xbd,
	0xdf, 0x4d, 0x57, 0x15, 0x26, 0xd9, 0x9d, 0x8e, 0xe3, 0x37, 0x51, 0x2b, 0x0a, 0x35, 0x38, 0xe8,
	0x55, 0x26, 0xaf, 0x22, 0x84, 0x4a, 0x4c, 0xf5, 0x07, 0x59, 0x20, 0xcb, 0x8c, 0x75, 0x12, 0x63,
	0xb3, 0xe6, 0xec, 0xb3, 0x90, 0x3c, 0x06, 0x39, 0x5f, 0x0f, 0xee, 0xb4, 0x1c, 0xa0, 0x1c, 0x0e,
	0x0a, 0x62, 0xc8, 0x65, 0xc8, 0xc5, 0xfb, 0x1d, 0x35, 0x84, 0x1f, 0x51, 0x14, 0x5c, 0x23, 0xee,
	0xf6, 0x2a, 0xa5, 0x1b, 0x37, 0x90, 0x91, 0x68, 0xc0, 0x09, 0xc9, 0x1b, 0x96, 0x09, 0x9a, 0x40,
	0x13, 0xf4, 0xc2, 0xf1, 0x4d, 0x90, 0x14, 0x90, 0x58, 0x16, 0xa1, 0xf3, 0xda, 0xf6, 0x98, 0x46,
	0x86, 0x6b, 0xa5, 0xeb, 0x77, 0xba, 0x31, 0x36, 0x89, 0xca, 0x39, 0x7c, 0x41, 0xa8, 0x95, 0xab,
	0x1a, 0x4c, 0x4d, 0x9a, 0xea, 0x1f, 0x4f, 0xc0, 0xbc, 0x35, 0x30, 0xf8, 0x96, 0xdf, 0xce, 0xc0,
	0xb4, 0x13, 0x36, 0x76, 0xdc, 0x98, 0x35, 0xe2, 0x6e, 0xc8, 0xf0, 0x5d, 0x97, 0xae, 0xac, 0x1d,
	0xff, 0x39, 0xfa, 0x07, 0xbf, 0x76, 0x4e, 0x0e, 0xe6, 0xf4, 0xa2, 0x21, 0x89, 0x5a, 0x72, 0xef,
	0x35, 0xfc, 0xcb, 0x37, 0x6e, 0xf0, 0x9f, 0xc6, 0xf0, 0x3f, 0x09, 0xc5, 0x2d, 0x27, 0x6e, 0xec,
	0x6c, 0xba, 0x6f, 0x30, 0x69, 0x25, 0x66, 0x0e, 0x7a, 0x95, 0x62, 0x4d, 0x01, 0xa9, 0xc6, 0xa3,
	0xe6, 0x74, 0x82, 0xc6, 0x4e, 0x24, 0xad, 0x84, 0xd0, 0x1c, 0x84, 0x50, 0x89, 0xe1, 0x5e, 0x8f,
	0xb6, 0x2a, 0x38, 0xb9, 0xd1, 0x5a, 0xe4, 0x85, 0xd7, 0x73, 0xd3, 0x46, 0xd1, 0x34, 0x2d, 0xb7,
	0x6b, 0x6e, 0xb4, 0xc9, 0x5e, 0x47, 0x13, 0x51, 0x10, 0x76, 0x6d, 0x95, 0x03, 0xa8, 0x80, 0x73,
	0xb3, 0xd0, 0xea, 0x74, 0x23, 0x34, 0x0b, 0xd2, 0x4e, 0x5d, 0xeb, 0x74, 0x23, 0x8a, 0x50, 0xae,
	0xa0, 0x5e, 0x10, 0x45, 0xe5, 0x82, 0xad, 0xa0, 0x6b, 0x41, 0x14, 0x51, 0xc4, 0x54, 0xd7, 0x60,
	0x76, 0xd9, 0x6d, 0x33, 0x3f, 0x72, 0x03, 0x1f, 0x97, 0x1d, 0xf2, 0x10, 0x4c, 0xec, 0xb2, 0x7d,
	0xa9, 0xd3, 0x53, 0x07, 0xbd, 0xca, 0xc4, 0x8b, 0x6c, 0x9f, 0x72, 0x18, 0xef, 0xcd, 0x1e, 0xa7,
	0x91, 0xe3, 0x89, 0xbd, 0x11, 0x6b, 0x95, 0x80, 0x57, 0xe7, 0x60, 0xe6, 0xaa, 0x1f, 0xb1, 0xf6,
	0x96, 0xc7, 0x68, 0xd7, 0x63, 0x51, 0xf5, 0x29, 0x98, 0x56, 0x00, 0xd4, 0x8c, 0x47, 0x20, 0xb7,
	0xe5, 0x44, 0x4c, 0xae, 0x20, 0xd8, 0xdd, 0x9a, 0x13, 0x31, 0x8a, 0xd0, 0xea, 0xd7, 0xa1, 0xb4,
	0x12, 0x84, 0xac, 0xe1, 0x44, 0xf1, 0x4b, 0x5b, 0xaf, 0x91, 0x47, 0xcd, 0x9e, 0x94, 0x64, 0xe7,
	0x75, 0x6f, 0xae, 0x00, 0x78, 0x6c, 0x8f, 0x79, 0xab, 0x7e, 0x93, 0xdd, 0x91, 0x86, 0x9f, 0xa8,
	0xe5, 0x75, 0x2d, 0xc1, 0x50, 0x83, 0xaa, 0xfa, 0xeb, 0x29, 0x98, 0x53, 0x22, 0xb8, 0x77, 0xc9,
	0xfb, 0xb4, 0x00, 0xc0, 0x7d, 0x7c, 0x69, 0x8b, 0x85, 0x34, 0x9c, 0x26, 0xf5, 0x04, 0x4a, 0x0d,
	0x0a, 0xf2, 0x0c, 0x4c, 0x8b, 0x25, 0x4a, 0xb6, 0x10, 0x83, 0x71, 0x86, 0xab, 0x62, 0xdd, 0x80,
	0x53, 0x8b, 0x8a, 0x7b, 0x94, 0x4d, 0x27, 0x66, 0x9c, 0xcf, 0x4a, 0x10, 0xb6, 0x9d, 0x58, 0x3a,
	0x4a, 0xe8, 0x51, 0x2a, 0x5b, 0x29, 0x30, 0x34, 0x45, 0xc9, 0x7b, 0xd8, 0x54, 0x2f, 0x49, 0xcd,
	0x4b, 0xec, 0x61, 0xf2, 0xea, 0x22, 0x6a, 0x50, 0x70, 0xfa, 0x90, 0x75, 0x42, 0x16, 0x45, 0x41,
	0x18, 0x95, 0xf3, 0x9a, 0x9e, 0x26, 0x50, 0x6a, 0x50, 0x10, 0x0f, 0x0a, 0xdb, 0x21, 0x7b, 0x9d,
	0x8f, 0x06, 0x2a, 0x5a, 0xe9, 0x4a, 0xed, 0xf8, 0x53, 0x75, 0x45, 0x72, 0xaa, 0x4d, 0x73, 0x87,
	0x44, 0xfd, 0xa3, 0x89, 0x04, 0xbe, 0x06, 0xec, 0x04, 0xa1, 0xfb, 0x46, 0xe0, 0x4b, 0xad, 0xc5,
	0x35, 0xe0, 0xba, 0x00, 0x51, 0x85, 0x23, 0x2b, 0x40, 0x1a, 0x81, 0xbf, 0xed, 0x36, 0x79, 0x14,
	0xb9, 0xea, 0xc7, 0x2c, 0xe4, 0x6e, 0x78, 0x01, 0x5b, 0x5c, 0x38, 0xe8, 0x55, 0xc8, 0x52, 0x1f,
	0x96, 0x0e, 0x68, 0x41, 0xfe, 0x6f, 0x06, 0xe6, 0x1b, 0x41, 0xd7, 0x8f, 0xc3, 0xfd, 0x95, 0x20,
	0xbc, 0x1e, 0xf0, 0x09, 0xb6, 0x5f, 0x2e, 0xe2, 0xe0, 0xff, 0x57, 0xee, 0x8f, 0x2f, 0xa5, 0x91,
	0x63, 0x39, 0x33, 0x82, 0x85, 0xe4, 0x49, 0xfb, 0x25, 0x93, 0xff, 0x93, 0x81, 0xb9, 0xa6, 0x35,
	0xe5, 0xa2, 0x32, 0xa0, 0x7d, 0xbc, 0x3e, 0x86, 0x7d, 0xb4, 0x18, 0xd6, 0x1e, 0x94, 0xd3, 0x60,
	0xce, 0x86, 0x47, 0x34, 0x2d, 0x99, 0xfb, 0x91, 0x5b, 0x32, 0x12, 0x2c, 0x97, 0xf0, 0xd5, 0xaf,
	0x1c, 0xbf, 0x17, 0x66, 0x4c, 0x29, 0x5e, 0xbf, 0x82, 0xd0, 0x44, 0x0a, 0xa1, 0x70, 0x61, 0x5b,
	0xce, 0xc0, 0xa5, 0xc0, 0xf7, 0x59, 0x83, 0x5b, 0x3b, 0xf4, 0x33, 0xa6, 0xf1, 0x9d, 0x3c, 0x7c,
	0xd0, 0xab, 0x5c, 0x58, 0x19, 0x48, 0x41, 0x87, 0xb4, 0x24, 0x97, 0xa0, 0xa0, 0x30, 0xe5, 0x19,
	0xb4, 0x94, 0x42, 0xf9, 0x24, 0x8c, 0x26, 0xd8, 0xea, 0xff, 0xcf, 0x40, 0xa2, 0x93, 0xbc, 0x99,
	0xab, 0x14, 0x4b, 0xc4, 0xbd, 0xd8, 0x2c, 0x51, 0xa7, 0x04, 0x4b, 0xbe, 0x06, 0xb9, 0xae, 0xef,
	0xc6, 0x72, 0xae, 0xaf, 0x72, 0xc3, 0xf7, 0x8a, 0xef, 0xa2, 0xdf, 0xfb, 0xdc, 0x71, 0x55, 0x85,
	0x77, 0x83, 0x22, 0xdb, 0xea, 0x8f, 0xb2, 0x50, 0xbc, 0xee, 0xb2, 0x90, 0x2f, 0x5e, 0xfb, 0xa3,
	0x3a, 0x49, 0x7b, 0x50, 0x6a, 0x85, 0x41, 0xb7, 0x83, 0xa6, 0x4e, 0x85, 0x2b, 0x5f, 0x3a, 0xfe,
	0xdb, 0x43, 0x3e, 0xda, 0x45, 0xbc, 0xa6, 0x79, 0x53, 0x53, 0x10, 0xf1, 0xa0, 0xe8, 0xc6, 0xac,
	0x8d, 0xff, 0xd0, 0x88, 0x9d, 0x80, 0x54, 0x5c, 0x64, 0x57, 0x15, 0x57, 0xaa, 0x05, 0x70, 0x6b,
	0xeb, 0x07, 0xb1, 0xbb, 0xed, 0x0a, 0x37, 0x49, 0x06, 0xd2, 0x68, 0x6d, 0x6f, 0x18, 0x70, 0x6a,
	0x51, 0x55, 0x5f, 0x85, 0x41, 0x21, 0xd5, 0x08, 0x0e, 0xdb, 0xe3, 0xf6, 0x12, 0x97, 0x64, 0x07,
	0xac, 0x65, 0xee, 0x9d, 0x0c, 0xcc, 0xaf, 0xb6, 0x9d, 0x16, 0x7b, 0x1f, 0xa6, 0x7d, 0xb0, 0x5f,
	0x43, 0xd2, 0x3e, 0x3f, 0xca, 0x42, 0x5e, 0x8c, 0xea, 0x47, 0x61, 0x32, 0x8a, 0x43, 0xd7, 0x6f,
	0x0d, 0x1c, 0x0a, 0x89, 0x23, 0x1f, 0xd7, 0x96, 0x5a, 0x2c, 0xaf, 0x73, 0x92, 0xac, 0xdf, 0x5a,
	0xbf, 0x0a, 0x39, 0x6e, 0xe0, 0xe5, 0xa2, 0x76, 0x9d, 0xb3, 0xe2, 0xfa, 0x3d, 0xfe, 0xfc, 0xe0,
	0x5c, 0x49, 0x07, 0x8a, 0x4e, 0xab, 0x15, 0xb2, 0x96, 0x13, 0x2b, 0x0d, 0xa0, 0x5c, 0x63, 0x16,
	0x15, 0x70, 0x9c, 0x98, 0x20, 0x61, 0x42, 0xb5, 0x10, 0xf2, 0x51, 0x98, 0x6a, 0xba, 0xdc, 0x47,
	0x68, 0xc8, 0xf5, 0x13, 0x9d, 0x3b, 0x69, 0x45, 0x15, 0xaa, 0xfa, 0xc3, 0x2c, 0xe4, 0x31, 0x9d,
	0x44, 0xbe, 0x0e, 0x05, 0x2e, 0x94, 0x47, 0x42, 0x38, 0xa4, 0xa5, 0x2b, 0x9f, 0x5a, 0x10, 0x49,
	0xc5, 0x05, 0x33, 0xa9, 0xa8, 0x67, 0x02, 0xa7, 0x5e, 0xd8, 0x7b, 0x7a, 0xe1, 0xa5, 0xad, 0xd7,
	0x58, 0x23, 0x5e, 0x67, 0xb1, 0xa3, 0x9d, 0x17, 0x0d, 0xa3, 0x09, 0x57, 0xc2, 0x20, 0x17, 0xf1,
	0x05, 0x3a, 0x8b, 0xdc, 0x97, 0xc6, 0xcc, 0x7f, 0x09, 0x13, 0xad, 0xde, 0x3a, 0xae, 0xd0, 0xc8,
	0x9e, 0xb4, 0xb9, 0x66, 0x38, 0x71, 0x37, 0x92, 0x53, 0xfb, 0xea, 0xb8, 0x82, 0x90, 0x59, 0x6d,
	0x56, 0x8a, 0x9a, 0x14, 0xff, 0xa9, 0x14, 0x52, 0xfd, 0x45, 0x16, 0xce, 0x20, 0x1d, 0x0f, 0xe6,
	0xb7, 0xba, 0xae, 0xd7, 0x64, 0xe1, 0x29, 0x0c, 0x66, 0xc7, 0x1a, 0xcc, 0x1b, 0x63, 0x3e, 0xa3,
	0xd1, 0xf7, 0xa1, 0xe3, 0x7a, 0x27, 0x35, 0xae, 0x1b, 0x27, 0x28, 0xf3, 0xf0, 0x21, 0xfe, 0xd7,
	0x2c, 0x3c, 0x94, 0x6e, 0xb2, 0x14, 0xf8, 0x4d, 0x17, 0x13, 0x1d, 0x8b, 0x32, 0x44, 0x12, 0x76,
	0xe0, 0x93, 0xa9, 0x10, 0xe9, 0xd1, 0xa1, 0x0d, 0x31, 0xa9, 0x21, 0x82, 0xa6, 0xb5, 0xe4, 0xd1,
	0x84, 0x35, 0x7b, 0xc6, 0xee, 0xc8, 0xdd, 0x5e, 0x65, 0x40, 0xaa, 0x7f, 0x21, 0xe1, 0x64, 0x77,
	0x97, 0x84, 0x40, 0x3c, 0x27, 0x8a, 0xeb, 0xa1, 0xe3, 0x47, 0x42, 0x92, 0x2b, 0xcd, 0x7e, 0xe9,
	0xca, 0x27, 0x46, 0x53, 0x03, 0xde, 0x42, 0xf8, 0x88, 0x6b, 0x7d, 0x9c, 0xe8, 0x00, 0xee, 0xe4,
	0x63, 0x30, 0x19, 0x32, 0x27, 0x0a, 0x7c, 0x99, 0xca, 0x49, 0x86, 0x92, 0x22, 0x94, 0x4a, 0x2c,
	0x37, 0x88, 0x6d, 0x16, 0x45, 0x4e, 0x8b, 0xa9, 0x9c, 0x8d, 0x32, 0x88, 0xeb, 0x02, 0x4c, 0x15,
	0xbe, 0xfa, 0x77, 0x19, 0x38, 0x97, 0x1e, 0xbc, 0x35, 0x37, 0x8a, 0xc9, 0xab, 0x7d, 0xca, 0xbd,
	0x30, 0xda, 0x53, 0xf1, 0xd6, 0xa8, 0xda, 0x67, 0xa4, 0xd0, 0x82, 0x82, 0x18, 0x8a, 0x1d, 0x40,
	0x9e, 0xaf, 0x9d, 0xca, 0x1d, 0x78, 0xe1, 0xe4, 0xb4, 0x4c, 0xaf, 0x85, 0x7c, 0x9d, 0x8e, 0xa8,
	0x90, 0x53, 0xfd, 0x6b, 0xe8, 0x7f, 0x4e, 0x95, 0xef, 0xe7, 0x3d, 0xda, 0x08, 0x83, 0x66, 0xb7,
	0x11, 0xa7, 0xf3, 0xfd, 0xcb, 0x36, 0x8a, 0xa6, 0x69, 0xb9, 0x9b, 0x68, 0x80, 0x6e, 0xb2, 0x30,
	0x52, 0x6e, 0x62, 0x56, 0xbb, 0x89, 0xcb, 0x03, 0x29, 0xe8, 0x90, 0x96, 0x32, 0x06, 0x73, 0xa2,
	0xa0, 0x1b, 0x36, 0x44, 0x6a, 0xcb, 0x8e, 0xc1, 0x9c, 0xcd, 0x04, 0x43, 0x53, 0x94, 0xe4, 0x69,
	0x3b, 0x9f, 0x96, 0xd3, 0x29, 0xbb, 0xa1, 0xb9, 0x34, 0x0f, 0x0a, 0x5e, 0xd0, 0x10, 0x19, 0xc7,
	0xfc, 0xd1, 0xc2, 0x2a, 0xce, 0xc6, 0xf0, 0xee, 0x9d, 0xd8, 0x59, 0x93, 0x9c, 0x84, 0x8b, 0xaa,
	0xfe, 0xd1, 0x44, 0x02, 0xf9, 0x2f, 0x90, 0x8b, 0x9d, 0x68, 0x57, 0x2a, 0xe6, 0x0b, 0x38, 0x89,
	0x9d, 0x68, 0xf7, 0x6e, 0xaf, 0xf2, 0xfc, 0x71, 0x57, 0xc6, 0xf5, 0x35, 0xce, 0x81, 0x22, 0x5f,
	0xd2, 0x86, 0x62, 0x80, 0xa6, 0xd4, 0xdd, 0x63, 0x18, 0xb8, 0x15, 0x6b, 0x2f, 0xf1, 0x35, 0xf8,
	0x25, 0x05, 0x1c, 0x4b, 0x12, 0x8b, 0x43, 0xb7, 0x41, 0xb5, 0x84, 0xbe, 0x28, 0xbb, 0x30, 0x52,
	0x94, 0xfd, 0x04, 0x4c, 0xb5, 0x9d, 0x3b, 0x68, 0x31, 0x8a, 0x3a, 0xb6, 0x5c, 0x17, 0x20, 0xaa,
	0x70, 0xe4, 0x49, 0x28, 0xb6, 0x9d, 0x3b, 0xa8, 0xb6, 0x3c, 0xf8, 0x4a, 0xd2, 0x3c, 0xeb, 0x0a,
	0x48, 0x35, 0x9e, 0x7c, 0x03, 0xa6, 0x9d, 0x46, 0x83, 0x45, 0xd1, 0x3a, 0x8b, 0x77, 0x82, 0x26,
	0x86, 0x49, 0xc5, 0xda, 0x7f, 0xc6, 0xd4, 0x93, 0x01, 0x3f, 0x42, 0xca, 0xbd, 0x7f, 0x73, 0x74,
	0x41, 0x70, 0x42, 0xa3, 0x6a, 0x49, 0xe3, 0x5d, 0x75, 0xba, 0x71, 0xb0, 0xd9, 0x70, 0x3c, 0x11,
	0x21, 0x15, 0x44, 0x57, 0x17, 0x15, 0x90, 0x6a, 0x3c, 0xf9, 0x4e, 0x46, 0x68, 0xb8, 0xd0, 0x63,
	0x8c, 0xe7, 0x67, 0x50, 0xf1, 0x96, 0x8f, 0xaf, 0x78, 0x9a, 0x57, 0x7a, 0x9e, 0xe0, 0xea, 0x96,
	0x92, 0xc7, 0x63, 0x2a, 0xb4, 0x25, 0x2c, 0x8c, 0xca, 0xb3, 0x3a, 0xa6, 0xaa, 0x4b, 0x18, 0x4d,
	0xb0, 0xe4, 0x3a, 0x4c, 0x47, 0x8c, 0x47, 0x3c, 0x72, 0x5c, 0xe7, 0x70, 0x5c, 0x3f, 0xca, 0xc7,
	0x75, 0xd3, 0x80, 0xdf, 0xed, 0x55, 0xce, 0x98, 0xff, 0x85, 0xb7, 0x6f, 0xb6, 0xe4, 0x6f, 0xdd,
	0xd9, 0x0a, 0xc2, 0x98, 0x35, 0xcb, 0x67, 0x70, 0x84, 0xf0, 0xad, 0x2f, 0x0a, 0x10, 0x55, 0x38,
	0x52, 0x81, 0x7c, 0x70, 0xdb, 0x67, 0x61, 0x79, 0x5e, 0xa7, 0xaf, 0x5e, 0xe2, 0x00, 0x2a, 0xe0,
	0x83, 0x77, 0xee, 0xc8, 0xd1, 0x76, 0xee, 0xc8, 0x35, 0x98, 0xf4, 0x9c, 0x2d, 0xca, 0xb6, 0xcb,
	0x67, 0x71, 0xe8, 0x1f, 0x37, 0xac, 0xfb, 0x02, 0x5f, 0xfc, 0xb4, 0xa3, 0x42, 0x99, 0xd4, 0x03,
	0xe1, 0x5d, 0xae, 0x61, 0x33, 0x2a, 0x9b, 0x57, 0x7f, 0x5c, 0x84, 0x0b, 0x83, 0x97, 0x7a, 0xf2,
	0x2c, 0x4c, 0x6f, 0x7b, 0x4e, 0xbc, 0xe2, 0x7a, 0xe6, 0x46, 0x6a, 0x92, 0x11, 0x5d, 0x31, 0x70,
	0xd4, 0xa2, 0x24, 0xcf, 0x9b, 0x0a, 0x62, 0x98, 0xd3, 0x0b, 0xb2, 0xed, 0x40, 0x33, 0xa8, 0xff,
	0xa7, 0xb7, 0x15, 0x26, 0x46, 0xdc, 0x56, 0xb8, 0x0c, 0xc5, 0x28, 0xee, 0x36, 0xf7, 0x0d, 0xdb,
	0x39, 0x2f, 0x1b, 0x15, 0x37, 0x15, 0x82, 0x6a, 0x1a, 0xf2, 0x05, 0x98, 0xd9, 0x62, 0x51, 0x8c,
	0xcf, 0x8f, 0x8d, 0x26, 0xed, 0x8d, 0xbc, 0x9a, 0x89, 0xa4, 0x36, 0x2d, 0x6f, 0xdc, 0x09, 0x59,
	0xd3, 0x6d, 0xc4, 0x81, 0x08, 0x1a, 0xa7, 0xec, 0xc6, 0x1b, 0x26, 0x92, 0xda, 0xb4, 0xbc, 0xb1,
	0xcb, 0x63, 0x28, 0xca, 0x3a, 0x01, 0x36, 0x2e, 0xd8, 0x8d, 0x57, 0x4d, 0x24, 0xb5, 0x69, 0xc9,
	0x73, 0x90, 0xef, 0xec, 0x38, 0x11, 0x93, 0xf9, 0xa5, 0x8f, 0xa9, 0x25, 0x73, 0x83, 0x03, 0xef,
	0xf6, 0x2a, 0xe7, 0xd3, 0x2f, 0x14, 0x11, 0x54, 0x34, 0xe2, 0xe1, 0x69, 0x18, 0xdc, 0x56, 0x16,
	0x29, 0xf1, 0x22, 0x69, 0x70, 0x3b, 0xa2, 0x88, 0xe1, 0x14, 0x8d, 0xc0, 0x8b, 0xd0, 0x06, 0x19,
	0x14, 0x4b, 0x81, 0x17, 0x51, 0xc4, 0x90, 0xa7, 0xa0, 0xb0, 0xed, 0x7a, 0x0c, 0x13, 0xd8, 0xd3,
	0x48, 0x95, 0xb8, 0x0b, 0x2b, 0x12, 0x4e, 0x13, 0x0a, 0xee, 0xf8, 0xb4, 0x85, 0x15, 0x9c, 0x11,
	0x5b, 0x62, 0xca, 0xf1, 0x91, 0x66, 0x50, 0x62, 0xf9, 0xa0, 0x88, 0x79, 0xdb, 0x94, 0x46, 0x53,
	0x4c, 0xed, 0x64, 0x50, 0xea, 0x26, 0x92, 0xda, 0xb4, 0x5c, 0xe7, 0x92, 0xf7, 0xb3, 0xc9, 0x67,
	0x00, 0x4e, 0xf5, 0x8c, 0xd6, 0xb9, 0x9a, 0x85, 0xa5, 0x29, 0x6a, 0xf2, 0x4d, 0x28, 0x32, 0x95,
	0xfb, 0xc7, 0x09, 0x3e, 0x96, 0xf7, 0x3c, 0x78, 0xe7, 0x58, 0x18, 0xd5, 0x04, 0x44, 0xb5, 0x44,
	0x72, 0x8b, 0xeb, 0xae, 0x13, 0xc6, 0xb8, 0xaa, 0xcc, 0x1f, 0xd9, 0x0f, 0x9d, 0x11, 0x3a, 0x2e,
	0x19, 0x50, 0xcd, 0x8b, 0x6c, 0xc3, 0x6c, 0x23, 0x68, 0x77, 0x3c, 0x96, 0x78, 0xb9, 0xe4, 0xc8,
	0xdc, 0xd1, 0x24, 0x2f, 0x59, 0x5c, 0x68, 0x8a, 0x2b, 0xf9, 0x1f, 0x19, 0x80, 0x86, 0xf2, 0xb6,
	0xa3, 0xf2, 0x59, 0xf4, 0x0c, 0x37, 0x4f, 0xce, 0x33, 0x4c, 0x3c, 0x79, 0x1d, 0x74, 0x25, 0xa0,
	0x88, 0x1a, 0xa2, 0xab, 0x3f, 0xcf, 0xc2, 0x2c, 0xb6, 0xd6, 0xf1, 0xc7, 0x67, 0xac, 0xf8, 0xa3,
	0x9a, 0x8a, 0x3f, 0x88, 0x4d, 0xfd, 0x61, 0xd0, 0x71, 0x78, 0xd0, 0xf1, 0x97, 0x19, 0x28, 0xe2,
	0x88, 0x9d, 0x42, 0xa4, 0xd1, 0xb4, 0x23, 0x8d, 0x2f, 0x8d, 0xa9, 0x4f, 0xc3, 0xc2, 0x8b, 0x2c,
	0xcc, 0x20, 0x5e, 0xa5, 0xda, 0x4e, 0x21, 0x39, 0xd0, 0xb6, 0x92, 0x03, 0x2f, 0x8e, 0xf9, 0x60,
	0x66, 0x8e, 0x70, 0x60, 0x66, 0xa0, 0x9b, 0xca, 0x0c, 0xac, 0x9f, 0x94, 0xc0, 0xc3, 0xd3, 0x02,
	0xff, 0x98, 0x95, 0xee, 0x85, 0xa2, 0xd7, 0x73, 0xf2, 0x79, 0x6b, 0x4e, 0x7e, 0x22, 0x35, 0x27,
	0x1f, 0x1e, 0xdc, 0xea, 0x94, 0xe7, 0xe6, 0xc4, 0x29, 0xcd, 0xcd, 0xdc, 0xa8, 0x73, 0x33, 0x7f,
	0x8f, 0xb9, 0xf9, 0x5e, 0x06, 0xe6, 0xad, 0x91, 0x3b, 0x85, 0x39, 0xea, 0xd9, 0x73, 0xf4, 0xda,
	0x09, 0x69, 0xd6, 0x90, 0xb9, 0x9a, 0xe4, 0xf2, 0x14, 0x1d, 0xed, 0xfa, 0x1f, 0xb8, 0x5c, 0x9e,
	0xd1, 0xf7, 0x53, 0xcb, 0xe5, 0x99, 0x32, 0x0f, 0x9f, 0xb4, 0xff, 0xa4, 0x72, 0x79, 0x46, 0x13,
	0x3d, 0x6f, 0x9f, 0xb3, 0xe6, 0xed, 0xa5, 0xd4, 0xbc, 0x2d, 0x0f, 0x6a, 0xf3, 0xe1, 0x8a, 0x3a,
	0x62, 0x1a, 0xcf, 0x18, 0xbc, 0x0f, 0x5e, 0x1a, 0xcf, 0xe8, 0xfc, 0x90, 0xb9, 0xfb, 0x76, 0xb6,
	0xff, 0x39, 0x31, 0x9e, 0x7f, 0x1a, 0x4a, 0x7b, 0x46, 0xf2, 0x2d, 0xa3, 0xf3, 0x5e, 0x66, 0xc6,
	0xcd, 0xa4, 0xc1, 0x54, 0x19, 0x8b, 0x1a, 0xa1, 0xdb, 0xc1, 0xd4, 0x57, 0xd6, 0x48, 0x95, 0x69,
	0x30, 0x35, 0x69, 0x78, 0x93, 0x38, 0x74, 0x5b, 0x2d, 0xb9, 0xc9, 0x37, 0xa1, 0x9b, 0xd4, 0x35,
	0x98, 0x9a, 0x34, 0xe4, 0x19, 0x98, 0xb6, 0xaa, 0xd4, 0x8c, 0x8d, 0x41, 0xab, 0x3a, 0xcd, 0xa2,
	0xd2, 0x39, 0x80, 0xfc, 0xe0, 0x1c, 0x40, 0xf5, 0xdf, 0xf2, 0xf0, 0x91, 0x01, 0x93, 0xb2, 0x25,
	0x97, 0x53, 0xf2, 0x59, 0x15, 0xe1, 0x89, 0x91, 0xf8, 0x4f, 0xe9, 0x08, 0xef, 0x8c, 0x41, 0x6c,
	0x05, 0x77, 0x4f, 0x41, 0xc1, 0xc1, 0x12, 0x61, 0xd6, 0xc4, 0x21, 0x29, 0x68, 0x05, 0x58, 0x94,
	0x70, 0x9a, 0x50, 0x90, 0x2b, 0x00, 0xea, 0x77, 0x6d, 0x5f, 0xa5, 0x29, 0x95, 0x19, 0x5c, 0x4c,
	0x30, 0xd4, 0xa0, 0x22, 0x5f, 0xd5, 0x6d, 0x16, 0xe3, 0x63, 0x4c, 0xb5, 0x59, 0x93, 0xf7, 0x62,
	0x4c, 0x0d, 0x6e, 0x76, 0x10, 0x34, 0x75, 0x82, 0x41, 0xd0, 0xcb, 0x30, 0xc5, 0xfc, 0x26, 0xb2,
	0x2d, 0x1c, 0x99, 0x6d, 0x49, 0x54, 0x19, 0x37, 0x45, 0x76, 0x4f, 0xf2, 0x21, 0x31, 0x4c, 0x85,
	0x2c, 0xea, 0x7a, 0x71, 0x54, 0x2e, 0xe2, 0xf4, 0x59, 0x3d, 0x81, 0x62, 0x71, 0x8a, 0x1c, 0xb5,
	0xa5, 0x10, 0xff, 0x23, 0xaa, 0x44, 0x91, 0xc7, 0x21, 0xcf, 0xc2, 0x30, 0x08, 0x31, 0x7a, 0x37,
	0x76, 0x8e, 0xaf, 0x72, 0x20, 0x15, 0xb8, 0x74, 0xfa, 0xa4, 0x34, 0x7a, 0xfa, 0xa4, 0x9d, 0x64,
	0x42, 0xa6, 0xed, 0xf4, 0x89, 0xce, 0x82, 0x68, 0x1a, 0x3b, 0xdf, 0x32, 0x73, 0xef, 0x7c, 0x4b,
	0xf5, 0x7f, 0x42, 0xca, 0x1b, 0x4c, 0xd6, 0x22, 0xf2, 0x39, 0xc8, 0x47, 0x5c, 0xa7, 0xa5, 0xc6,
	0x3f, 0xae, 0x1e, 0x0c, 0x15, 0x3d, 0x89, 0xd1, 0x0c, 0xaf, 0xb3, 0xc5, 0xa8, 0x68, 0x61, 0x77,
	0x23, 0x3b, 0x42, 0xda, 0xe7, 0x7f, 0x65, 0x00, 0x9a, 0xa2, 0x8e, 0x55, 0x2f, 0xaf, 0xaf, 0x9c,
	0xe8, 0xf2, 0xaa, 0x26, 0xa7, 0x9e, 0x4e, 0xcb, 0x89, 0x40, 0x6a, 0x08, 0x27, 0xbf, 0x91, 0x81,
	0x59, 0xc5, 0x51, 0xf6, 0x27, 0x77, 0x3f, 0xfb, 0x93, 0xa4, 0x43, 0xea, 0x96, 0x50, 0x9a, 0xea,
	0x04, 0x79, 0x3b, 0x03, 0xc5, 0xae, 0x13, 0xcb, 0x2e, 0xe5, 0xef, 0x67, 0x97, 0x92, 0x97, 0xf5,
	0xca, 0x62, 0x5d, 0xf6, 0x46, 0x8b, 0xc6, 0x01, 0x6a, 0xe8, 0x73, 0x1e, 0xbc, 0x37, 0x93, 0xa7,
	0x32, 0x40, 0x4b, 0x96, 0x50, 0x9a, 0xea, 0x04, 0x2a, 0x51, 0x27, 0x0c, 0x9a, 0xb2, 0x4f, 0x53,
	0xa7, 0xa2, 0x44, 0x1b, 0x89, 0x40, 0x6a, 0x08, 0xb7, 0xed, 0x66, 0xe1, 0xbe, 0x26, 0x8f, 0x8a,
	0xf7, 0x25, 0x79, 0xf4, 0x8c, 0x5a, 0xef, 0x84, 0x59, 0xbb, 0x98, 0x5e, 0xef, 0x66, 0xd4, 0xc0,
	0x58, 0x8b, 0x5d, 0x2a, 0xe5, 0x54, 0x3a, 0x91, 0x94, 0xd3, 0x20, 0xff, 0xf5, 0x5e, 0x29, 0x27,
	0xf2, 0x29, 0x28, 0xb1, 0x3d, 0xc7, 0x13, 0x1b, 0x4c, 0x91, 0xb4, 0x85, 0x89, 0x63, 0xb8, 0x12,
	0x78, 0x4d, 0x16, 0x52, 0x93, 0xa4, 0xfa, 0x4e, 0x31, 0x15, 0xa8, 0x1d, 0xd7, 0x0f, 0xa2, 0x70,
	0xa1, 0xc9, 0xb6, 0x9d, 0xae, 0x17, 0xa7, 0x4e, 0x37, 0x59, 0x5b, 0x98, 0x03, 0x29, 0xe8, 0x90,
	0x96, 0x69, 0xdf, 0x6a, 0x62, 0x04, 0xdf, 0x8a, 0x41, 0x0e, 0xbd, 0x54, 0x61, 0x29, 0xc6, 0x88,
	0x01, 0xad, 0x03, 0x06, 0xa2, 0x78, 0x97, 0x83, 0x28, 0xb2, 0x27, 0x5d, 0xb9, 0xf1, 0xe3, 0xfa,
	0x2d, 0x69, 0x06, 0xc6, 0xc8, 0x9c, 0x18, 0x26, 0x50, 0x8a, 0xd3, 0xbb, 0x48, 0xae, 0xdf, 0xa2,
	0x89, 0x28, 0xe2, 0xc0, 0x44, 0xd7, 0x89, 0xe5, 0x24, 0x1f, 0xa3, 0x76, 0x51, 0x58, 0x38, 0x29,
	0x0c, 0xcb, 0x9e, 0x5f, 0x59, 0xac, 0x53, 0xce, 0x9b, 0x3f, 0x99, 0xb2, 0x30, 0x72, 0x0a, 0x8f,
	0xf1, 0x64, 0x7d, 0x07, 0xe3, 0xc4, 0x93, 0x29, 0x30, 0x4d, 0x44, 0xf1, 0xf7, 0xc6, 0x0d, 0x89,
	0x9c, 0xd7, 0x63, 0xbc, 0x37, 0x69, 0x9a, 0xcc, 0xf7, 0xc6, 0x41, 0x14, 0xd9, 0x5b, 0xbb, 0xd4,
	0x70, 0xdf, 0x77, 0xa9, 0x43, 0x28, 0x44, 0x8d, 0x1d, 0xd6, 0xec, 0x7a, 0x4c, 0xd6, 0x9b, 0x8e,
	0xbc, 0x35, 0x29, 0x37, 0x8d, 0xb5, 0x40, 0x6e, 0x8a, 0x25, 0x2f, 0xed, 0x4b, 0x2b, 0x08, 0x4d,
	0xe4, 0x68, 0x9f, 0x7f, 0x7a, 0xc8, 0xbe, 0xdf, 0x2a, 0x9c, 0x95, 0xae, 0x6e, 0xb8, 0xd8, 0xc0,
	0x8a, 0x5d, 0xc3, 0x6f, 0x7a, 0xf0, 0xa0, 0x57, 0x39, 0xbb, 0xd8, 0x8f, 0xa6, 0x83, 0xda, 0xf4,
	0x95, 0x2b, 0xce, 0x8e, 0x52, 0xae, 0x48, 0x96, 0x60, 0x7e, 0xcb, 0x89, 0xd0, 0xd8, 0xe8, 0x1d,
	0xaf, 0x39, 0xbd, 0xf1, 0x58, 0x4b, 0x23, 0x69, 0x3f, 0x7d, 0xf5, 0xb7, 0x33, 0x70, 0x76, 0x40,
	0x02, 0x90, 0xbc, 0x65, 0xdb, 0x62, 0x71, 0x16, 0xe3, 0xa4, 0x52, 0x16, 0xa3, 0xe7, 0xfe, 0xbf,
	0x9f, 0x81, 0x12, 0x36, 0x15, 0x9e, 0xf3, 0x08, 0xb5, 0x98, 0x8f, 0xc2, 0x84, 0xe3, 0xb5, 0xa4,
	0xb1, 0x4c, 0xea, 0xff, 0x17, 0xbd, 0x16, 0xe5, 0x70, 0xfe, 0x5a, 0x23, 0xdc, 0x4d, 0x9a, 0xc0,
	0xdd, 0x24, 0x7c, 0xad, 0x62, 0x03, 0x49, 0xc0, 0x39, 0x81, 0xf0, 0xc8, 0x73, 0xfa, 0xf0, 0x84,
	0xe9, 0x8d, 0x57, 0xff, 0xf7, 0x14, 0xcc, 0x89, 0x7d, 0x26, 0xdc, 0x4d, 0x46, 0x3b, 0xff, 0x29,
	0x2b, 0x87, 0xf2, 0x88, 0x91, 0x3f, 0xe9, 0xdf, 0x85, 0x16, 0x79, 0x13, 0x51, 0x73, 0xb0, 0x14,
	0x44, 0xb1, 0x79, 0x2a, 0x76, 0x5d, 0x80, 0xa8, 0xc2, 0x99, 0xa5, 0x09, 0x13, 0xa3, 0x96, 0x26,
	0xe4, 0xee, 0x51, 0x9a, 0x70, 0x09, 0x0a, 0x6d, 0xd7, 0x17, 0x7b, 0x6a, 0x79, 0x1c, 0x05, 0x9c,
	0x77, 0xeb, 0x12, 0x46, 0x13, 0xac, 0xb5, 0x2d, 0x3f, 0x79, 0xe8, 0xb6, 0xfc, 0xb7, 0xa1, 0x18,
	0xed, 0xbc, 0xd4, 0x11, 0xca, 0x22, 0xcc, 0x2a, 0x3d, 0xbe, 0xb2, 0x6c, 0x76, 0xb1, 0x98, 0xc1,
	0xdd, 0x63, 0xd7, 0x1d, 0x8f, 0xaf, 0x64, 0x92, 0xb3, 0xf4, 0x6c, 0xae, 0xcb, 0xbf, 0x54, 0xcb,
	0x4c, 0x8e, 0xde, 0x15, 0x06, 0x1e, 0xbd, 0x7b, 0x12, 0x8a, 0x21, 0x8b, 0x1d, 0xd7, 0xaf, 0x07,
	0x1d, 0x59, 0xe3, 0x81, 0xac, 0xa8, 0x02, 0x52, 0x8d, 0x27, 0x97, 0xa1, 0x24, 0xfe, 0xb0, 0xe6,
	0x8a, 0x8c, 0xcc, 0x2c, 0xf2, 0x95, 0x20, 0xa4, 0x26, 0x05, 0xf9, 0x16, 0xe7, 0x2e, 0xaa, 0x7e,
	0x22, 0x69, 0x9f, 0x5e, 0x1e, 0x7f, 0x15, 0xa3, 0x92, 0x25, 0x65, 0xaf, 0x77, 0x59, 0x14, 0xab,
	0x1e, 0x48, 0x39, 0x54, 0x8b, 0x24, 0x6f, 0x42, 0xd1, 0xf1, 0xbc, 0xe0, 0xb6, 0xe7, 0x46, 0x71,
	0x79, 0x1a, 0x0b, 0x4f, 0xbf, 0x86, 0xd5, 0x1e, 0x1c, 0xb8, 0xe6, 0x46, 0xf1, 0xdd, 0x5e, 0x65,
	0xed, 0xd8, 0x07, 0x3b, 0xc5, 0xce, 0x67, 0xb2, 0xc9, 0x29, 0x82, 0xaf, 0x44, 0x1e, 0xf9, 0x3c,
	0xcc, 0xee, 0x05, 0xb1, 0xeb, 0xb7, 0xd4, 0x91, 0x1d, 0x59, 0x4b, 0x8f, 0x6e, 0xe2, 0x4d, 0x0b,
	0x43, 0x53, 0x94, 0xe4, 0xcb, 0x70, 0x26, 0x8a, 0x9d, 0xc6, 0xae, 0xd9, 0x7a, 0x16, 0x5b, 0x9f,
	0x3b, 0x10, 0x49, 0x11, 0x0b, 0x47, 0xfb, 0xa8, 0xab, 0xef, 0xcd, 0xc8, 0xbd, 0x2b, 0x9c, 0x86,
	0x89, 0xcd, 0xce, 0x0c, 0xb1, 0xd9, 0x29, 0x7f, 0x2c, 0x3b, 0x82, 0x3f, 0xf6, 0xa4, 0x19, 0x8d,
	0x0a, 0xcf, 0x69, 0x66, 0x68, 0x24, 0x7a, 0x8c, 0x7a, 0x2f, 0x55, 0x81, 0x95, 0x3f, 0x8d, 0x0a,
	0xac, 0xc9, 0xfb, 0x5e, 0x81, 0xf5, 0x56, 0x06, 0xcb, 0x28, 0x3a, 0x61, 0x80, 0x33, 0xd8, 0x6f,
	0x49, 0x6b, 0xf0, 0xe2, 0x38, 0x9e, 0x88, 0xc1, 0x0e, 0xbd, 0x91, 0x79, 0x59, 0x8f, 0xa1, 0xc1,
	0xd4, 0x16, 0x6a, 0xef, 0xfe, 0x17, 0x4e, 0x7d, 0xf7, 0x7f, 0x1b, 0x26, 0x9a, 0xbe, 0x2f, 0x9d,
	0xb0, 0x17, 0x4f, 0xe8, 0x04, 0xa3, 0x76, 0x32, 0x97, 0x7d, 0x9f, 0x72, 0x01, 0xa4, 0x03, 0x05,
	0xa6, 0x26, 0x0e, 0x8c, 0xeb, 0xcc, 0x9a, 0x67, 0xee, 0x84, 0xa1, 0x4f, 0x26, 0x5e, 0x22, 0x85,
	0x4b, 0x4c, 0x1c, 0xf6, 0xb1, 0x8f, 0xfe, 0x24, 0x0e, 0xfb, 0x61, 0xbe, 0x7a, 0x15, 0x26, 0xb9,
	0x0d, 0x67, 0x4d, 0x59, 0xc8, 0x86, 0x55, 0x4f, 0x75, 0x84, 0x50, 0x89, 0x31, 0x6b, 0xb9, 0x66,
	0x0e, 0xa9, 0xe5, 0x7a, 0x12, 0x8a, 0x9d, 0xee, 0x96, 0xe7, 0x46, 0x3b, 0xac, 0x29, 0x0d, 0x0d,
	0xbe, 0xc3, 0x0d, 0x05, 0xa4, 0x1a, 0xcf, 0xe5, 0x76, 0xba, 0x48, 0x39, 0xa7, 0xe5, 0x6e, 0x20,
	0x84, 0x4a, 0x0c, 0x5f, 0x20, 0x43, 0xd6, 0x31, 0x8b, 0xc8, 0xf0, 0x29, 0xa8, 0x84, 0xd1, 0x04,
	0x8b, 0xdc, 0x9c, 0x6e, 0xc4, 0x9a, 0x58, 0x0c, 0xa2, 0xb8, 0x21, 0x84, 0x4a, 0x0c, 0xe7, 0xd6,
	0x09, 0x83, 0x6d, 0xd7, 0x63, 0x4d, 0x2c, 0xea, 0x90, 0xdc, 0x36, 0x24, 0x8c, 0x26, 0x58, 0x4e,
	0x89, 0x47, 0x56, 0xf7, 0x58, 0x13, 0x0b, 0xc6, 0x24, 0xe5, 0xa2, 0x84, 0xd1, 0x04, 0x4b, 0x16,
	0x00, 0xd4, 0x31, 0x26, 0xd6, 0x2c, 0x9f, 0x43, 0x5a, 0x4c, 0xd9, 0xae, 0x24, 0x50, 0x6a, 0x50,
	0x70, 0xce, 0xf2, 0xf0, 0x7e, 0xb3, 0x7c, 0x5e, 0x73, 0xc6, 0x78, 0xdf, 0xe5, 0x9c, 0x15, 0xd6,
	0x0a, 0x01, 0x2e, 0xdc, 0xf7, 0x10, 0xe0, 0xad, 0x0c, 0xcc, 0x6d, 0xdb, 0x67, 0x30, 0xcb, 0x0f,
	0xa2, 0xd4, 0x31, 0xf2, 0xb4, 0xa9, 0x43, 0x9d, 0xc2, 0x52, 0x1b, 0x40, 0x9a, 0x16, 0x69, 0xdd,
	0xa0, 0x50, 0x1e, 0x57, 0xfd, 0xcd, 0xbb, 0x19, 0xf4, 0x30, 0x73, 0x88, 0xbe, 0x41, 0xa1, 0xfa,
	0xb7, 0x33, 0xd2, 0x03, 0x1e, 0x94, 0x1b, 0xca, 0x9c, 0x6c, 0x6e, 0x08, 0xbb, 0x98, 0x20, 0xe5,
	0xde, 0xe8, 0x91, 0x73, 0x43, 0x75, 0x8b, 0x0b, 0x4d, 0x71, 0x25, 0x5d, 0x38, 0x8b, 0x10, 0x3b,
	0x85, 0x74, 0x8c, 0xad, 0x79, 0x8c, 0xb1, 0xea, 0xfd, 0xac, 0xe8, 0x20, 0xfe, 0xa4, 0x01, 0x33,
	0x78, 0xca, 0x30, 0x79, 0xba, 0xa3, 0x6f, 0x75, 0xe0, 0xb2, 0x53, 0x37, 0x99, 0x50, 0x9b, 0x27,
	0x09, 0x81, 0x70, 0x40, 0xea, 0xd1, 0xf2, 0xc7, 0xdb, 0xbf, 0xac, 0xf7, 0x71, 0xa2, 0x03, 0xb8,
	0x0f, 0xc8, 0xe9, 0x4d, 0xde, 0x97, 0x9c, 0xde, 0xc7, 0x61, 0xaa, 0xb1, 0x27, 0xa2, 0x06, 0x71,
	0x9d, 0x44, 0xb2, 0xab, 0xb1, 0x74, 0x53, 0x04, 0x0e, 0x0a, 0x4f, 0xae, 0x00, 0x88, 0x97, 0x8e,
	0xd4, 0x05, 0xa4, 0x4e, 0x22, 0xbd, 0x7a, 0x82, 0xa1, 0x06, 0x15, 0xb9, 0x0c, 0x45, 0x1c, 0x4b,
	0x6c, 0x52, 0xc4, 0x26, 0x49, 0x22, 0xb9, 0xae, 0x10, 0x54, 0xd3, 0x88, 0xaa, 0xc6, 0x28, 0xc6,
	0x75, 0x2f, 0x63, 0x56, 0x35, 0x72, 0xaf, 0x9f, 0x63, 0x38, 0xc5, 0x96, 0x3a, 0xa2, 0x5a, 0xd0,
	0x14, 0x35, 0x8c, 0x0b, 0x38, 0x86, 0xbc, 0x09, 0x25, 0xec, 0x82, 0x88, 0x2e, 0xd1, 0x77, 0x1e,
	0x27, 0xb7, 0xb0, 0xce, 0x9c, 0xa8, 0x1b, 0xb2, 0x36, 0xf3, 0x63, 0xbd, 0x3f, 0x53, 0xd7, 0x02,
	0xa8, 0x29, 0x8d, 0xdc, 0x01, 0x88, 0x93, 0x3d, 0xa2, 0xf2, 0xcc, 0x09, 0xca, 0xd6, 0x63, 0x9d,
	0xf0, 0xa7, 0x86, 0x2c, 0xf2, 0xb4, 0x4a, 0xcf, 0xce, 0x5a, 0x57, 0x1c, 0x24, 0xe9, 0x59, 0x10,
	0xd1, 0xba, 0x99, 0x9b, 0xbd, 0x82, 0xa7, 0xc3, 0x83, 0x30, 0x36, 0xb2, 0x0c, 0x89, 0x18, 0x9a,
	0x60, 0xa8, 0x41, 0x45, 0x3e, 0x0d, 0xa5, 0xb6, 0xe3, 0xbb, 0xdb, 0x2c, 0x8a, 0x5f, 0x09, 0x5d,
	0x5c, 0x20, 0x8d, 0x7d, 0xab, 0x75, 0x8d, 0xa2, 0x26, 0x1d, 0x17, 0x75, 0x9b, 0xb9, 0xad, 0x9d,
	0x38, 0xe2, 0xad, 0xe6, 0x6d, 0x51, 0xb7, 0x12, 0x0c, 0x35, 0xa8, 0xc8, 0x12, 0x9c, 0xf1, 0x9c,
	0x2d, 0xe6, 0x45, 0xf2, 0xde, 0x1f, 0xde, 0x52, 0xd4, 0x60, 0x27, 0xa7, 0x9a, 0xd7, 0x38, 0x5e,
	0xa3, 0x69, 0x5f, 0x03, 0xae, 0xe1, 0x5e, 0xd0, 0x42, 0xa9, 0x67, 0xed, 0x1d, 0xfe, 0x35, 0x01,
	0xa6, 0x0a, 0xcf, 0xfb, 0x28, 0x17, 0x63, 0x4e, 0x7d, 0xce, 0xee, 0xe3, 0x46, 0x82, 0xa1, 0x06,
	0x15, 0x0e, 0x87, 0x1b, 0x35, 0xb8, 0x2f, 0xc9, 0x1b, 0x9d, 0x4f, 0x0d, 0x87, 0x46, 0x51, 0x93,
	0x8e, 0x4f, 0x0c, 0x2c, 0x17, 0xc6, 0x81, 0xbf, 0x60, 0x6f, 0x87, 0xad, 0x2a, 0x04, 0xd5, 0x34,
	0x5c, 0x8e, 0x5a, 0xb6, 0xb8, 0x9c, 0x07, 0x6d, 0x39, 0x2b, 0x1a, 0x45, 0x4d, 0x3a, 0xf2, 0x0d,
	0x2b, 0xe1, 0x53, 0x1e, 0xf7, 0x70, 0xb9, 0x5d, 0x83, 0x79, 0xcf, 0x44, 0xcf, 0xdb, 0x13, 0x32,
	0xab, 0xa2, 0x55, 0xf6, 0xb8, 0xb7, 0xd1, 0x58, 0x2b, 0x64, 0xf6, 0xfe, 0xec, 0x3a, 0x4f, 0x9c,
	0xd0, 0xae, 0x73, 0xa0, 0x77, 0x9d, 0x73, 0x27, 0x68, 0x00, 0x86, 0x6f, 0x38, 0x27, 0xe9, 0x2d,
	0xa3, 0x94, 0xc1, 0x4a, 0x6f, 0xbd, 0x97, 0x91, 0xb5, 0x93, 0xea, 0xb2, 0xb3, 0x74, 0x50, 0x9b,
	0x19, 0x21, 0xa8, 0x8d, 0xa1, 0xa8, 0x92, 0x48, 0xaa, 0x1a, 0x65, 0x8c, 0xb3, 0xa7, 0x89, 0xf9,
	0x37, 0xf6, 0xaf, 0x15, 0x77, 0xaa, 0x05, 0x8d, 0x98, 0x2c, 0xab, 0x7e, 0x05, 0xce, 0xa4, 0x6f,
	0xb8, 0x39, 0xa9, 0x33, 0xde, 0xef, 0x66, 0xa1, 0x70, 0x23, 0x88, 0xd9, 0x56, 0x10, 0xec, 0x9e,
	0x42, 0x11, 0xdb, 0x8e, 0x55, 0xc4, 0x36, 0x86, 0x27, 0xaa, 0xfa, 0x3c, 0xb4, 0x78, 0xad, 0x93,
	0x2a, 0x5e, 0xbb, 0x7e, 0x02, 0xb2, 0x0e, 0x2f, 0x5a, 0xfb, 0x55, 0x16, 0xe6, 0x15, 0xa9, 0x2e,
	0x56, 0xfb, 0x9c, 0x95, 0x68, 0x7d, 0x22, 0x55, 0xac, 0x76, 0xbe, 0xaf, 0xc1, 0x87, 0x95, 0x6a,
	0x87, 0x57, 0xaa, 0xfd, 0x34, 0x03, 0xd3, 0x6a, 0xd0, 0x4e, 0xa1, 0x42, 0xad, 0x65, 0x57, 0xa8,
	0xd5, 0xc6, 0xd7, 0xa2, 0x21, 0x95, 0x69, 0x3f, 0xc9, 0x42, 0x49, 0x91, 0x9c, 0x4e, 0x41, 0xe9,
	0xae, 0x35, 0x17, 0x57, 0xc7, 0x7f, 0xb2, 0xc3, 0x6a, 0x49, 0xa3, 0xd4, 0x74, 0x7c, 0xf1, 0x64,
	0xc4, 0x1d, 0x3e, 0x23, 0xff, 0x21, 0x0b, 0xe7, 0x0c, 0xea, 0x91, 0x2b, 0x48, 0x07, 0xb5, 0xf9,
	0x70, 0x5e, 0x1e, 0x3e, 0x2f, 0xff, 0x26, 0x03, 0x73, 0xc6, 0xb8, 0x9d, 0xc2, 0xd4, 0x7c, 0xcd,
	0x9e, 0x9a, 0x57, 0x4f, 0x44, 0xa3, 0x86, 0xcc, 0xce, 0xbf, 0xca, 0x5a, 0x4f, 0x77, 0xdc, 0x52,
	0x09, 0xb1, 0x6d, 0x8a, 0x5c, 0x8c, 0x74, 0xbe, 0xda, 0x36, 0x4d, 0xe0, 0xd4, 0xa2, 0x22, 0x21,
	0x4c, 0xee, 0x89, 0x0b, 0x94, 0xc6, 0xbf, 0x28, 0x4f, 0xf2, 0xbd, 0xe9, 0xc8, 0x8b, 0x3a, 0x93,
	0x37, 0x2f, 0xef, 0xfc, 0x90, 0x92, 0xf4, 0xc6, 0x44, 0xee, 0x28, 0x87, 0x48, 0xf3, 0x47, 0xbc,
	0xfe, 0xf5, 0xff, 0x4d, 0xe8, 0x25, 0x53, 0x57, 0xe2, 0xdd, 0xb3, 0xf6, 0xd4, 0x68, 0x62, 0x85,
	0x7c, 0xf7, 0xcd, 0x8f, 0xee, 0xcf, 0x58, 0x4c, 0xdc, 0x97, 0x8c, 0xc5, 0x7f, 0xb7, 0xf7, 0xb0,
	0x85, 0x83, 0x7d, 0xe3, 0x44, 0x14, 0x7b, 0xf4, 0xc0, 0xe6, 0x47, 0x39, 0xbd, 0xc2, 0x9e, 0x62,
	0x6d, 0xf4, 0x06, 0x14, 0xc5, 0xf5, 0xd3, 0x94, 0x6d, 0xcb, 0xe1, 0x1d, 0xe9, 0x4c, 0xb1, 0x78,
	0x6b, 0xaa, 0x25, 0xd5, 0x4c, 0xc8, 0x93, 0x66, 0x1c, 0x9a, 0xd3, 0x1b, 0x61, 0x03, 0x63, 0xd0,
	0x67, 0x60, 0x3a, 0x64, 0xaf, 0x77, 0x5d, 0x11, 0x8f, 0x44, 0x52, 0x95, 0x71, 0x6a, 0x52, 0x03,
	0x4e, 0x2d, 0x2a, 0xf1, 0x9c, 0x5b, 0x1b, 0x4e, 0x63, 0xd7, 0x69, 0xb1, 0xc8, 0xbc, 0xe1, 0x74,
	0x59, 0x83, 0xa9, 0x49, 0x43, 0x1e, 0x81, 0xdc, 0x9e, 0x13, 0x46, 0xe5, 0x29, 0x7d, 0x37, 0xe0,
	0x4d, 0x27, 0x8c, 0x28, 0x42, 0xad, 0x1c, 0x75, 0xe1, 0xbe, 0xe7, 0xa8, 0x93, 0x59, 0x5e, 0x3c,
	0xca, 0x2c, 0x87, 0x23, 0xce, 0xf2, 0x9f, 0x66, 0x60, 0xd6, 0xf6, 0xa1, 0x79, 0x6c, 0x82, 0x43,
	0x2f, 0x95, 0x49, 0x1b, 0x5d, 0x3c, 0x66, 0x2c, 0x70, 0xe4, 0x51, 0x98, 0xe8, 0x86, 0x6e, 0xba,
	0x30, 0xe2, 0x15, 0xba, 0x4a, 0x39, 0x9c, 0x7c, 0xdb, 0x9a, 0x2b, 0xc2, 0x34, 0x9e, 0x80, 0x5b,
	0x31, 0xfa, 0x44, 0xe1, 0x61, 0x59, 0xca, 0x9e, 0x9e, 0x54, 0x58, 0xf6, 0xbd, 0x2c, 0x9c, 0xbd,
	0xd1, 0x6d, 0xb3, 0xd0, 0x6d, 0xbc, 0xdf, 0x2f, 0x96, 0x6d, 0xc2, 0x64, 0xd4, 0x70, 0xbc, 0xe4,
	0x4a, 0xec, 0x35, 0xf4, 0x84, 0x10, 0x32, 0xce, 0x46, 0xad, 0xe0, 0x40, 0x25, 0xef, 0xea, 0xaf,
	0x33, 0x30, 0xa7, 0x46, 0x42, 0x9e, 0x95, 0x20, 0xbe, 0x51, 0x64, 0x95, 0x39, 0xc1, 0x22, 0xab,
	0xe9, 0x21, 0x05, 0x56, 0x6f, 0xc2, 0xb4, 0x60, 0x7f, 0x75, 0x0f, 0x4d, 0x44, 0xf6, 0x68, 0x37,
	0x47, 0xf5, 0xc9, 0xbc, 0x66, 0x30, 0x13, 0x96, 0xc6, 0x84, 0x50, 0x4b, 0x58, 0xf5, 0xbd, 0x02,
	0xcc, 0xf7, 0xed, 0x2b, 0x93, 0xb7, 0x32, 0x50, 0x6a, 0xe8, 0xfb, 0xd3, 0xe5, 0x30, 0xbc, 0x3c,
	0x4e, 0xdd, 0xde, 0xc0, 0xcb, 0xd8, 0x85, 0x4d, 0x33, 0x90, 0xd4, 0x14, 0x4b, 0x62, 0x98, 0xf2,
	0x85, 0xb6, 0xca, 0x41, 0x19, 0xe3, 0x70, 0xe7, 0x00, 0xb5, 0x17, 0x5a, 0x2e, 0x11, 0x54, 0x89,
	0x22, 0x3b, 0x90, 0x8b, 0xd9, 0x9d, 0x58, 0x2e, 0x16, 0x2f, 0x8c, 0x93, 0xae, 0xb9, 0x13, 0x5b,
	0xf2, 0x64, 0x35, 0xce, 0x1d, 0xac, 0xc6, 0xb9, 0x13, 0xe3, 0x01, 0x43, 0x34, 0x57, 0xb9, 0x71,
	0x83, 0x97, 0xbe, 0xfb, 0xf4, 0xe4, 0x65, 0xb7, 0xa6, 0xdd, 0xf3, 0x20, 0xef, 0x74, 0x9b, 0x6e,
	0x20, 0xb7, 0x61, 0xc6, 0x90, 0xd6, 0xf7, 0xd1, 0x06, 0x21, 0x0d, 0xc1, 0x54, 0x08, 0xe1, 0xd2,
	0xf6, 0xdc, 0x26, 0x0b, 0xc6, 0xaf, 0x66, 0xbd, 0xc9, 0xd9, 0xf4, 0x4b, 0x43, 0x30, 0x15, 0x42,
	0xc8, 0x1d, 0x28, 0xa8, 0x5b, 0x5f, 0x65, 0x9d, 0xc5, 0x8d, 0xb1, 0x2a, 0x75, 0xfb, 0xee, 0xde,
	0x16, 0xb3, 0x97, 0xaf, 0x7e, 0xe8, 0x61, 0x25, 0xd2, 0xc8, 0x7f, 0xcb, 0xc0, 0x9c, 0xb8, 0x24,
	0x90, 0x6d, 0x32, 0x8f, 0x35, 0x54, 0x9d, 0x45, 0xb1, 0x76, 0x0b, 0xe7, 0xbb, 0x84, 0x8d, 0x73,
	0x29, 0xe1, 0x8a, 0xcd, 0x9e, 0xa6, 0xe5, 0x91, 0x5d, 0x98, 0x0a, 0x59, 0xb3, 0xdb, 0x48, 0x56,
	0xdc, 0x97, 0x45, 0xca, 0x13, 0x41, 0xe3, 0x7c, 0x3f, 0x60, 0xd9, 0x6d, 0x4b, 0x2e, 0x54, 0x49,
	0x20, 0x0b, 0x00, 0x6e, 0x7b, 0xcb, 0xf1, 0x1c, 0xbf, 0xc1, 0x9a, 0xb8, 0x68, 0xcb, 0x8d, 0xf4,
	0xd5, 0x04, 0x4a, 0x0d, 0x8a, 0xea, 0xdf, 0x67, 0x60, 0xc6, 0xaa, 0xa1, 0x1d, 0xf7, 0x5b, 0x16,
	0x9f, 0x4d, 0xdf, 0x4f, 0x22, 0x8f, 0xc6, 0xdc, 0xf3, 0x6e, 0x92, 0x2a, 0x4c, 0x8a, 0x9d, 0x12,
	0x59, 0xf3, 0x88, 0xa5, 0x07, 0x62, 0x1f, 0x85, 0x4a, 0xcc, 0x80, 0x4f, 0x57, 0xe4, 0x46, 0xfd,
	0x74, 0x45, 0xf5, 0xcf, 0xb2, 0x30, 0x29, 0x76, 0x80, 0x4e, 0x21, 0xcd, 0xb2, 0x6d, 0xa5, 0x59,
	0x96, 0x8f, 0xaf, 0xed, 0xa2, 0xc7, 0x43, 0x33, 0x2c, 0x7e, 0x2a, 0xc3, 0xb2, 0x32, 0xb6, 0xa4,
	0xc3, 0x93, 0x2b, 0xef, 0x65, 0x61, 0x4e, 0x10, 0xea, 0xbc, 0xca, 0x67, 0xad, 0xbc, 0xca, 0xe3,
	0xa9, 0xbc, 0xca, 0xd9, 0x14, 0xf9, 0x87, 0x29, 0x95, 0xc3, 0x53, 0x2a, 0x3f, 0xc9, 0x80, 0xdc,
	0xa8, 0x3c, 0x85, 0x6c, 0x0a, 0xb3, 0xb3, 0x29, 0x5f, 0x1e, 0x57, 0x7b, 0x86, 0x24, 0x52, 0xbe,
	0x97, 0x53, 0xcf, 0x74, 0xdc, 0xd0, 0xb2, 0x0e, 0x45, 0xe6, 0xc7, 0x6e, 0xbc, 0xcf, 0xe3, 0xc4,
	0xec, 0xe8, 0x71, 0x62, 0xb2, 0x13, 0x73, 0x55, 0xb5, 0xa6, 0x9a, 0x91, 0x15, 0x77, 0xe5, 0xee,
	0x7b, 0xdc, 0xf5, 0x9c, 0xda, 0x9b, 0xe6, 0x53, 0xc0, 0xf8, 0xae, 0x86, 0x1c, 0x1a, 0x39, 0x5f,
	0x8c, 0x7f, 0xd4, 0xa0, 0x27, 0x57, 0x60, 0x72, 0x5b, 0xdc, 0xad, 0x3e, 0x99, 0x1c, 0xb0, 0x99,
	0x14, 0x77, 0xa8, 0xdf, 0xc5, 0x70, 0x95, 0x53, 0xca, 0x3b, 0xd6, 0x25, 0x65, 0x3a, 0x20, 0x9f,
	0xd2, 0x03, 0xad, 0xea, 0xf5, 0xf9, 0x80, 0x58, 0x01, 0x79, 0x12, 0x1c, 0x16, 0x8e, 0x12, 0x1c,
	0x16, 0x8f, 0x18, 0x1c, 0xfe, 0xee, 0x04, 0x4c, 0x9b, 0xf6, 0xe6, 0x83, 0x9f, 0xc4, 0xb9, 0xa2,
	0xd2, 0x57, 0x22, 0xe5, 0xf0, 0x48, 0x3a, 0x7d, 0x55, 0x12, 0x8f, 0x6b, 0x65, 0xae, 0x64, 0xa8,
	0x9b, 0x1f, 0x12, 0xea, 0x7e, 0xd3, 0x0a, 0x75, 0x27, 0xc7, 0x3d, 0xed, 0x9b, 0xb2, 0xc3, 0xf7,
	0x0c, 0x74, 0x7f, 0x98, 0x85, 0x3c, 0x56, 0x0f, 0x7f, 0x90, 0xee, 0xff, 0xc5, 0x0e, 0x9f, 0xc6,
	0xfd, 0xbf, 0x42, 0xd0, 0xe1, 0x8b, 0xe5, 0xcf, 0xb3, 0x30, 0x8b, 0x74, 0x23, 0xdf, 0x08, 0x65,
	0x53, 0x7f, 0xb8, 0x54, 0xde, 0xfb, 0x46, 0x28, 0x1c, 0xb1, 0x0f, 0xd4, 0x8d, 0x50, 0xd8, 0xe3,
	0x21, 0x0b, 0xe5, 0x1f, 0x96, 0xe4, 0x13, 0x9d, 0x62, 0x0a, 0x56, 0xdf, 0xe9, 0x38, 0x31, 0xd6,
	0x9d, 0x8e, 0x1f, 0x9e, 0x2a, 0x40, 0xfb, 0x82, 0xe7, 0xa8, 0x64, 0x16, 0x77, 0xdc, 0xbb, 0x19,
	0xf4, 0xd1, 0x2d, 0x31, 0xe0, 0xe2, 0x3f, 0x95, 0x42, 0x06, 0x1c, 0x62, 0x28, 0xfe, 0x47, 0x1c,
	0x62, 0x30, 0x6b, 0xed, 0xe1, 0x54, 0x6a, 0xed, 0x9b, 0x90, 0xc7, 0xcf, 0x87, 0x61, 0xa9, 0xfd,
	0x58, 0xeb, 0x45, 0xf2, 0x0d, 0x36, 0x79, 0xc4, 0x0e, 0xbf, 0x54, 0x24, 0x98, 0x8f, 0x5a, 0xad,
	0x6f, 0x16, 0xd7, 0xcf, 0x8e, 0x58, 0x5c, 0x3f, 0x37, 0x52, 0x71, 0xfd, 0x99, 0x43, 0x8b, 0xeb,
	0x79, 0x2c, 0x8c, 0xf5, 0x8f, 0xc9, 0x51, 0x81, 0x79, 0x23, 0x16, 0xb6, 0x30, 0x34, 0x45, 0x49,
	0xbe, 0x0c, 0x67, 0x10, 0x22, 0x12, 0x53, 0xe2, 0xf8, 0x00, 0xd1, 0x27, 0x9a, 0xd6, 0x53, 0x38,
	0xda, 0x47, 0x6d, 0xb9, 0xce, 0x67, 0xef, 0xbb, 0xeb, 0xdc, 0x81, 0xe2, 0x8e, 0xfa, 0x84, 0x08,
	0x56, 0x24, 0x8e, 0xf5, 0xd2, 0x93, 0xaf, 0x91, 0x08, 0xbf, 0x31, 0xf9, 0x4b, 0xb5, 0x10, 0xed,
	0x07, 0x5f, 0x18, 0x72, 0x97, 0xce, 0xef, 0xcf, 0x42, 0xc9, 0x70, 0x02, 0x8c, 0xdb, 0x46, 0x33,
	0x87, 0xde, 0x36, 0xba, 0x0c, 0xb3, 0xb7, 0x1d, 0x37, 0x76, 0xfd, 0x56, 0x3d, 0xa8, 0x1b, 0x9f,
	0xf5, 0x53, 0x1e, 0xe3, 0xb9, 0x5b, 0x16, 0x56, 0xb6, 0x4e, 0xb5, 0x21, 0xcf, 0xeb, 0xeb, 0x3b,
	0xe4, 0x71, 0x4a, 0x51, 0x4a, 0xd6, 0x77, 0xcf, 0x86, 0x6a, 0x6f, 0x53, 0x93, 0x0d, 0x38, 0xb7,
	0xed, 0x70, 0x35, 0xb2, 0xe9, 0xe4, 0xa1, 0xcc, 0xa4, 0x2f, 0x02, 0xba, 0x62, 0x51, 0xd2, 0x81,
	0x2d, 0xfb, 0x6f, 0x51, 0xcd, 0x1f, 0xe1, 0x16, 0xd5, 0x75, 0x38, 0xab, 0x1f, 0x50, 0x5d, 0x90,
	0xaa, 0x0e, 0x73, 0xaa, 0xba, 0xdf, 0xb3, 0xb7, 0xfa, 0x49, 0xe8, 0xa0, 0x76, 0xd8, 0x17, 0x86,
	0xa7, 0x21, 0x24, 0xa3, 0xa9, 0x54, 0x5f, 0x4c, 0x24, 0xb5, 0x69, 0x79, 0x5f, 0xe4, 0x03, 0x5a,
	0x2c, 0x0a, 0x76, 0x5f, 0xac, 0x91, 0x11, 0x84, 0x74, 0x50, 0x3b, 0xf2, 0x2c, 0x4c, 0x8b, 0xd3,
	0x3f, 0x92, 0x8f, 0x38, 0xd6, 0x99, 0x5c, 0x67, 0x5c, 0x37, 0x70, 0xd4, 0xa2, 0x24, 0x4f, 0x19,
	0xc7, 0x5a, 0xc1, 0xbe, 0xed, 0x76, 0xc0, 0xd1, 0xd6, 0x67, 0x61, 0x7a, 0x3b, 0x64, 0x4c, 0x61,
	0xe4, 0x2d, 0xba, 0xfa, 0xda, 0x64, 0x03, 0x47, 0x2d, 0x4a, 0xde, 0x72, 0xab, 0xdb, 0xdc, 0x4f,
	0x5a, 0x4e, 0xdb, 0x2d, 0x6b, 0xdd, 0x68, 0x5f, 0xb7, 0x34, 0x29, 0xed, 0xa8, 0x6d, 0xe6, 0x04,
	0xa3, 0xb6, 0x00, 0xe6, 0x8d, 0x8b, 0x61, 0xa4, 0x80, 0xd9, 0x23, 0x0b, 0xc0, 0x80, 0xb4, 0x9e,
	0x66, 0x44, 0xfb, 0x79, 0x93, 0x6f, 0xc1, 0x05, 0x05, 0x4c, 0x9d, 0x8a, 0x98, 0x3b, 0xb2, 0x54,
	0xbc, 0xfa, 0xa2, 0x3e, 0x90, 0x1b, 0x1d, 0x22, 0x85, 0xec, 0xc0, 0xac, 0xd4, 0x42, 0xec, 0x93,
	0x34, 0xfe, 0x47, 0x93, 0x8b, 0xa6, 0xbb, 0x6e, 0x70, 0x91, 0xe7, 0x5a, 0x2c, 0xbe, 0xe4, 0x4d,
	0x38, 0x2f, 0x21, 0xa9, 0x07, 0x3d, 0xfa, 0xed, 0xbf, 0x0f, 0x1d, 0xf4, 0x2a, 0xe7, 0xeb, 0x83,
	0x98, 0xd1, 0xc1, 0x32, 0x4e, 0xed, 0x56, 0xe0, 0xcb, 0x50, 0x4c, 0xee, 0x59, 0x96, 0x65, 0xef,
	0x49, 0x26, 0x28, 0xb9, 0x90, 0x99, 0x6a, 0x9a, 0x01, 0xd7, 0x38, 0x9f, 0x3f, 0xd2, 0x35, 0xce,
	0x76, 0xa1, 0xfd, 0x85, 0x91, 0x0a, 0xed, 0xed, 0xb3, 0x0a, 0x0f, 0x8e, 0x74, 0x56, 0x21, 0x39,
	0x12, 0x51, 0x1e, 0x72, 0x24, 0x02, 0x97, 0x24, 0x2b, 0xcb, 0x60, 0x17, 0xcc, 0x3f, 0x34, 0x6e,
	0xc1, 0xbc, 0x1d, 0xa2, 0xde, 0x33, 0x8b, 0xf0, 0x27, 0x19, 0x28, 0x0f, 0x3b, 0x27, 0x2f, 0xef,
	0x03, 0xa8, 0x75, 0x9b, 0x2d, 0x16, 0x4b, 0x63, 0xaf, 0xee, 0x03, 0x10, 0x40, 0xaa, 0xf1, 0xe4,
	0x8b, 0x30, 0xc7, 0x3c, 0xb7, 0xed, 0xfa, 0xc2, 0x39, 0x70, 0x62, 0x26, 0xcd, 0x3a, 0xee, 0x4b,
	0x5c, 0xb5, 0x51, 0x34, 0x4d, 0x4b, 0x9e, 0x85, 0x42, 0x3b, 0x68, 0x3a, 0x9e, 0xba, 0xe8, 0x44,
	0xe4, 0xde, 0x0a, 0xeb, 0x12, 0x76, 0xb7, 0x57, 0x99, 0x56, 0xbf, 0x31, 0xee, 0x4e, 0xa8, 0xab,
	0xbd, 0x0c, 0x9c, 0xef, 0x7b, 0x04, 0x0c, 0xd0, 0xaa, 0x30, 0xb9, 0x25, 0x3a, 0x9f, 0xd1, 0x1f,
	0xc9, 0x94, 0x3d, 0x97, 0x18, 0xee, 0x45, 0x6e, 0x85, 0x4e, 0x63, 0x97, 0x59, 0x37, 0x28, 0xd4,
	0x04, 0x88, 0x2a, 0x1c, 0x79, 0x04, 0x72, 0x61, 0xd7, 0x6f, 0xc9, 0x65, 0x1c, 0xb7, 0x22, 0x69,
	0xd7, 0x6f, 0x51, 0x84, 0x72, 0x41, 0x8d, 0xc0, 0xdf, 0x5e, 0x5d, 0x36, 0xbf, 0xc6, 0xb9, 0x84,
	0x10, 0x2a, 0x31, 0xd6, 0x03, 0x3e, 0x7c, 0xa4, 0x07, 0xfc, 0x41, 0x06, 0xf4, 0xd9, 0x25, 0xb2,
	0x03, 0x93, 0x6d, 0x8c, 0x6c, 0x64, 0xc0, 0xb9, 0x91, 0x38, 0x32, 0x08, 0x3d, 0x81, 0x88, 0x49,
	0xf2, 0xd7, 0x97, 0x5c, 0x64, 0x07, 0x5f, 0x72, 0x51, 0xfd, 0xee, 0x04, 0x9c, 0x49, 0x6f, 0xd3,
	0x8e, 0x5a, 0x0d, 0xd1, 0xd1, 0x5f, 0xed, 0x16, 0x51, 0xf0, 0x4d, 0xfb, 0xab, 0xdd, 0xc7, 0xde,
	0xef, 0xe3, 0x1d, 0xc2, 0xdc, 0xc6, 0x76, 0x10, 0xb6, 0x8d, 0x4f, 0x77, 0x73, 0x6d, 0x8e, 0x83,
	0x5d, 0xe6, 0xe3, 0xb7, 0xcf, 0x8c, 0x23, 0xf8, 0x75, 0x05, 0xa4, 0x1a, 0x2f, 0xce, 0xeb, 0x07,
	0x9d, 0xdb, 0x41, 0xd8, 0x8c, 0xe4, 0x26, 0x96, 0x5c, 0x0e, 0x83, 0xce, 0x2d, 0x0e, 0xa4, 0x1a,
	0x4f, 0x1e, 0x82, 0x89, 0x4e, 0x10, 0xc9, 0xcf, 0xb4, 0xe3, 0xd1, 0xea, 0x8d, 0x20, 0xa2, 0x1c,
	0xc6, 0xc7, 0xd0, 0x63, 0xed, 0xb6, 0x63, 0x7e, 0x44, 0x75, 0x8d, 0x03, 0xa8, 0x80, 0xe3, 0xb7,
	0x95, 0x63, 0xd6, 0xc6, 0xb9, 0x22, 0xbf, 0x2d, 0xbd, 0x19, 0xb3, 0x36, 0x45, 0x28, 0xef, 0x06,
	0x6b, 0x6f, 0xb1, 0x66, 0x93, 0x07, 0x6f, 0x05, 0xdd, 0xe7, 0xab, 0x0a, 0x48, 0x35, 0xbe, 0xfa,
	0x07, 0x19, 0x78, 0x70, 0xc8, 0xb5, 0x0f, 0xe4, 0x93, 0x30, 0xd1, 0xea, 0x74, 0xa5, 0xca, 0x28,
	0xb3, 0x34, 0x71, 0xad, 0xd3, 0x15, 0xc9, 0x69, 0x41, 0x8c, 0x17, 0xf4, 0x73, 0x3a, 0x4e, 0xde,
	0xe8, 0x74, 0x53, 0xdf, 0xae, 0x9d, 0x58, 0x1a, 0x44, 0xde, 0x10, 0xe4, 0x6d, 0xd6, 0x96, 0x83,
	0x9a, 0x90, 0xaf, 0xb3, 0x76, 0x3f, 0x79, 0x9b, 0xb5, 0xab, 0xbf, 0x37, 0x09, 0xd3, 0x66, 0x20,
	0x29, 0xa2, 0x2a, 0x37, 0x08, 0xf9, 0xdc, 0xc8, 0xea, 0x1b, 0x42, 0x36, 0x24, 0x8c, 0x26, 0x58,
	0xd2, 0x84, 0xc9, 0xc6, 0x1e, 0xa6, 0xe8, 0x8c, 0xc2, 0x96, 0xa5, 0x3d, 0x99, 0xa0, 0x3b, 0xb6,
	0xe6, 0x0b, 0x0e, 0x54, 0xf2, 0x26, 0x17, 0x20, 0xdb, 0xd8, 0x93, 0xaf, 0x7d, 0xf2, 0xa0, 0x57,
	0xc9, 0x2e, 0xdd, 0xa4, 0xd9, 0xc6, 0x1e, 0x7f, 0x9b, 0xdb, 0x81, 0xd7, 0x54, 0x9e, 0x2f, 0xbe,
	0xcd, 0x15, 0x0e, 0xa0, 0x02, 0xce, 0x09, 0x42, 0x16, 0x87, 0xfb, 0xd2, 0xf4, 0x21, 0x01, 0xe5,
	0x00, 0x2a, 0xe0, 0x24, 0xb2, 0xaf, 0x04, 0x2b, 0xe0, 0x0c, 0x79, 0xf9, 0xa0, 0x57, 0x29, 0x5d,
	0xd5, 0xe0, 0x13, 0x98, 0xc3, 0xa6, 0x14, 0xd4, 0x22, 0x27, 0xf4, 0xf6, 0xb9, 0xf2, 0xa2, 0x83,
	0x2b, 0x95, 0xf9, 0xaa, 0x02, 0x52, 0x8d, 0xc7, 0x6f, 0x9f, 0xee, 0xb0, 0xc6, 0x6e, 0x27, 0x70,
	0xfd, 0x38, 0xf9, 0xf6, 0x29, 0x18, 0xdf, 0x3e, 0xed, 0xc3, 0xd2, 0x01, 0x2d, 0x48, 0x64, 0x7c,
	0x17, 0xb3, 0x74, 0xd2, 0x47, 0xac, 0x87, 0x7c, 0x62, 0x93, 0xb4, 0x20, 0x1b, 0xed, 0xc8, 0xb4,
	0xc3, 0x4b, 0x27, 0x78, 0x73, 0x0c, 0x0a, 0x45, 0x4d, 0xd8, 0xbc, 0x4e, 0xb3, 0xd1, 0x4e, 0xf2,
	0x49, 0xf4, 0x99, 0x41, 0x9f, 0x44, 0x1f, 0xbc, 0x09, 0x33, 0x7b, 0xc4, 0x4d, 0x98, 0x3f, 0xcf,
	0xc2, 0x7c, 0xdf, 0x5d, 0x64, 0x7d, 0xd5, 0xca, 0x99, 0x91, 0xaa, 0x95, 0x9f, 0x80, 0x29, 0xcf,
	0xd9, 0x32, 0xf6, 0xfb, 0xd1, 0x28, 0xaf, 0x09, 0x10, 0x55, 0xb8, 0xa3, 0xdd, 0x52, 0xf2, 0xba,
	0x71, 0x01, 0x50, 0x6e, 0xdc, 0x98, 0x5f, 0x1f, 0xce, 0x4a, 0x82, 0xa8, 0x01, 0x37, 0x09, 0xf5,
	0xd7, 0x17, 0xe4, 0x47, 0xae, 0x2f, 0xf8, 0x9d, 0x2c, 0x4c, 0x9b, 0x17, 0xad, 0x8d, 0x5b, 0x48,
	0xe1, 0x41, 0x9e, 0x3b, 0xd1, 0x27, 0x75, 0xbf, 0xb9, 0x3a, 0x27, 0xa7, 0x33, 0xcf, 0x1c, 0x12,
	0x51, 0x21, 0x84, 0xeb, 0x9b, 0xd3, 0x8d, 0x03, 0xf9, 0x9d, 0x78, 0xd4, 0xb7, 0xc5, 0x6e, 0x1c,
	0x50, 0x84, 0x0e, 0xd6, 0xb7, 0xdc, 0x11, 0xf5, 0xed, 0x9d, 0x0c, 0xcc, 0xf7, 0x55, 0x0b, 0xbd,
	0x4f, 0xbe, 0x2c, 0x8a, 0xfd, 0x1a, 0xfc, 0x65, 0xd1, 0xda, 0xc2, 0xbb, 0xbf, 0xbc, 0xf8, 0xc0,
	0x8f, 0x7f, 0x79, 0xf1, 0x81, 0x9f, 0xfd, 0xf2, 0xe2, 0x03, 0xdf, 0x39, 0xb8, 0x98, 0x79, 0xf7,
	0xe0, 0x62, 0xe6, 0xc7, 0x07, 0x17, 0x33, 0x3f, 0x3b, 0xb8, 0x98, 0xf9, 0xc5, 0xc1, 0xc5, 0xcc,
	0xf7, 0x7f, 0x75, 0xf1, 0x81, 0xaf, 0x16, 0x14, 0xaf, 0x7f, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x17,
	0xcc, 0x89, 0x6d, 0x89, 0x89, 0x00, 0x00,
}

func (m *AudioPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudioPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AudioPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Featurizer != nil {
		i -= len(*m.Featurizer)
		copy(dAtA[i:], *m.Featurizer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Featurizer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BacktestSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BacktestSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BacktestSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Windows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Windows))
		i--
		dAtA[i] = 0x10
	}
	if m.Initial != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Initial))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CapacityStageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapacityStageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CapacityStageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManualApproval != nil {
		i--
		if *m.ManualApproval {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Tests) > 0 {
		for iNdEx := len(m.Tests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ServingSiteName != nil {
		i -= len(*m.ServingSiteName)
		copy(dAtA[i:], *m.ServingSiteName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ServingSiteName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CategoricalPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoricalPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CategoricalPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Encoder != nil {
		i -= len(*m.Encoder)
		copy(dAtA[i:], *m.Encoder)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Encoder)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Imputer != nil {
		i -= len(*m.Imputer)
		copy(dAtA[i:], *m.Imputer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Imputer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClassicalEstimatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassicalEstimatorSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassicalEstimatorSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i -= len(m.AlgorithmName)
	copy(dAtA[i:], m.AlgorithmName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.AlgorithmName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CompilerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompilerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompilerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Targets[iNdEx])
			copy(dAtA[i:], m.Targets[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Targets[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Compiler != nil {
		i -= len(*m.Compiler)
		copy(dAtA[i:], *m.Compiler)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Compiler)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataSplit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSplit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSplit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Seed != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Seed))))
		i--
		dAtA[i] = 0x39
	}
	if m.SplitColumn != nil {
		i -= len(*m.SplitColumn)
		copy(dAtA[i:], *m.SplitColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SplitColumn)))
		i--
		dAtA[i] = 0x32
	}
	if m.SplitPolicy != nil {
		i -= len(*m.SplitPolicy)
		copy(dAtA[i:], *m.SplitPolicy)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SplitPolicy)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Test != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Test))
		i--
		dAtA[i] = 0x20
	}
	if m.Validation != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Validation))
		i--
		dAtA[i] = 0x18
	}
	if m.Train != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Train))
		i--
		dAtA[i] = 0x10
	}
	if m.Auto != nil {
		i--
		if *m.Auto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataStageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataStageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataStageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.DataPipelineName)
	copy(dAtA[i:], m.DataPipelineName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DataPipelineName)))
	i--
	dAtA[i] = 0x12
	i -= len(m.DatasetName)
	copy(dAtA[i:], m.DatasetName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DatasetName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DateTimePipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DateTimePipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DateTimePipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expand != nil {
		i--
		if *m.Expand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Imputer != nil {
		i -= len(*m.Imputer)
		copy(dAtA[i:], *m.Imputer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Imputer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeepEstimatorLayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeepEstimatorLayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeepEstimatorLayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InputLayers) > 0 {
		for iNdEx := len(m.InputLayers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InputLayers[iNdEx])
			copy(dAtA[i:], m.InputLayers[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.InputLayers[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeepEstimatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeepEstimatorSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeepEstimatorSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Loss)
	copy(dAtA[i:], m.Loss)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Loss)))
	i--
	dAtA[i] = 0x42
	if m.Gpus != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Gpus))
		i--
		dAtA[i] = 0x38
	}
	if m.IsSeq != nil {
		i--
		if *m.IsSeq {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ValidationSplit != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ValidationSplit))
		i--
		dAtA[i] = 0x28
	}
	if m.Epochs != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Epochs))
		i--
		dAtA[i] = 0x20
	}
	if m.BatchSize != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.BatchSize))
		i--
		dAtA[i] = 0x18
	}
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0x12
	if len(m.Architecture) > 0 {
		for iNdEx := len(m.Architecture) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Architecture[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DimensionValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DimensionValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DimensionValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		i -= len(*m.Key)
		copy(dAtA[i:], *m.Key)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnsembleRules) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnsembleRules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnsembleRules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EnsembleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnsembleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnsembleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Base) > 0 {
		for iNdEx := len(m.Base) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Base[iNdEx])
			copy(dAtA[i:], m.Base[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Base[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *ForecastObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForecastObj) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForecastObj) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintGenerated(dAtA, i, uint64(m.LevelIndex))
	i--
	dAtA[i] = 0x10
	i -= len(m.Key)
	copy(dAtA[i:], m.Key)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Key)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ForecastingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForecastingSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForecastingSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Forecast != nil {
		i--
		if *m.Forecast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.ForecastConnectionName != nil {
		i -= len(*m.ForecastConnectionName)
		copy(dAtA[i:], *m.ForecastConnectionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ForecastConnectionName)))
		i--
		dAtA[i] = 0x62
	}
	if m.Backtest != nil {
		{
			size, err := m.Backtest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.DimensionValues) > 0 {
		for iNdEx := len(m.DimensionValues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DimensionValues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.CountryForHoliday != nil {
		i -= len(*m.CountryForHoliday)
		copy(dAtA[i:], *m.CountryForHoliday)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.CountryForHoliday)))
		i--
		dAtA[i] = 0x4a
	}
	if m.ConfidenceInterval != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ConfidenceInterval))
		i--
		dAtA[i] = 0x40
	}
	if m.Horizon != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Horizon))
		i--
		dAtA[i] = 0x38
	}
	if m.FreqSpec != nil {
		{
			size, err := m.FreqSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Repressors) > 0 {
		for iNdEx := len(m.Repressors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Repressors[iNdEx])
			copy(dAtA[i:], m.Repressors[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Repressors[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Dimensions) > 0 {
		for iNdEx := len(m.Dimensions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Dimensions[iNdEx])
			copy(dAtA[i:], m.Dimensions[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Dimensions[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.DateTimeFormat != nil {
		i -= len(*m.DateTimeFormat)
		copy(dAtA[i:], *m.DateTimeFormat)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DateTimeFormat)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TargetColumn != nil {
		i -= len(*m.TargetColumn)
		copy(dAtA[i:], *m.TargetColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TargetColumn)))
		i--
		dAtA[i] = 0x12
	}
	if m.TimeColumn != nil {
		i -= len(*m.TimeColumn)
		copy(dAtA[i:], *m.TimeColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TimeColumn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FreqSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreqSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FreqSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Units != nil {
		i -= len(*m.Units)
		copy(dAtA[i:], *m.Units)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Units)))
		i--
		dAtA[i] = 0x12
	}
	if m.Interval != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Interval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Hierarchy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Hierarchy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Hierarchy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NotifierName != nil {
		i -= len(*m.NotifierName)
		copy(dAtA[i:], *m.NotifierName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.NotifierName)))
		i--
		dAtA[i] = 0x22
	}
	if m.ItemLevel != nil {
		{
			size, err := m.ItemLevel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GroupLevels) > 0 {
		for iNdEx := len(m.GroupLevels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupLevels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HyperParameterValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HyperParameterValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HyperParameterValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Value)
	copy(dAtA[i:], m.Value)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Value)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ImagePipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImagePipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImagePipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Featurizer != nil {
		i -= len(*m.Featurizer)
		copy(dAtA[i:], *m.Featurizer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Featurizer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Level) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Level) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Level) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Aggregate != nil {
		i -= len(*m.Aggregate)
		copy(dAtA[i:], *m.Aggregate)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Aggregate)))
		i--
		dAtA[i] = 0x22
	}
	if m.Freq != nil {
		i -= len(*m.Freq)
		copy(dAtA[i:], *m.Freq)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Freq)))
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.Horizon))
	i--
	dAtA[i] = 0x10
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Model) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelAutobuilder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelAutobuilder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAutobuilder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelAutobuilderCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelAutobuilderCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAutobuilderCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelAutobuilderList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelAutobuilderList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAutobuilderList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelAutobuilderSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelAutobuilderSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAutobuilderSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LabRef != nil {
		{
			size, err := m.LabRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Aborted != nil {
		i--
		if *m.Aborted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SearchMethod != nil {
		i -= len(*m.SearchMethod)
		copy(dAtA[i:], *m.SearchMethod)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SearchMethod)))
		i--
		dAtA[i] = 0x7a
	}
	if m.Trainers != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Trainers))
		i--
		dAtA[i] = 0x70
	}
	if m.DataSourceSpec != nil {
		{
			size, err := m.DataSourceSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AutoScale != nil {
		i--
		if *m.AutoScale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.AccessMethod != nil {
		i -= len(*m.AccessMethod)
		copy(dAtA[i:], *m.AccessMethod)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.AccessMethod)))
		i--
		dAtA[i] = 0x5a
	}
	if m.MaxModels != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxModels))
		i--
		dAtA[i] = 0x50
	}
	if m.MaxTime != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxTime))
		i--
		dAtA[i] = 0x48
	}
	if m.TargetColumn != nil {
		i -= len(*m.TargetColumn)
		copy(dAtA[i:], *m.TargetColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TargetColumn)))
		i--
		dAtA[i] = 0x42
	}
	if m.Objective != nil {
		i -= len(*m.Objective)
		copy(dAtA[i:], *m.Objective)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Objective)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Task != nil {
		i -= len(*m.Task)
		copy(dAtA[i:], *m.Task)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Task)))
		i--
		dAtA[i] = 0x32
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0x22
	}
	if m.DataSourceName != nil {
		i -= len(*m.DataSourceName)
		copy(dAtA[i:], *m.DataSourceName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DataSourceName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DataProductVersionName != nil {
		i -= len(*m.DataProductVersionName)
		copy(dAtA[i:], *m.DataProductVersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DataProductVersionName)))
		i--
		dAtA[i] = 0x12
	}
	if m.DataProductName != nil {
		i -= len(*m.DataProductName)
		copy(dAtA[i:], *m.DataProductName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DataProductName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelAutobuilderStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelAutobuilderStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAutobuilderStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.CompletionTime != nil {
		{
			size, err := m.CompletionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Estimator != nil {
		{
			size, err := m.Estimator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BestModelScore))))
	i--
	dAtA[i] = 0x79
	i = encodeVarintGenerated(dAtA, i, uint64(m.TrainedModels))
	i--
	dAtA[i] = 0x70
	i = encodeVarintGenerated(dAtA, i, uint64(m.Models))
	i--
	dAtA[i] = 0x68
	i = encodeVarintGenerated(dAtA, i, uint64(m.FileSize))
	i--
	dAtA[i] = 0x60
	i = encodeVarintGenerated(dAtA, i, uint64(m.Cols))
	i--
	dAtA[i] = 0x58
	i = encodeVarintGenerated(dAtA, i, uint64(m.Rows))
	i--
	dAtA[i] = 0x50
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x4a
	i -= len(m.ImageRepoName)
	copy(dAtA[i:], m.ImageRepoName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ImageRepoName)))
	i--
	dAtA[i] = 0x42
	i -= len(m.PredictorName)
	copy(dAtA[i:], m.PredictorName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PredictorName)))
	i--
	dAtA[i] = 0x3a
	i -= len(m.BestModelName)
	copy(dAtA[i:], m.BestModelName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.BestModelName)))
	i--
	dAtA[i] = 0x32
	i -= len(m.StudyName)
	copy(dAtA[i:], m.StudyName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.StudyName)))
	i--
	dAtA[i] = 0x22
	i -= len(m.DatasetName)
	copy(dAtA[i:], m.DatasetName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DatasetName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.DataSourceName)
	copy(dAtA[i:], m.DataSourceName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DataSourceName)))
	i--
	dAtA[i] = 0x12
	i -= len(m.FlatFileName)
	copy(dAtA[i:], m.FlatFileName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.FlatFileName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x22
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineRun) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineRun) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineRun) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineRunCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineRunCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineRunCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineRunList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineRunList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineRunList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineRunSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineRunSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineRunSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PipelineName != nil {
		i -= len(*m.PipelineName)
		copy(dAtA[i:], *m.PipelineName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.PipelineName)))
		i--
		dAtA[i] = 0x22
	}
	if m.TriggerName != nil {
		i -= len(*m.TriggerName)
		copy(dAtA[i:], *m.TriggerName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TriggerName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelPipelineRunStageStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineRunStageStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineRunStageStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.StudyName)
	copy(dAtA[i:], m.StudyName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.StudyName)))
	i--
	dAtA[i] = 0x6a
	i -= len(m.ModelName)
	copy(dAtA[i:], m.ModelName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ModelName)))
	i--
	dAtA[i] = 0x62
	i -= len(m.DatasetName)
	copy(dAtA[i:], m.DatasetName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DatasetName)))
	i--
	dAtA[i] = 0x5a
	i -= len(m.Error)
	copy(dAtA[i:], m.Error)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Error)))
	i--
	dAtA[i] = 0x52
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Results[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.EndTime != nil {
		{
			size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.ApprovedAt != nil {
		{
			size, err := m.ApprovedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.ApprovedBy)
	copy(dAtA[i:], m.ApprovedBy)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ApprovedBy)))
	i--
	dAtA[i] = 0x1a
	i--
	if m.Approved {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineRunStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineRunStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineRunStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Folder)
	copy(dAtA[i:], m.Folder)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Folder)))
	i--
	dAtA[i] = 0x6a
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x52
	if m.CompletionTime != nil {
		{
			size, err := m.CompletionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	{
		size, err := m.ProdStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.CapacityStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.UATStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.TrainingStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.DataStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	i -= len(m.StudyName)
	copy(dAtA[i:], m.StudyName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.StudyName)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Stage)
	copy(dAtA[i:], m.Stage)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Stage)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BaselineModelName != nil {
		i -= len(*m.BaselineModelName)
		copy(dAtA[i:], *m.BaselineModelName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.BaselineModelName)))
		i--
		dAtA[i] = 0x7a
	}
	if m.NotifierName != nil {
		i -= len(*m.NotifierName)
		copy(dAtA[i:], *m.NotifierName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.NotifierName)))
		i--
		dAtA[i] = 0x72
	}
	if m.ApproverAccountName != nil {
		i -= len(*m.ApproverAccountName)
		copy(dAtA[i:], *m.ApproverAccountName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ApproverAccountName)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x62
	}
	{
		size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Prod != nil {
		{
			size, err := m.Prod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Capacity != nil {
		{
			size, err := m.Capacity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.UAT != nil {
		{
			size, err := m.UAT.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Training != nil {
		{
			size, err := m.Training.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DefaultServingSiteName != nil {
		i -= len(*m.DefaultServingSiteName)
		copy(dAtA[i:], *m.DefaultServingSiteName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DefaultServingSiteName)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelPipelineStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPipelineStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPipelineStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ModelResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		i--
		if *m.Error {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Score != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Score))))
		i--
		dAtA[i] = 0x19
	}
	i -= len(m.Alg)
	copy(dAtA[i:], m.Alg)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Alg)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelSearchSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelSearchSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelSearchSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StackingEnsemble != nil {
		i--
		if *m.StackingEnsemble {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.VotingEnsemble != nil {
		i--
		if *m.VotingEnsemble {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.AllowList) > 0 {
		for iNdEx := len(m.AllowList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowList[iNdEx])
			copy(dAtA[i:], m.AllowList[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.AllowList[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.RetainFor != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.RetainFor))
		i--
		dAtA[i] = 0x50
	}
	if m.RetainTop != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.RetainTop))
		i--
		dAtA[i] = 0x48
	}
	if m.Test != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Test))
		i--
		dAtA[i] = 0x40
	}
	if m.SHOptions != nil {
		{
			size, err := m.SHOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Trainers != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Trainers))
		i--
		dAtA[i] = 0x30
	}
	if m.MinScore != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.MinScore))))
		i--
		dAtA[i] = 0x29
	}
	if m.MaxModels != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxModels))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxTime != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxTime))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxCost != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxCost))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != nil {
		i -= len(*m.Type)
		copy(dAtA[i:], *m.Type)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Compiler != nil {
		{
			size, err := m.Compiler.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Forecasting != nil {
		{
			size, err := m.Forecasting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Complied != nil {
		i--
		if *m.Complied {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Forecasted != nil {
		i--
		if *m.Forecasted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Archived != nil {
		i--
		if *m.Archived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Profiled != nil {
		i--
		if *m.Profiled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Paused != nil {
		i--
		if *m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Reported != nil {
		i--
		if *m.Reported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Pushed != nil {
		i--
		if *m.Pushed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.Published != nil {
		i--
		if *m.Published {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.Aborted != nil {
		i--
		if *m.Aborted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Tested != nil {
		i--
		if *m.Tested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Training != nil {
		{
			size, err := m.Training.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Ensemble != nil {
		{
			size, err := m.Ensemble.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Dnn != nil {
		{
			size, err := m.Dnn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Estimator != nil {
		{
			size, err := m.Estimator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Preprocessing != nil {
		{
			size, err := m.Preprocessing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Objective != nil {
		i -= len(*m.Objective)
		copy(dAtA[i:], *m.Objective)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Objective)))
		i--
		dAtA[i] = 0x32
	}
	if m.Task != nil {
		i -= len(*m.Task)
		copy(dAtA[i:], *m.Task)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Task)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0x22
	}
	if m.StudyName != nil {
		i -= len(*m.StudyName)
		copy(dAtA[i:], *m.StudyName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.StudyName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	i -= len(m.ForecastUri)
	copy(dAtA[i:], m.ForecastUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ForecastUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	i -= len(m.ImageName)
	copy(dAtA[i:], m.ImageName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ImageName)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	i -= len(m.MisclassUri)
	copy(dAtA[i:], m.MisclassUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.MisclassUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	i -= len(m.ProfileUri)
	copy(dAtA[i:], m.ProfileUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ProfileUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	i -= len(m.LogsUri)
	copy(dAtA[i:], m.LogsUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LogsUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	i -= len(m.LabelEncoderUri)
	copy(dAtA[i:], m.LabelEncoderUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LabelEncoderUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	i -= len(m.WeightsUri)
	copy(dAtA[i:], m.WeightsUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.WeightsUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	i -= len(m.ManifestUri)
	copy(dAtA[i:], m.ManifestUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ManifestUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	i -= len(m.ReportName)
	copy(dAtA[i:], m.ReportName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ReportName)))
	i--
	dAtA[i] = 0x7a
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x72
	if len(m.TestResult) > 0 {
		for iNdEx := len(m.TestResult) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TestResult[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.TrainResult) > 0 {
		for iNdEx := len(m.TrainResult) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrainResult[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	i--
	if m.Best {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x58
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Cost))))
	i--
	dAtA[i] = 0x51
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TestScore))))
	i--
	dAtA[i] = 0x49
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TrainScore))))
	i--
	dAtA[i] = 0x41
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CVScore))))
	i--
	dAtA[i] = 0x39
	if m.CompletionTime != nil {
		{
			size, err := m.CompletionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TestCompletionTime != nil {
		{
			size, err := m.TestCompletionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TestStartTime != nil {
		{
			size, err := m.TestStartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TrainCompletionTime != nil {
		{
			size, err := m.TrainCompletionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TrainStartTime != nil {
		{
			size, err := m.TrainStartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelTestResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelTestResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelTestResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		i -= len(*m.Error)
		copy(dAtA[i:], *m.Error)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Error)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Results[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.EndTime != nil {
		{
			size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.DatasetName)
	copy(dAtA[i:], m.DatasetName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DatasetName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ModelTestSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelTestSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelTestSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxTime != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxTime))
		i--
		dAtA[i] = 0x18
	}
	if len(m.MinScores) > 0 {
		for iNdEx := len(m.MinScores) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MinScores[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NNLayerParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NNLayerParameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NNLayerParameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Value)
	copy(dAtA[i:], m.Value)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Value)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Notebook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notebook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notebook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookRun) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookRun) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookRun) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookRunCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookRunCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookRunCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookRunList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookRunList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookRunList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookRunSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookRunSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookRunSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.NotebookName != nil {
		i -= len(*m.NotebookName)
		copy(dAtA[i:], *m.NotebookName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.NotebookName)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NotebookRunStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookRunStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookRunStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.CompletionTime != nil {
		{
			size, err := m.CompletionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x52
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Vars) > 0 {
		for iNdEx := len(m.Vars) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Vars[iNdEx])
			copy(dAtA[i:], m.Vars[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Vars[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.DebPackages != nil {
		i -= len(*m.DebPackages)
		copy(dAtA[i:], *m.DebPackages)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DebPackages)))
		i--
		dAtA[i] = 0x32
	}
	if m.Requirements != nil {
		i -= len(*m.Requirements)
		copy(dAtA[i:], *m.Requirements)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Requirements)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ImageName != nil {
		i -= len(*m.ImageName)
		copy(dAtA[i:], *m.ImageName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ImageName)))
		i--
		dAtA[i] = 0x22
	}
	if m.SchemaRef != nil {
		{
			size, err := m.SchemaRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NotebookStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	i -= len(m.URI)
	copy(dAtA[i:], m.URI)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.URI)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Image)
	copy(dAtA[i:], m.Image)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Image)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NotebookVarValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookVarValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookVarValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Value)
	copy(dAtA[i:], m.Value)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Value)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NumericPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumericPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NumericPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Scaler != nil {
		i -= len(*m.Scaler)
		copy(dAtA[i:], *m.Scaler)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Scaler)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Imputer != nil {
		i -= len(*m.Imputer)
		copy(dAtA[i:], *m.Imputer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Imputer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PipelineTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelineTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GithubEvents != nil {
		{
			size, err := m.GithubEvents.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Schedule != nil {
		{
			size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PreprocessingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreprocessingSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreprocessingSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Imbalanced != nil {
		i--
		if *m.Imbalanced {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Reducer != nil {
		i -= len(*m.Reducer)
		copy(dAtA[i:], *m.Reducer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Reducer)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Selector != nil {
		i -= len(*m.Selector)
		copy(dAtA[i:], *m.Selector)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Selector)))
		i--
		dAtA[i] = 0x42
	}
	if m.DataTime != nil {
		{
			size, err := m.DataTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Audio != nil {
		{
			size, err := m.Audio.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Text != nil {
		{
			size, err := m.Text.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Numeric != nil {
		{
			size, err := m.Numeric.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Categorical != nil {
		{
			size, err := m.Categorical.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProdStageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProdStageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProdStageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManualApproval != nil {
		i--
		if *m.ManualApproval {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Weight != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Weight))))
		i--
		dAtA[i] = 0x19
	}
	if m.PredictorName != nil {
		i -= len(*m.PredictorName)
		copy(dAtA[i:], *m.PredictorName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.PredictorName)))
		i--
		dAtA[i] = 0x12
	}
	if m.ServingSiteName != nil {
		i -= len(*m.ServingSiteName)
		copy(dAtA[i:], *m.ServingSiteName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ServingSiteName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Report) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Report) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Report) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReportCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReportList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReportSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x42
	}
	if m.NotifierRef != nil {
		i -= len(*m.NotifierRef)
		copy(dAtA[i:], *m.NotifierRef)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.NotifierRef)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Format != nil {
		i -= len(*m.Format)
		copy(dAtA[i:], *m.Format)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Format)))
		i--
		dAtA[i] = 0x32
	}
	if m.ReportType != nil {
		i -= len(*m.ReportType)
		copy(dAtA[i:], *m.ReportType)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ReportType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.EntityRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i -= len(m.URI)
	copy(dAtA[i:], m.URI)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.URI)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x22
	if m.CompletionTime != nil {
		{
			size, err := m.CompletionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *Study) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Study) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Study) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StudyCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StudyCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StudyCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StudyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StudyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StudyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StudySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StudySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StudySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Hierarchy != nil {
		{
			size, err := m.Hierarchy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.ModelImagePushed != nil {
		i--
		if *m.ModelImagePushed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ModelPublished != nil {
		i--
		if *m.ModelPublished {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Profiled != nil {
		i--
		if *m.Profiled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Paused != nil {
		i--
		if *m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.Reported != nil {
		i--
		if *m.Reported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.Aborted != nil {
		i--
		if *m.Aborted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Split != nil {
		{
			size, err := m.Split.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Training != nil {
		{
			size, err := m.Training.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Preprocessing != nil {
		{
			size, err := m.Preprocessing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Search != nil {
		{
			size, err := m.Search.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Objective != nil {
		i -= len(*m.Objective)
		copy(dAtA[i:], *m.Objective)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Objective)))
		i--
		dAtA[i] = 0x32
	}
	if m.Task != nil {
		i -= len(*m.Task)
		copy(dAtA[i:], *m.Task)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Task)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0x22
	}
	if m.LabRef != nil {
		{
			size, err := m.LabRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StudyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StudyStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StudyStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc2
	i -= len(m.ReportName)
	copy(dAtA[i:], m.ReportName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ReportName)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	i -= len(m.ProfileUri)
	copy(dAtA[i:], m.ProfileUri)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ProfileUri)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BestModelScore))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa9
	i -= len(m.BestModel)
	copy(dAtA[i:], m.BestModel)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.BestModel)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	if m.CompletionTime != nil {
		{
			size, err := m.CompletionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.TestingCompletionTime != nil {
		{
			size, err := m.TestingCompletionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.TestingStartTime != nil {
		{
			size, err := m.TestingStartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.TrainingCompletionTime != nil {
		{
			size, err := m.TrainingCompletionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.TrainingStartTime != nil {
		{
			size, err := m.TrainingStartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.BusyTrainers))
	i--
	dAtA[i] = 0x60
	i = encodeVarintGenerated(dAtA, i, uint64(m.FreeTrainers))
	i--
	dAtA[i] = 0x58
	i = encodeVarintGenerated(dAtA, i, uint64(m.Trainers))
	i--
	dAtA[i] = 0x50
	i = encodeVarintGenerated(dAtA, i, uint64(m.TestedModels))
	i--
	dAtA[i] = 0x48
	i = encodeVarintGenerated(dAtA, i, uint64(m.ModelsFailedTesting))
	i--
	dAtA[i] = 0x40
	i = encodeVarintGenerated(dAtA, i, uint64(m.TestingModels))
	i--
	dAtA[i] = 0x38
	i = encodeVarintGenerated(dAtA, i, uint64(m.WaitingToTestModels))
	i--
	dAtA[i] = 0x30
	i = encodeVarintGenerated(dAtA, i, uint64(m.TrainedModels))
	i--
	dAtA[i] = 0x28
	i = encodeVarintGenerated(dAtA, i, uint64(m.ModelsFailedTraining))
	i--
	dAtA[i] = 0x20
	i = encodeVarintGenerated(dAtA, i, uint64(m.TrainingModels))
	i--
	dAtA[i] = 0x18
	i = encodeVarintGenerated(dAtA, i, uint64(m.WaitingToTrainModels))
	i--
	dAtA[i] = 0x10
	i = encodeVarintGenerated(dAtA, i, uint64(m.Models))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *SuccessiveHalvingOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuccessiveHalvingOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuccessiveHalvingOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Modality != nil {
		i -= len(*m.Modality)
		copy(dAtA[i:], *m.Modality)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Modality)))
		i--
		dAtA[i] = 0x42
	}
	if m.EliminationRate != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.EliminationRate))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxBudget != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxBudget))
		i--
		dAtA[i] = 0x30
	}
	return len(dAtA) - i, nil
}

func (m *SuccessiveHalvingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuccessiveHalvingSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuccessiveHalvingSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Modality != nil {
		i -= len(*m.Modality)
		copy(dAtA[i:], *m.Modality)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Modality)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.ConfID != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ConfID))
		i--
		dAtA[i] = 0x20
	}
	if m.Rung != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Rung))
		i--
		dAtA[i] = 0x18
	}
	if m.Bracket != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Bracket))
		i--
		dAtA[i] = 0x10
	}
	if m.Budget != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Budget))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestScore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestScore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Score != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Score))))
		i--
		dAtA[i] = 0x11
	}
	i -= len(m.Metric)
	copy(dAtA[i:], m.Metric)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Metric)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TextPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TextPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Embedding != nil {
		i -= len(*m.Embedding)
		copy(dAtA[i:], *m.Embedding)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Embedding)))
		i--
		dAtA[i] = 0x42
	}
	if m.Stem != nil {
		i--
		if *m.Stem {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Lemma != nil {
		i--
		if *m.Lemma {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Pos != nil {
		i--
		if *m.Pos {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.StopWords != nil {
		i--
		if *m.StopWords {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Tokenizer != nil {
		i -= len(*m.Tokenizer)
		copy(dAtA[i:], *m.Tokenizer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Tokenizer)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Encoder != nil {
		i -= len(*m.Encoder)
		copy(dAtA[i:], *m.Encoder)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Encoder)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TrainingResourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrainingResourceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrainingResourceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Mem)
	copy(dAtA[i:], m.Mem)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Mem)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Cpu)
	copy(dAtA[i:], m.Cpu)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Cpu)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Gpu)
	copy(dAtA[i:], m.Gpu)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Gpu)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TrainingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrainingSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrainingSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x72
	}
	if m.Seed != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Seed))))
		i--
		dAtA[i] = 0x69
	}
	if m.SH != nil {
		{
			size, err := m.SH.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Forecast != nil {
		{
			size, err := m.Forecast.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.CheckpointInterval != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.CheckpointInterval))
		i--
		dAtA[i] = 0x50
	}
	if m.EarlyStop != nil {
		i--
		if *m.EarlyStop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.EvalMetrics) > 0 {
		for iNdEx := len(m.EvalMetrics) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EvalMetrics[iNdEx])
			copy(dAtA[i:], m.EvalMetrics[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.EvalMetrics[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Retry != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Retry))
		i--
		dAtA[i] = 0x38
	}
	if m.Folds != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Folds))
		i--
		dAtA[i] = 0x30
	}
	if m.CV != nil {
		i--
		if *m.CV {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CvType != nil {
		i -= len(*m.CvType)
		copy(dAtA[i:], *m.CvType)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.CvType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Priority != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Priority))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *TrainingStageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrainingStageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrainingStageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManualApproval != nil {
		i--
		if *m.ManualApproval {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.MinScore.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.StudyName != nil {
		i -= len(*m.StudyName)
		copy(dAtA[i:], *m.StudyName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.StudyName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.LabName != nil {
		i -= len(*m.LabName)
		copy(dAtA[i:], *m.LabName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.LabName)))
		i--
		dAtA[i] = 0x12
	}
	if m.NotebookName != nil {
		i -= len(*m.NotebookName)
		copy(dAtA[i:], *m.NotebookName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.NotebookName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UATStageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UATStageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UATStageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadClassName != nil {
		i -= len(*m.WorkloadClassName)
		copy(dAtA[i:], *m.WorkloadClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkloadClassName)))
		i--
		dAtA[i] = 0x22
	}
	if m.Auto != nil {
		i--
		if *m.Auto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Tests) > 0 {
		for iNdEx := len(m.Tests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ServingSiteName != nil {
		i -= len(*m.ServingSiteName)
		copy(dAtA[i:], *m.ServingSiteName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ServingSiteName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VideoPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VideoPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Featurizer != nil {
		i -= len(*m.Featurizer)
		copy(dAtA[i:], *m.Featurizer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Featurizer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenerated(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenerated(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AudioPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Featurizer != nil {
		l = len(*m.Featurizer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *BacktestSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Initial != nil {
		n += 1 + sovGenerated(uint64(*m.Initial))
	}
	if m.Windows != nil {
		n += 1 + sovGenerated(uint64(*m.Windows))
	}
	return n
}

func (m *CapacityStageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServingSiteName != nil {
		l = len(*m.ServingSiteName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Tests) > 0 {
		for _, e := range m.Tests {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ManualApproval != nil {
		n += 2
	}
	return n
}

func (m *CategoricalPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Imputer != nil {
		l = len(*m.Imputer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Encoder != nil {
		l = len(*m.Encoder)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ClassicalEstimatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AlgorithmName)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *CompilerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Compiler != nil {
		l = len(*m.Compiler)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Targets) > 0 {
		for _, s := range m.Targets {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DataSplit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Auto != nil {
		n += 2
	}
	if m.Train != nil {
		n += 1 + sovGenerated(uint64(*m.Train))
	}
	if m.Validation != nil {
		n += 1 + sovGenerated(uint64(*m.Validation))
	}
	if m.Test != nil {
		n += 1 + sovGenerated(uint64(*m.Test))
	}
	if m.SplitPolicy != nil {
		l = len(*m.SplitPolicy)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SplitColumn != nil {
		l = len(*m.SplitColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Seed != nil {
		n += 9
	}
	return n
}

func (m *DataStageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DatasetName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DataPipelineName)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DateTimePipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Imputer != nil {
		l = len(*m.Imputer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Expand != nil {
		n += 2
	}
	return n
}

func (m *DeepEstimatorLayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.InputLayers) > 0 {
		for _, s := range m.InputLayers {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DeepEstimatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Architecture) > 0 {
		for _, e := range m.Architecture {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	if m.BatchSize != nil {
		n += 1 + sovGenerated(uint64(*m.BatchSize))
	}
	if m.Epochs != nil {
		n += 1 + sovGenerated(uint64(*m.Epochs))
	}
	if m.ValidationSplit != nil {
		n += 1 + sovGenerated(uint64(*m.ValidationSplit))
	}
	if m.IsSeq != nil {
		n += 2
	}
	if m.Gpus != nil {
		n += 1 + sovGenerated(uint64(*m.Gpus))
	}
	l = len(m.Loss)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DimensionValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *EnsembleRules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EnsembleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Base) > 0 {
		for _, s := range m.Base {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ForecastObj) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.LevelIndex))
	return n
}

func (m *ForecastingSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimeColumn != nil {
		l = len(*m.TimeColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TargetColumn != nil {
		l = len(*m.TargetColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DateTimeFormat != nil {
		l = len(*m.DateTimeFormat)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Dimensions) > 0 {
		for _, s := range m.Dimensions {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Repressors) > 0 {
		for _, s := range m.Repressors {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.FreqSpec != nil {
		l = m.FreqSpec.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Horizon != nil {
		n += 1 + sovGenerated(uint64(*m.Horizon))
	}
	if m.ConfidenceInterval != nil {
		n += 1 + sovGenerated(uint64(*m.ConfidenceInterval))
	}
	if m.CountryForHoliday != nil {
		l = len(*m.CountryForHoliday)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.DimensionValues) > 0 {
		for _, e := range m.DimensionValues {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Backtest != nil {
		l = m.Backtest.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ForecastConnectionName != nil {
		l = len(*m.ForecastConnectionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Forecast != nil {
		n += 2
	}
	return n
}

func (m *FreqSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Interval != nil {
		n += 1 + sovGenerated(uint64(*m.Interval))
	}
	if m.Units != nil {
		l = len(*m.Units)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *Hierarchy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.GroupLevels) > 0 {
		for _, e := range m.GroupLevels {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.ItemLevel != nil {
		l = m.ItemLevel.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.NotifierName != nil {
		l = len(*m.NotifierName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *HyperParameterValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ImagePipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Featurizer != nil {
		l = len(*m.Featurizer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *Level) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.Horizon))
	if m.Freq != nil {
		l = len(*m.Freq)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Aggregate != nil {
		l = len(*m.Aggregate)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *Model) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelAutobuilder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelAutobuilderCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelAutobuilderList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelAutobuilderSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataProductName != nil {
		l = len(*m.DataProductName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DataProductVersionName != nil {
		l = len(*m.DataProductVersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DataSourceName != nil {
		l = len(*m.DataSourceName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Task != nil {
		l = len(*m.Task)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Objective != nil {
		l = len(*m.Objective)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TargetColumn != nil {
		l = len(*m.TargetColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.MaxTime != nil {
		n += 1 + sovGenerated(uint64(*m.MaxTime))
	}
	if m.MaxModels != nil {
		n += 1 + sovGenerated(uint64(*m.MaxModels))
	}
	if m.AccessMethod != nil {
		l = len(*m.AccessMethod)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.AutoScale != nil {
		n += 2
	}
	if m.DataSourceSpec != nil {
		l = m.DataSourceSpec.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Trainers != nil {
		n += 1 + sovGenerated(uint64(*m.Trainers))
	}
	if m.SearchMethod != nil {
		l = len(*m.SearchMethod)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Aborted != nil {
		n += 3
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.LabRef != nil {
		l = m.LabRef.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ModelAutobuilderStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FlatFileName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DataSourceName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DatasetName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.StudyName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.BestModelName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.PredictorName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ImageRepoName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.Rows))
	n += 1 + sovGenerated(uint64(m.Cols))
	n += 1 + sovGenerated(uint64(m.FileSize))
	n += 1 + sovGenerated(uint64(m.Models))
	n += 1 + sovGenerated(uint64(m.TrainedModels))
	n += 9
	if m.Estimator != nil {
		l = m.Estimator.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.CompletionTime != nil {
		l = m.CompletionTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelPipeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelPipelineCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelPipelineList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelPipelineRun) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelPipelineRunCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelPipelineRunList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelPipelineRunSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TriggerName != nil {
		l = len(*m.TriggerName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.PipelineName != nil {
		l = len(*m.PipelineName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ModelPipelineRunStageStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	l = len(m.ApprovedBy)
	n += 1 + l + sovGenerated(uint64(l))
	if m.ApprovedAt != nil {
		l = m.ApprovedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = len(m.Error)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DatasetName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ModelName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.StudyName)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelPipelineRunStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stage)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.StudyName)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.DataStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.TrainingStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.UATStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.CapacityStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.ProdStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CompletionTime != nil {
		l = m.CompletionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = len(m.Folder)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ModelPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DefaultServingSiteName != nil {
		l = len(*m.DefaultServingSiteName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Training != nil {
		l = m.Training.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.UAT != nil {
		l = m.UAT.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Capacity != nil {
		l = m.Capacity.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Prod != nil {
		l = m.Prod.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Schedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ApproverAccountName != nil {
		l = len(*m.ApproverAccountName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.NotifierName != nil {
		l = len(*m.NotifierName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.BaselineModelName != nil {
		l = len(*m.BaselineModelName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ModelPipelineStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Alg)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Score != nil {
		n += 9
	}
	if m.Error != nil {
		n += 2
	}
	return n
}

func (m *ModelSearchSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.MaxCost != nil {
		n += 1 + sovGenerated(uint64(*m.MaxCost))
	}
	if m.MaxTime != nil {
		n += 1 + sovGenerated(uint64(*m.MaxTime))
	}
	if m.MaxModels != nil {
		n += 1 + sovGenerated(uint64(*m.MaxModels))
	}
	if m.MinScore != nil {
		n += 9
	}
	if m.Trainers != nil {
		n += 1 + sovGenerated(uint64(*m.Trainers))
	}
	if m.SHOptions != nil {
		l = m.SHOptions.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Test != nil {
		n += 1 + sovGenerated(uint64(*m.Test))
	}
	if m.RetainTop != nil {
		n += 1 + sovGenerated(uint64(*m.RetainTop))
	}
	if m.RetainFor != nil {
		n += 1 + sovGenerated(uint64(*m.RetainFor))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.AllowList) > 0 {
		for _, s := range m.AllowList {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.VotingEnsemble != nil {
		n += 2
	}
	if m.StackingEnsemble != nil {
		n += 2
	}
	return n
}

func (m *ModelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.StudyName != nil {
		l = len(*m.StudyName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Task != nil {
		l = len(*m.Task)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Objective != nil {
		l = len(*m.Objective)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Preprocessing != nil {
		l = m.Preprocessing.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Estimator != nil {
		l = m.Estimator.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Dnn != nil {
		l = m.Dnn.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Ensemble != nil {
		l = m.Ensemble.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Training != nil {
		l = m.Training.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Tested != nil {
		n += 2
	}
	if m.Aborted != nil {
		n += 2
	}
	if m.Published != nil {
		n += 2
	}
	if m.Pushed != nil {
		n += 2
	}
	if m.Reported != nil {
		n += 3
	}
	if m.Paused != nil {
		n += 3
	}
	if m.Profiled != nil {
		n += 3
	}
	if m.Archived != nil {
		n += 3
	}
	if m.Forecasted != nil {
		n += 3
	}
	if m.Complied != nil {
		n += 3
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Forecasting != nil {
		l = m.Forecasting.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Compiler != nil {
		l = m.Compiler.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ModelStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TrainStartTime != nil {
		l = m.TrainStartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TrainCompletionTime != nil {
		l = m.TrainCompletionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TestStartTime != nil {
		l = m.TestStartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TestCompletionTime != nil {
		l = m.TestCompletionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CompletionTime != nil {
		l = m.CompletionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	n += 9
	n += 9
	n += 9
	n += 9
	n += 2
	if len(m.TrainResult) > 0 {
		for _, e := range m.TrainResult {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.TestResult) > 0 {
		for _, e := range m.TestResult {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ReportName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ManifestUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.WeightsUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.LabelEncoderUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.LogsUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.ProfileUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.MisclassUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.ImageName)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.ForecastUri)
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ModelTestResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DatasetName)
	n += 1 + l + sovGenerated(uint64(l))
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Error != nil {
		l = len(*m.Error)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ModelTestSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.MinScores) > 0 {
		for _, e := range m.MinScores {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.MaxTime != nil {
		n += 1 + sovGenerated(uint64(*m.MaxTime))
	}
	return n
}

func (m *NNLayerParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *Notebook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *NotebookCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *NotebookList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *NotebookRun) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *NotebookRunCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *NotebookRunList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *NotebookRunSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.NotebookName != nil {
		l = len(*m.NotebookName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *NotebookRunStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CompletionTime != nil {
		l = m.CompletionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *NotebookSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SchemaRef != nil {
		l = m.SchemaRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ImageName != nil {
		l = len(*m.ImageName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Requirements != nil {
		l = len(*m.Requirements)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DebPackages != nil {
		l = len(*m.DebPackages)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Vars) > 0 {
		for _, s := range m.Vars {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *NotebookStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.URI)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *NotebookVarValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *NumericPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Imputer != nil {
		l = len(*m.Imputer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Scaler != nil {
		l = len(*m.Scaler)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *PipelineTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Schedule != nil {
		l = m.Schedule.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GithubEvents != nil {
		l = m.GithubEvents.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *PreprocessingSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Categorical != nil {
		l = m.Categorical.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Numeric != nil {
		l = m.Numeric.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Audio != nil {
		l = m.Audio.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DataTime != nil {
		l = m.DataTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Selector != nil {
		l = len(*m.Selector)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Reducer != nil {
		l = len(*m.Reducer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Imbalanced != nil {
		n += 2
	}
	return n
}

func (m *ProdStageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServingSiteName != nil {
		l = len(*m.ServingSiteName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.PredictorName != nil {
		l = len(*m.PredictorName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Weight != nil {
		n += 9
	}
	if m.ManualApproval != nil {
		n += 2
	}
	return n
}

func (m *Report) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ReportCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ReportList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ReportSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.EntityRef.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ReportType != nil {
		l = len(*m.ReportType)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Format != nil {
		l = len(*m.Format)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.NotifierRef != nil {
		l = len(*m.NotifierRef)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ReportStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CompletionTime != nil {
		l = m.CompletionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.URI)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *Study) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *StudyCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *StudyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *StudySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.LabRef != nil {
		l = m.LabRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Task != nil {
		l = len(*m.Task)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Objective != nil {
		l = len(*m.Objective)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Search != nil {
		l = m.Search.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Preprocessing != nil {
		l = m.Preprocessing.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Training != nil {
		l = m.Training.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Split != nil {
		l = m.Split.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Aborted != nil {
		n += 2
	}
	if m.Reported != nil {
		n += 2
	}
	if m.Paused != nil {
		n += 2
	}
	if m.Profiled != nil {
		n += 3
	}
	if m.ModelPublished != nil {
		n += 3
	}
	if m.ModelImagePushed != nil {
		n += 3
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Hierarchy != nil {
		l = m.Hierarchy.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 2 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *StudyStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.Models))
	n += 1 + sovGenerated(uint64(m.WaitingToTrainModels))
	n += 1 + sovGenerated(uint64(m.TrainingModels))
	n += 1 + sovGenerated(uint64(m.ModelsFailedTraining))
	n += 1 + sovGenerated(uint64(m.TrainedModels))
	n += 1 + sovGenerated(uint64(m.WaitingToTestModels))
	n += 1 + sovGenerated(uint64(m.TestingModels))
	n += 1 + sovGenerated(uint64(m.ModelsFailedTesting))
	n += 1 + sovGenerated(uint64(m.TestedModels))
	n += 1 + sovGenerated(uint64(m.Trainers))
	n += 1 + sovGenerated(uint64(m.FreeTrainers))
	n += 1 + sovGenerated(uint64(m.BusyTrainers))
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TrainingStartTime != nil {
		l = m.TrainingStartTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TrainingCompletionTime != nil {
		l = m.TrainingCompletionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TestingStartTime != nil {
		l = m.TestingStartTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.TestingCompletionTime != nil {
		l = m.TestingCompletionTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.CompletionTime != nil {
		l = m.CompletionTime.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	l = len(m.BestModel)
	n += 2 + l + sovGenerated(uint64(l))
	n += 10
	l = len(m.ProfileUri)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.ReportName)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.Phase)
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *SuccessiveHalvingOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxBudget != nil {
		n += 1 + sovGenerated(uint64(*m.MaxBudget))
	}
	if m.EliminationRate != nil {
		n += 1 + sovGenerated(uint64(*m.EliminationRate))
	}
	if m.Modality != nil {
		l = len(*m.Modality)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *SuccessiveHalvingSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Budget != nil {
		n += 1 + sovGenerated(uint64(*m.Budget))
	}
	if m.Bracket != nil {
		n += 1 + sovGenerated(uint64(*m.Bracket))
	}
	if m.Rung != nil {
		n += 1 + sovGenerated(uint64(*m.Rung))
	}
	if m.ConfID != nil {
		n += 1 + sovGenerated(uint64(*m.ConfID))
	}
	if m.Modality != nil {
		l = len(*m.Modality)
		n += 2 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *TestScore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Metric)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Score != nil {
		n += 9
	}
	return n
}

func (m *TextPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Encoder != nil {
		l = len(*m.Encoder)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Tokenizer != nil {
		l = len(*m.Tokenizer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.StopWords != nil {
		n += 2
	}
	if m.Pos != nil {
		n += 2
	}
	if m.Lemma != nil {
		n += 2
	}
	if m.Stem != nil {
		n += 2
	}
	if m.Embedding != nil {
		l = len(*m.Embedding)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *TrainingResourceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Gpu)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Cpu)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Mem)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *TrainingSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != nil {
		n += 1 + sovGenerated(uint64(*m.Priority))
	}
	if m.CvType != nil {
		l = len(*m.CvType)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CV != nil {
		n += 2
	}
	if m.Folds != nil {
		n += 1 + sovGenerated(uint64(*m.Folds))
	}
	if m.Retry != nil {
		n += 1 + sovGenerated(uint64(*m.Retry))
	}
	if len(m.EvalMetrics) > 0 {
		for _, s := range m.EvalMetrics {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.EarlyStop != nil {
		n += 2
	}
	if m.CheckpointInterval != nil {
		n += 1 + sovGenerated(uint64(*m.CheckpointInterval))
	}
	if m.Forecast != nil {
		l = m.Forecast.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SH != nil {
		l = m.SH.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Seed != nil {
		n += 9
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *TrainingStageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NotebookName != nil {
		l = len(*m.NotebookName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.LabName != nil {
		l = len(*m.LabName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.StudyName != nil {
		l = len(*m.StudyName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.MinScore.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.ManualApproval != nil {
		n += 2
	}
	return n
}

func (m *UATStageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServingSiteName != nil {
		l = len(*m.ServingSiteName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Tests) > 0 {
		for _, e := range m.Tests {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Auto != nil {
		n += 2
	}
	if m.WorkloadClassName != nil {
		l = len(*m.WorkloadClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *VideoPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Featurizer != nil {
		l = len(*m.Featurizer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func sovGenerated(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenerated(x uint64) (n int) {
	return sovGenerated(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AudioPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AudioPipelineSpec{`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Featurizer:` + valueToStringGenerated(this.Featurizer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BacktestSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BacktestSpec{`,
		`Initial:` + valueToStringGenerated(this.Initial) + `,`,
		`Windows:` + valueToStringGenerated(this.Windows) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CapacityStageSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTests := "[]ModelTestSpec{"
	for _, f := range this.Tests {
		repeatedStringForTests += strings.Replace(strings.Replace(f.String(), "ModelTestSpec", "ModelTestSpec", 1), `&`, ``, 1) + ","
	}
	repeatedStringForTests += "}"
	s := strings.Join([]string{`&CapacityStageSpec{`,
		`ServingSiteName:` + valueToStringGenerated(this.ServingSiteName) + `,`,
		`Tests:` + repeatedStringForTests + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`ManualApproval:` + valueToStringGenerated(this.ManualApproval) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CategoricalPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CategoricalPipelineSpec{`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Imputer:` + valueToStringGenerated(this.Imputer) + `,`,
		`Encoder:` + valueToStringGenerated(this.Encoder) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClassicalEstimatorSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParameters := "[]HyperParameterValue{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "HyperParameterValue", "HyperParameterValue", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&ClassicalEstimatorSpec{`,
		`AlgorithmName:` + fmt.Sprintf("%v", this.AlgorithmName) + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`}`,
	}, "")
	return s
}
func (this *CompilerSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CompilerSpec{`,
		`Compiler:` + valueToStringGenerated(this.Compiler) + `,`,
		`Targets:` + fmt.Sprintf("%v", this.Targets) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSplit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSplit{`,
		`Auto:` + valueToStringGenerated(this.Auto) + `,`,
		`Train:` + valueToStringGenerated(this.Train) + `,`,
		`Validation:` + valueToStringGenerated(this.Validation) + `,`,
		`Test:` + valueToStringGenerated(this.Test) + `,`,
		`SplitPolicy:` + valueToStringGenerated(this.SplitPolicy) + `,`,
		`SplitColumn:` + valueToStringGenerated(this.SplitColumn) + `,`,
		`Seed:` + valueToStringGenerated(this.Seed) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataStageSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataStageSpec{`,
		`DatasetName:` + fmt.Sprintf("%v", this.DatasetName) + `,`,
		`DataPipelineName:` + fmt.Sprintf("%v", this.DataPipelineName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DateTimePipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DateTimePipelineSpec{`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Imputer:` + valueToStringGenerated(this.Imputer) + `,`,
		`Expand:` + valueToStringGenerated(this.Expand) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeepEstimatorLayer) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParameters := "[]*NNLayerParameter{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(f.String(), "NNLayerParameter", "NNLayerParameter", 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&DeepEstimatorLayer{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`InputLayers:` + fmt.Sprintf("%v", this.InputLayers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeepEstimatorSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForArchitecture := "[]DeepEstimatorLayer{"
	for _, f := range this.Architecture {
		repeatedStringForArchitecture += strings.Replace(strings.Replace(f.String(), "DeepEstimatorLayer", "DeepEstimatorLayer", 1), `&`, ``, 1) + ","
	}
	repeatedStringForArchitecture += "}"
	s := strings.Join([]string{`&DeepEstimatorSpec{`,
		`Architecture:` + repeatedStringForArchitecture + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`BatchSize:` + valueToStringGenerated(this.BatchSize) + `,`,
		`Epochs:` + valueToStringGenerated(this.Epochs) + `,`,
		`ValidationSplit:` + valueToStringGenerated(this.ValidationSplit) + `,`,
		`IsSeq:` + valueToStringGenerated(this.IsSeq) + `,`,
		`Gpus:` + valueToStringGenerated(this.Gpus) + `,`,
		`Loss:` + fmt.Sprintf("%v", this.Loss) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DimensionValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DimensionValue{`,
		`Key:` + valueToStringGenerated(this.Key) + `,`,
		`Value:` + valueToStringGenerated(this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EnsembleRules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EnsembleRules{`,
		`}`,
	}, "")
	return s
}
func (this *EnsembleSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EnsembleSpec{`,
		`Base:` + fmt.Sprintf("%v", this.Base) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForecastObj) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForecastObj{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`LevelIndex:` + fmt.Sprintf("%v", this.LevelIndex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForecastingSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDimensionValues := "[]DimensionValue{"
	for _, f := range this.DimensionValues {
		repeatedStringForDimensionValues += strings.Replace(strings.Replace(f.String(), "DimensionValue", "DimensionValue", 1), `&`, ``, 1) + ","
	}
	repeatedStringForDimensionValues += "}"
	s := strings.Join([]string{`&ForecastingSpec{`,
		`TimeColumn:` + valueToStringGenerated(this.TimeColumn) + `,`,
		`TargetColumn:` + valueToStringGenerated(this.TargetColumn) + `,`,
		`DateTimeFormat:` + valueToStringGenerated(this.DateTimeFormat) + `,`,
		`Dimensions:` + fmt.Sprintf("%v", this.Dimensions) + `,`,
		`Repressors:` + fmt.Sprintf("%v", this.Repressors) + `,`,
		`FreqSpec:` + strings.Replace(this.FreqSpec.String(), "FreqSpec", "FreqSpec", 1) + `,`,
		`Horizon:` + valueToStringGenerated(this.Horizon) + `,`,
		`ConfidenceInterval:` + valueToStringGenerated(this.ConfidenceInterval) + `,`,
		`CountryForHoliday:` + valueToStringGenerated(this.CountryForHoliday) + `,`,
		`DimensionValues:` + repeatedStringForDimensionValues + `,`,
		`Backtest:` + strings.Replace(this.Backtest.String(), "BacktestSpec", "BacktestSpec", 1) + `,`,
		`ForecastConnectionName:` + valueToStringGenerated(this.ForecastConnectionName) + `,`,
		`Forecast:` + valueToStringGenerated(this.Forecast) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FreqSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FreqSpec{`,
		`Interval:` + valueToStringGenerated(this.Interval) + `,`,
		`Units:` + valueToStringGenerated(this.Units) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Hierarchy) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGroupLevels := "[]Level{"
	for _, f := range this.GroupLevels {
		repeatedStringForGroupLevels += strings.Replace(strings.Replace(f.String(), "Level", "Level", 1), `&`, ``, 1) + ","
	}
	repeatedStringForGroupLevels += "}"
	s := strings.Join([]string{`&Hierarchy{`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`GroupLevels:` + repeatedStringForGroupLevels + `,`,
		`ItemLevel:` + strings.Replace(this.ItemLevel.String(), "Level", "Level", 1) + `,`,
		`NotifierName:` + valueToStringGenerated(this.NotifierName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HyperParameterValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HyperParameterValue{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImagePipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImagePipelineSpec{`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Featurizer:` + valueToStringGenerated(this.Featurizer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Level) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Level{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Horizon:` + fmt.Sprintf("%v", this.Horizon) + `,`,
		`Freq:` + valueToStringGenerated(this.Freq) + `,`,
		`Aggregate:` + valueToStringGenerated(this.Aggregate) + `,`,
		`Values:` + fmt.Sprintf("%v", this.Values) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Model) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Model{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "ModelSpec", "ModelSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "ModelStatus", "ModelStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelAutobuilder) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelAutobuilder{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "ModelAutobuilderSpec", "ModelAutobuilderSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "ModelAutobuilderStatus", "ModelAutobuilderStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelAutobuilderCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelAutobuilderCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelAutobuilderList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]ModelAutobuilder{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "ModelAutobuilder", "ModelAutobuilder", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ModelAutobuilderList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelAutobuilderSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelAutobuilderSpec{`,
		`DataProductName:` + valueToStringGenerated(this.DataProductName) + `,`,
		`DataProductVersionName:` + valueToStringGenerated(this.DataProductVersionName) + `,`,
		`DataSourceName:` + valueToStringGenerated(this.DataSourceName) + `,`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha1.DataLocation", 1) + `,`,
		`Task:` + valueToStringGenerated(this.Task) + `,`,
		`Objective:` + valueToStringGenerated(this.Objective) + `,`,
		`TargetColumn:` + valueToStringGenerated(this.TargetColumn) + `,`,
		`MaxTime:` + valueToStringGenerated(this.MaxTime) + `,`,
		`MaxModels:` + valueToStringGenerated(this.MaxModels) + `,`,
		`AccessMethod:` + valueToStringGenerated(this.AccessMethod) + `,`,
		`AutoScale:` + valueToStringGenerated(this.AutoScale) + `,`,
		`DataSourceSpec:` + strings.Replace(fmt.Sprintf("%v", this.DataSourceSpec), "DataSourceSpec", "v1alpha1.DataSourceSpec", 1) + `,`,
		`Trainers:` + valueToStringGenerated(this.Trainers) + `,`,
		`SearchMethod:` + valueToStringGenerated(this.SearchMethod) + `,`,
		`Aborted:` + valueToStringGenerated(this.Aborted) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`LabRef:` + strings.Replace(fmt.Sprintf("%v", this.LabRef), "ObjectReference", "v11.ObjectReference", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelAutobuilderStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]ModelAutobuilderCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "ModelAutobuilderCondition", "ModelAutobuilderCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&ModelAutobuilderStatus{`,
		`FlatFileName:` + fmt.Sprintf("%v", this.FlatFileName) + `,`,
		`DataSourceName:` + fmt.Sprintf("%v", this.DataSourceName) + `,`,
		`DatasetName:` + fmt.Sprintf("%v", this.DatasetName) + `,`,
		`StudyName:` + fmt.Sprintf("%v", this.StudyName) + `,`,
		`BestModelName:` + fmt.Sprintf("%v", this.BestModelName) + `,`,
		`PredictorName:` + fmt.Sprintf("%v", this.PredictorName) + `,`,
		`ImageRepoName:` + fmt.Sprintf("%v", this.ImageRepoName) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`Rows:` + fmt.Sprintf("%v", this.Rows) + `,`,
		`Cols:` + fmt.Sprintf("%v", this.Cols) + `,`,
		`FileSize:` + fmt.Sprintf("%v", this.FileSize) + `,`,
		`Models:` + fmt.Sprintf("%v", this.Models) + `,`,
		`TrainedModels:` + fmt.Sprintf("%v", this.TrainedModels) + `,`,
		`BestModelScore:` + fmt.Sprintf("%v", this.BestModelScore) + `,`,
		`Estimator:` + strings.Replace(this.Estimator.String(), "ClassicalEstimatorSpec", "ClassicalEstimatorSpec", 1) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`CompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.CompletionTime), "Time", "v1.Time", 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]Model{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "Model", "Model", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ModelList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipeline) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelPipeline{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "ModelPipelineSpec", "ModelPipelineSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "ModelPipelineStatus", "ModelPipelineStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelPipelineCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]ModelPipeline{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "ModelPipeline", "ModelPipeline", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ModelPipelineList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineRun) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelPipelineRun{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "ModelPipelineRunSpec", "ModelPipelineRunSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "ModelPipelineRunStatus", "ModelPipelineRunStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineRunCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelPipelineRunCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineRunList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]ModelPipelineRun{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "ModelPipelineRun", "ModelPipelineRun", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ModelPipelineRunList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineRunSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelPipelineRunSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`TriggerName:` + valueToStringGenerated(this.TriggerName) + `,`,
		`PipelineName:` + valueToStringGenerated(this.PipelineName) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineRunStageStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResults := "[]ModelTestResult{"
	for _, f := range this.Results {
		repeatedStringForResults += strings.Replace(strings.Replace(f.String(), "ModelTestResult", "ModelTestResult", 1), `&`, ``, 1) + ","
	}
	repeatedStringForResults += "}"
	s := strings.Join([]string{`&ModelPipelineRunStageStatus{`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`Approved:` + fmt.Sprintf("%v", this.Approved) + `,`,
		`ApprovedBy:` + fmt.Sprintf("%v", this.ApprovedBy) + `,`,
		`ApprovedAt:` + strings.Replace(fmt.Sprintf("%v", this.ApprovedAt), "Time", "v1.Time", 1) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Time", "v1.Time", 1) + `,`,
		`Results:` + repeatedStringForResults + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`DatasetName:` + fmt.Sprintf("%v", this.DatasetName) + `,`,
		`ModelName:` + fmt.Sprintf("%v", this.ModelName) + `,`,
		`StudyName:` + fmt.Sprintf("%v", this.StudyName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineRunStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]ModelPipelineRunCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "ModelPipelineRunCondition", "ModelPipelineRunCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&ModelPipelineRunStatus{`,
		`Stage:` + fmt.Sprintf("%v", this.Stage) + `,`,
		`StudyName:` + fmt.Sprintf("%v", this.StudyName) + `,`,
		`DataStatus:` + strings.Replace(strings.Replace(this.DataStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`TrainingStatus:` + strings.Replace(strings.Replace(this.TrainingStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`UATStatus:` + strings.Replace(strings.Replace(this.UATStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`CapacityStatus:` + strings.Replace(strings.Replace(this.CapacityStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`ProdStatus:` + strings.Replace(strings.Replace(this.ProdStatus.String(), "ModelPipelineRunStageStatus", "ModelPipelineRunStageStatus", 1), `&`, ``, 1) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`CompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.CompletionTime), "Time", "v1.Time", 1) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`Folder:` + fmt.Sprintf("%v", this.Folder) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelPipelineSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`DefaultServingSiteName:` + valueToStringGenerated(this.DefaultServingSiteName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`Data:` + strings.Replace(this.Data.String(), "DataStageSpec", "DataStageSpec", 1) + `,`,
		`Training:` + strings.Replace(this.Training.String(), "TrainingStageSpec", "TrainingStageSpec", 1) + `,`,
		`UAT:` + strings.Replace(this.UAT.String(), "UATStageSpec", "UATStageSpec", 1) + `,`,
		`Capacity:` + strings.Replace(this.Capacity.String(), "CapacityStageSpec", "CapacityStageSpec", 1) + `,`,
		`Prod:` + strings.Replace(this.Prod.String(), "ProdStageSpec", "ProdStageSpec", 1) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha1.DataLocation", 1) + `,`,
		`Schedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Schedule), "RunSchedule", "v1alpha11.RunSchedule", 1), `&`, ``, 1) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`ApproverAccountName:` + valueToStringGenerated(this.ApproverAccountName) + `,`,
		`NotifierName:` + valueToStringGenerated(this.NotifierName) + `,`,
		`BaselineModelName:` + valueToStringGenerated(this.BaselineModelName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelPipelineStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]ModelPipelineCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "ModelPipelineCondition", "ModelPipelineCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&ModelPipelineStatus{`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelResult{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Alg:` + fmt.Sprintf("%v", this.Alg) + `,`,
		`Score:` + valueToStringGenerated(this.Score) + `,`,
		`Error:` + valueToStringGenerated(this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelSearchSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelSearchSpec{`,
		`Type:` + valueToStringGenerated(this.Type) + `,`,
		`MaxCost:` + valueToStringGenerated(this.MaxCost) + `,`,
		`MaxTime:` + valueToStringGenerated(this.MaxTime) + `,`,
		`MaxModels:` + valueToStringGenerated(this.MaxModels) + `,`,
		`MinScore:` + valueToStringGenerated(this.MinScore) + `,`,
		`Trainers:` + valueToStringGenerated(this.Trainers) + `,`,
		`SHOptions:` + strings.Replace(this.SHOptions.String(), "SuccessiveHalvingOptions", "SuccessiveHalvingOptions", 1) + `,`,
		`Test:` + valueToStringGenerated(this.Test) + `,`,
		`RetainTop:` + valueToStringGenerated(this.RetainTop) + `,`,
		`RetainFor:` + valueToStringGenerated(this.RetainFor) + `,`,
		`Resources:` + strings.Replace(this.Resources.String(), "TrainingResourceRequest", "TrainingResourceRequest", 1) + `,`,
		`AllowList:` + fmt.Sprintf("%v", this.AllowList) + `,`,
		`VotingEnsemble:` + valueToStringGenerated(this.VotingEnsemble) + `,`,
		`StackingEnsemble:` + valueToStringGenerated(this.StackingEnsemble) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelSpec{`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`StudyName:` + valueToStringGenerated(this.StudyName) + `,`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Task:` + valueToStringGenerated(this.Task) + `,`,
		`Objective:` + valueToStringGenerated(this.Objective) + `,`,
		`Preprocessing:` + strings.Replace(this.Preprocessing.String(), "PreprocessingSpec", "PreprocessingSpec", 1) + `,`,
		`Estimator:` + strings.Replace(this.Estimator.String(), "ClassicalEstimatorSpec", "ClassicalEstimatorSpec", 1) + `,`,
		`Dnn:` + strings.Replace(this.Dnn.String(), "DeepEstimatorSpec", "DeepEstimatorSpec", 1) + `,`,
		`Ensemble:` + strings.Replace(this.Ensemble.String(), "EnsembleSpec", "EnsembleSpec", 1) + `,`,
		`Training:` + strings.Replace(this.Training.String(), "TrainingSpec", "TrainingSpec", 1) + `,`,
		`Tested:` + valueToStringGenerated(this.Tested) + `,`,
		`Aborted:` + valueToStringGenerated(this.Aborted) + `,`,
		`Published:` + valueToStringGenerated(this.Published) + `,`,
		`Pushed:` + valueToStringGenerated(this.Pushed) + `,`,
		`Reported:` + valueToStringGenerated(this.Reported) + `,`,
		`Paused:` + valueToStringGenerated(this.Paused) + `,`,
		`Profiled:` + valueToStringGenerated(this.Profiled) + `,`,
		`Archived:` + valueToStringGenerated(this.Archived) + `,`,
		`Forecasted:` + valueToStringGenerated(this.Forecasted) + `,`,
		`Complied:` + valueToStringGenerated(this.Complied) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha1.DataLocation", 1) + `,`,
		`Forecasting:` + strings.Replace(this.Forecasting.String(), "ForecastingSpec", "ForecastingSpec", 1) + `,`,
		`Compiler:` + strings.Replace(this.Compiler.String(), "CompilerSpec", "CompilerSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTrainResult := "[]Measurement{"
	for _, f := range this.TrainResult {
		repeatedStringForTrainResult += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForTrainResult += "}"
	repeatedStringForTestResult := "[]Measurement{"
	for _, f := range this.TestResult {
		repeatedStringForTestResult += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForTestResult += "}"
	repeatedStringForConditions := "[]ModelCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "ModelCondition", "ModelCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&ModelStatus{`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`TrainStartTime:` + strings.Replace(fmt.Sprintf("%v", this.TrainStartTime), "Time", "v1.Time", 1) + `,`,
		`TrainCompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.TrainCompletionTime), "Time", "v1.Time", 1) + `,`,
		`TestStartTime:` + strings.Replace(fmt.Sprintf("%v", this.TestStartTime), "Time", "v1.Time", 1) + `,`,
		`TestCompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.TestCompletionTime), "Time", "v1.Time", 1) + `,`,
		`CompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.CompletionTime), "Time", "v1.Time", 1) + `,`,
		`CVScore:` + fmt.Sprintf("%v", this.CVScore) + `,`,
		`TrainScore:` + fmt.Sprintf("%v", this.TrainScore) + `,`,
		`TestScore:` + fmt.Sprintf("%v", this.TestScore) + `,`,
		`Cost:` + fmt.Sprintf("%v", this.Cost) + `,`,
		`Best:` + fmt.Sprintf("%v", this.Best) + `,`,
		`TrainResult:` + repeatedStringForTrainResult + `,`,
		`TestResult:` + repeatedStringForTestResult + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`ReportName:` + fmt.Sprintf("%v", this.ReportName) + `,`,
		`ManifestUri:` + fmt.Sprintf("%v", this.ManifestUri) + `,`,
		`WeightsUri:` + fmt.Sprintf("%v", this.WeightsUri) + `,`,
		`LabelEncoderUri:` + fmt.Sprintf("%v", this.LabelEncoderUri) + `,`,
		`LogsUri:` + fmt.Sprintf("%v", this.LogsUri) + `,`,
		`ProfileUri:` + fmt.Sprintf("%v", this.ProfileUri) + `,`,
		`MisclassUri:` + fmt.Sprintf("%v", this.MisclassUri) + `,`,
		`ImageName:` + fmt.Sprintf("%v", this.ImageName) + `,`,
		`ForecastUri:` + fmt.Sprintf("%v", this.ForecastUri) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelTestResult) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResults := "[]Measurement{"
	for _, f := range this.Results {
		repeatedStringForResults += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForResults += "}"
	s := strings.Join([]string{`&ModelTestResult{`,
		`DatasetName:` + fmt.Sprintf("%v", this.DatasetName) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Time", "v1.Time", 1) + `,`,
		`Results:` + repeatedStringForResults + `,`,
		`Error:` + valueToStringGenerated(this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelTestSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMinScores := "[]TestScore{"
	for _, f := range this.MinScores {
		repeatedStringForMinScores += strings.Replace(strings.Replace(f.String(), "TestScore", "TestScore", 1), `&`, ``, 1) + ","
	}
	repeatedStringForMinScores += "}"
	s := strings.Join([]string{`&ModelTestSpec{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`MinScores:` + repeatedStringForMinScores + `,`,
		`MaxTime:` + valueToStringGenerated(this.MaxTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NNLayerParameter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NNLayerParameter{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Notebook) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Notebook{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "NotebookSpec", "NotebookSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "NotebookStatus", "NotebookStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NotebookCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]Notebook{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "Notebook", "Notebook", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&NotebookList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookRun) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NotebookRun{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "NotebookRunSpec", "NotebookRunSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "NotebookRunStatus", "NotebookRunStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookRunCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NotebookRunCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookRunList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]NotebookRun{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "NotebookRun", "NotebookRun", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&NotebookRunList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookRunSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValues := "[]NotebookVarValue{"
	for _, f := range this.Values {
		repeatedStringForValues += strings.Replace(strings.Replace(f.String(), "NotebookVarValue", "NotebookVarValue", 1), `&`, ``, 1) + ","
	}
	repeatedStringForValues += "}"
	s := strings.Join([]string{`&NotebookRunSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`NotebookName:` + valueToStringGenerated(this.NotebookName) + `,`,
		`Values:` + repeatedStringForValues + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookRunStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]NotebookRunCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "NotebookRunCondition", "NotebookRunCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&NotebookRunStatus{`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`CompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.CompletionTime), "Time", "v1.Time", 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NotebookSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`SchemaRef:` + strings.Replace(fmt.Sprintf("%v", this.SchemaRef), "ObjectReference", "v11.ObjectReference", 1) + `,`,
		`ImageName:` + valueToStringGenerated(this.ImageName) + `,`,
		`Requirements:` + valueToStringGenerated(this.Requirements) + `,`,
		`DebPackages:` + valueToStringGenerated(this.DebPackages) + `,`,
		`Vars:` + fmt.Sprintf("%v", this.Vars) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha1.DataLocation", 1) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]NotebookCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "NotebookCondition", "NotebookCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&NotebookStatus{`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`URI:` + fmt.Sprintf("%v", this.URI) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotebookVarValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NotebookVarValue{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NumericPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NumericPipelineSpec{`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Imputer:` + valueToStringGenerated(this.Imputer) + `,`,
		`Scaler:` + valueToStringGenerated(this.Scaler) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PipelineTrigger) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PipelineTrigger{`,
		`Schedule:` + strings.Replace(fmt.Sprintf("%v", this.Schedule), "RunSchedule", "v1alpha11.RunSchedule", 1) + `,`,
		`GithubEvents:` + strings.Replace(fmt.Sprintf("%v", this.GithubEvents), "GithubEvents", "v1alpha11.GithubEvents", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PreprocessingSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PreprocessingSpec{`,
		`Categorical:` + strings.Replace(this.Categorical.String(), "CategoricalPipelineSpec", "CategoricalPipelineSpec", 1) + `,`,
		`Numeric:` + strings.Replace(this.Numeric.String(), "NumericPipelineSpec", "NumericPipelineSpec", 1) + `,`,
		`Text:` + strings.Replace(this.Text.String(), "TextPipelineSpec", "TextPipelineSpec", 1) + `,`,
		`Image:` + strings.Replace(this.Image.String(), "ImagePipelineSpec", "ImagePipelineSpec", 1) + `,`,
		`Audio:` + strings.Replace(this.Audio.String(), "AudioPipelineSpec", "AudioPipelineSpec", 1) + `,`,
		`Video:` + strings.Replace(this.Video.String(), "VideoPipelineSpec", "VideoPipelineSpec", 1) + `,`,
		`DataTime:` + strings.Replace(this.DataTime.String(), "DateTimePipelineSpec", "DateTimePipelineSpec", 1) + `,`,
		`Selector:` + valueToStringGenerated(this.Selector) + `,`,
		`Reducer:` + valueToStringGenerated(this.Reducer) + `,`,
		`Imbalanced:` + valueToStringGenerated(this.Imbalanced) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProdStageSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProdStageSpec{`,
		`ServingSiteName:` + valueToStringGenerated(this.ServingSiteName) + `,`,
		`PredictorName:` + valueToStringGenerated(this.PredictorName) + `,`,
		`Weight:` + valueToStringGenerated(this.Weight) + `,`,
		`ManualApproval:` + valueToStringGenerated(this.ManualApproval) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Report) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Report{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "ReportSpec", "ReportSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "ReportStatus", "ReportStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReportCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReportCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReportList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]Report{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "Report", "Report", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ReportList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReportSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReportSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`EntityRef:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.EntityRef), "ObjectReference", "v11.ObjectReference", 1), `&`, ``, 1) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha1.DataLocation", 1) + `,`,
		`ReportType:` + valueToStringGenerated(this.ReportType) + `,`,
		`Format:` + valueToStringGenerated(this.Format) + `,`,
		`NotifierRef:` + valueToStringGenerated(this.NotifierRef) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReportStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]ReportCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "ReportCondition", "ReportCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&ReportStatus{`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`CompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.CompletionTime), "Time", "v1.Time", 1) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`URI:` + fmt.Sprintf("%v", this.URI) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *Study) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Study{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "StudySpec", "StudySpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "StudyStatus", "StudyStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StudyCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StudyCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StudyList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]Study{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "Study", "Study", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&StudyList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *StudySpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StudySpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`LabRef:` + strings.Replace(fmt.Sprintf("%v", this.LabRef), "ObjectReference", "v11.ObjectReference", 1) + `,`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Task:` + valueToStringGenerated(this.Task) + `,`,
		`Objective:` + valueToStringGenerated(this.Objective) + `,`,
		`Search:` + strings.Replace(this.Search.String(), "ModelSearchSpec", "ModelSearchSpec", 1) + `,`,
		`Preprocessing:` + strings.Replace(this.Preprocessing.String(), "PreprocessingSpec", "PreprocessingSpec", 1) + `,`,
		`Training:` + strings.Replace(this.Training.String(), "TrainingSpec", "TrainingSpec", 1) + `,`,
		`Split:` + strings.Replace(this.Split.String(), "DataSplit", "DataSplit", 1) + `,`,
		`Aborted:` + valueToStringGenerated(this.Aborted) + `,`,
		`Reported:` + valueToStringGenerated(this.Reported) + `,`,
		`Paused:` + valueToStringGenerated(this.Paused) + `,`,
		`Profiled:` + valueToStringGenerated(this.Profiled) + `,`,
		`ModelPublished:` + valueToStringGenerated(this.ModelPublished) + `,`,
		`ModelImagePushed:` + valueToStringGenerated(this.ModelImagePushed) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha1.DataLocation", 1) + `,`,
		`Hierarchy:` + strings.Replace(this.Hierarchy.String(), "Hierarchy", "Hierarchy", 1) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StudyStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]StudyCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "StudyCondition", "StudyCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&StudyStatus{`,
		`Models:` + fmt.Sprintf("%v", this.Models) + `,`,
		`WaitingToTrainModels:` + fmt.Sprintf("%v", this.WaitingToTrainModels) + `,`,
		`TrainingModels:` + fmt.Sprintf("%v", this.TrainingModels) + `,`,
		`ModelsFailedTraining:` + fmt.Sprintf("%v", this.ModelsFailedTraining) + `,`,
		`TrainedModels:` + fmt.Sprintf("%v", this.TrainedModels) + `,`,
		`WaitingToTestModels:` + fmt.Sprintf("%v", this.WaitingToTestModels) + `,`,
		`TestingModels:` + fmt.Sprintf("%v", this.TestingModels) + `,`,
		`ModelsFailedTesting:` + fmt.Sprintf("%v", this.ModelsFailedTesting) + `,`,
		`TestedModels:` + fmt.Sprintf("%v", this.TestedModels) + `,`,
		`Trainers:` + fmt.Sprintf("%v", this.Trainers) + `,`,
		`FreeTrainers:` + fmt.Sprintf("%v", this.FreeTrainers) + `,`,
		`BusyTrainers:` + fmt.Sprintf("%v", this.BusyTrainers) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Time", "v1.Time", 1) + `,`,
		`TrainingStartTime:` + strings.Replace(fmt.Sprintf("%v", this.TrainingStartTime), "Time", "v1.Time", 1) + `,`,
		`TrainingCompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.TrainingCompletionTime), "Time", "v1.Time", 1) + `,`,
		`TestingStartTime:` + strings.Replace(fmt.Sprintf("%v", this.TestingStartTime), "Time", "v1.Time", 1) + `,`,
		`TestingCompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.TestingCompletionTime), "Time", "v1.Time", 1) + `,`,
		`CompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.CompletionTime), "Time", "v1.Time", 1) + `,`,
		`BestModel:` + fmt.Sprintf("%v", this.BestModel) + `,`,
		`BestModelScore:` + fmt.Sprintf("%v", this.BestModelScore) + `,`,
		`ProfileUri:` + fmt.Sprintf("%v", this.ProfileUri) + `,`,
		`ReportName:` + fmt.Sprintf("%v", this.ReportName) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuccessiveHalvingOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SuccessiveHalvingOptions{`,
		`MaxBudget:` + valueToStringGenerated(this.MaxBudget) + `,`,
		`EliminationRate:` + valueToStringGenerated(this.EliminationRate) + `,`,
		`Modality:` + valueToStringGenerated(this.Modality) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuccessiveHalvingSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SuccessiveHalvingSpec{`,
		`Budget:` + valueToStringGenerated(this.Budget) + `,`,
		`Bracket:` + valueToStringGenerated(this.Bracket) + `,`,
		`Rung:` + valueToStringGenerated(this.Rung) + `,`,
		`ConfID:` + valueToStringGenerated(this.ConfID) + `,`,
		`Modality:` + valueToStringGenerated(this.Modality) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestScore) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestScore{`,
		`Metric:` + fmt.Sprintf("%v", this.Metric) + `,`,
		`Score:` + valueToStringGenerated(this.Score) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TextPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TextPipelineSpec{`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Encoder:` + valueToStringGenerated(this.Encoder) + `,`,
		`Tokenizer:` + valueToStringGenerated(this.Tokenizer) + `,`,
		`StopWords:` + valueToStringGenerated(this.StopWords) + `,`,
		`Pos:` + valueToStringGenerated(this.Pos) + `,`,
		`Lemma:` + valueToStringGenerated(this.Lemma) + `,`,
		`Stem:` + valueToStringGenerated(this.Stem) + `,`,
		`Embedding:` + valueToStringGenerated(this.Embedding) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrainingResourceRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrainingResourceRequest{`,
		`Gpu:` + fmt.Sprintf("%v", this.Gpu) + `,`,
		`Cpu:` + fmt.Sprintf("%v", this.Cpu) + `,`,
		`Mem:` + fmt.Sprintf("%v", this.Mem) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrainingSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrainingSpec{`,
		`Priority:` + valueToStringGenerated(this.Priority) + `,`,
		`CvType:` + valueToStringGenerated(this.CvType) + `,`,
		`CV:` + valueToStringGenerated(this.CV) + `,`,
		`Folds:` + valueToStringGenerated(this.Folds) + `,`,
		`Retry:` + valueToStringGenerated(this.Retry) + `,`,
		`EvalMetrics:` + fmt.Sprintf("%v", this.EvalMetrics) + `,`,
		`EarlyStop:` + valueToStringGenerated(this.EarlyStop) + `,`,
		`CheckpointInterval:` + valueToStringGenerated(this.CheckpointInterval) + `,`,
		`Forecast:` + strings.Replace(this.Forecast.String(), "ForecastingSpec", "ForecastingSpec", 1) + `,`,
		`SH:` + strings.Replace(this.SH.String(), "SuccessiveHalvingSpec", "SuccessiveHalvingSpec", 1) + `,`,
		`Seed:` + valueToStringGenerated(this.Seed) + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrainingStageSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrainingStageSpec{`,
		`NotebookName:` + valueToStringGenerated(this.NotebookName) + `,`,
		`LabName:` + valueToStringGenerated(this.LabName) + `,`,
		`StudyName:` + valueToStringGenerated(this.StudyName) + `,`,
		`MinScore:` + strings.Replace(strings.Replace(this.MinScore.String(), "TestScore", "TestScore", 1), `&`, ``, 1) + `,`,
		`ManualApproval:` + valueToStringGenerated(this.ManualApproval) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UATStageSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTests := "[]ModelTestSpec{"
	for _, f := range this.Tests {
		repeatedStringForTests += strings.Replace(strings.Replace(f.String(), "ModelTestSpec", "ModelTestSpec", 1), `&`, ``, 1) + ","
	}
	repeatedStringForTests += "}"
	s := strings.Join([]string{`&UATStageSpec{`,
		`ServingSiteName:` + valueToStringGenerated(this.ServingSiteName) + `,`,
		`Tests:` + repeatedStringForTests + `,`,
		`Auto:` + valueToStringGenerated(this.Auto) + `,`,
		`WorkloadClassName:` + valueToStringGenerated(this.WorkloadClassName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VideoPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoPipelineSpec{`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Featurizer:` + valueToStringGenerated(this.Featurizer) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGenerated(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AudioPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Featurizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.AudioFeaturizer(dAtA[iNdEx:postIndex])
			m.Featurizer = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BacktestSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BacktestSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BacktestSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initial", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Initial = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Windows = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapacityStageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CapacityStageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CapacityStageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServingSiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServingSiteName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tests = append(m.Tests, ModelTestSpec{})
			if err := m.Tests[len(m.Tests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualApproval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ManualApproval = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoricalPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoricalPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoricalPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imputer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.Imputator(dAtA[iNdEx:postIndex])
			m.Imputer = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.CatEncoder(dAtA[iNdEx:postIndex])
			m.Encoder = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassicalEstimatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassicalEstimatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassicalEstimatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgorithmName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlgorithmName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, HyperParameterValue{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompilerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompilerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompilerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compiler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.CompilerName(dAtA[iNdEx:postIndex])
			m.Compiler = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.HardwareTarget(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSplit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSplit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSplit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Auto = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Train", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Train = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validation", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Validation = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Test", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Test = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := SplitType(dAtA[iNdEx:postIndex])
			m.SplitPolicy = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SplitColumn = &s
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Seed = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataStageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataStageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataStageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPipelineName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataPipelineName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DateTimePipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DateTimePipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DateTimePipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imputer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.Imputator(dAtA[iNdEx:postIndex])
			m.Imputer = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Expand = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeepEstimatorLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeepEstimatorLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeepEstimatorLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = NNLayerName(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &NNLayerParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputLayers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputLayers = append(m.InputLayers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeepEstimatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeepEstimatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeepEstimatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = append(m.Architecture, DeepEstimatorLayer{})
			if err := m.Architecture[len(m.Architecture)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = DNNTypeName(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BatchSize = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epochs", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Epochs = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationSplit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidationSplit = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSeq", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsSeq = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpus", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gpus = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loss", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Loss = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DimensionValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DimensionValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DimensionValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnsembleRules) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnsembleRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnsembleRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnsembleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnsembleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnsembleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Base = append(m.Base, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForecastObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForecastObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForecastObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelIndex", wireType)
			}
			m.LevelIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LevelIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForecastingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForecastingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForecastingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TimeColumn = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TargetColumn = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTimeFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DateTimeFormat = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dimensions = append(m.Dimensions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repressors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repressors = append(m.Repressors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreqSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FreqSpec == nil {
				m.FreqSpec = &FreqSpec{}
			}
			if err := m.FreqSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Horizon", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Horizon = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfidenceInterval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConfidenceInterval = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryForHoliday", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.HolidayCountry(dAtA[iNdEx:postIndex])
			m.CountryForHoliday = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DimensionValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DimensionValues = append(m.DimensionValues, DimensionValue{})
			if err := m.DimensionValues[len(m.DimensionValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backtest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Backtest == nil {
				m.Backtest = &BacktestSpec{}
			}
			if err := m.Backtest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForecastConnectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ForecastConnectionName = &s
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forecast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Forecast = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreqSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreqSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreqSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Interval = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.Freq(dAtA[iNdEx:postIndex])
			m.Units = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Hierarchy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hierarchy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hierarchy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupLevels = append(m.GroupLevels, Level{})
			if err := m.GroupLevels[len(m.GroupLevels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemLevel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemLevel == nil {
				m.ItemLevel = &Level{}
			}
			if err := m.ItemLevel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NotifierName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HyperParameterValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HyperParameterValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HyperParameterValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImagePipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImagePipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImagePipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Featurizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.ImageFeaturizer(dAtA[iNdEx:postIndex])
			m.Featurizer = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Level) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Level: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Level: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Horizon", wireType)
			}
			m.Horizon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Horizon |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Freq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.Freq(dAtA[iNdEx:postIndex])
			m.Freq = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.Aggregate(dAtA[iNdEx:postIndex])
			m.Aggregate = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelAutobuilder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelAutobuilder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelAutobuilder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelAutobuilderCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelAutobuilderCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelAutobuilderCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = ModelAutobuilderConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelAutobuilderList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelAutobuilderList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelAutobuilderList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, ModelAutobuilder{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelAutobuilderSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelAutobuilderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelAutobuilderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DataProductName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProductVersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DataProductVersionName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DataSourceName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha1.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.MLTask(dAtA[iNdEx:postIndex])
			m.Task = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objective", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex])
			m.Objective = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TargetColumn = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxTime = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxModels", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxModels = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_inference_v1alpha1.AccessType(dAtA[iNdEx:postIndex])
			m.AccessMethod = &s
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoScale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AutoScale = &b
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataSourceSpec == nil {
				m.DataSourceSpec = &v1alpha1.DataSourceSpec{}
			}
			if err := m.DataSourceSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trainers", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Trainers = &v
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := SearchMethodName(dAtA[iNdEx:postIndex])
			m.SearchMethod = &s
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aborted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Aborted = &b
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabRef == nil {
				m.LabRef = &v11.ObjectReference{}
			}
			if err := m.LabRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelAutobuilderStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelAutobuilderStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelAutobuilderStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlatFileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlatFileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataSourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BestModelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredictorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageRepoName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageRepoName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = ModelAutobuilderPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Models", wireType)
			}
			m.Models = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Models |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainedModels", wireType)
			}
			m.TrainedModels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainedModels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestModelScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BestModelScore = float64(math.Float64frombits(v))
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Estimator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Estimator == nil {
				m.Estimator = &ClassicalEstimatorSpec{}
			}
			if err := m.Estimator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletionTime == nil {
				m.CompletionTime = &v1.Time{}
			}
			if err := m.CompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, ModelAutobuilderCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = ModelConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Model{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = ModelPipelineConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, ModelPipeline{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineRun) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineRun: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineRun: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineRunCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineRunCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineRunCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = PipelineRunConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineRunList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineRunList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineRunList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, ModelPipelineRun{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineRunSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineRunSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineRunSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TriggerName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PipelineName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineRunStageStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineRunStageStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineRunStageStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = StageStatusPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Approved = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovedAt == nil {
				m.ApprovedAt = &v1.Time{}
			}
			if err := m.ApprovedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &v1.Time{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, ModelTestResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineRunStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineRunStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineRunStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stage = ModelPipelineStage(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DataStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TrainingStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UATStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UATStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacityStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CapacityStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProdStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletionTime == nil {
				m.CompletionTime = &v1.Time{}
			}
			if err := m.CompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = PipelinePhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, ModelPipelineRunCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Folder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Folder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultServingSiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DefaultServingSiteName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &DataStageSpec{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Training", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Training == nil {
				m.Training = &TrainingStageSpec{}
			}
			if err := m.Training.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UAT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UAT == nil {
				m.UAT = &UATStageSpec{}
			}
			if err := m.UAT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capacity == nil {
				m.Capacity = &CapacityStageSpec{}
			}
			if err := m.Capacity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prod == nil {
				m.Prod = &ProdStageSpec{}
			}
			if err := m.Prod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha1.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproverAccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ApproverAccountName = &s
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NotifierName = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaselineModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BaselineModelName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPipelineStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPipelineStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPipelineStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, ModelPipelineCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Score = &v2
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Error = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelSearchSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelSearchSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelSearchSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := SearchMethodName(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCost", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxCost = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxTime = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxModels", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxModels = &v
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.MinScore = &v2
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trainers", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Trainers = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SHOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SHOptions == nil {
				m.SHOptions = &SuccessiveHalvingOptions{}
			}
			if err := m.SHOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Test", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Test = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetainTop", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetainTop = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetainFor", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetainFor = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &TrainingResourceRequest{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowList = append(m.AllowList, github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.ClassicEstimatorName(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingEnsemble", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.VotingEnsemble = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StackingEnsemble", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.StackingEnsemble = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.StudyName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.MLTask(dAtA[iNdEx:postIndex])
			m.Task = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objective", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex])
			m.Objective = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preprocessing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Preprocessing == nil {
				m.Preprocessing = &PreprocessingSpec{}
			}
			if err := m.Preprocessing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Estimator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Estimator == nil {
				m.Estimator = &ClassicalEstimatorSpec{}
			}
			if err := m.Estimator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dnn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dnn == nil {
				m.Dnn = &DeepEstimatorSpec{}
			}
			if err := m.Dnn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ensemble", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ensemble == nil {
				m.Ensemble = &EnsembleSpec{}
			}
			if err := m.Ensemble.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Training", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Training == nil {
				m.Training = &TrainingSpec{}
			}
			if err := m.Training.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Tested = &b
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aborted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Aborted = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Published", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Published = &b
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pushed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Pushed = &b
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reported = &b
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Paused = &b
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profiled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Profiled = &b
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Archived = &b
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forecasted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Forecasted = &b
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complied", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Complied = &b
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha1.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forecasting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Forecasting == nil {
				m.Forecasting = &ForecastingSpec{}
			}
			if err := m.Forecasting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compiler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Compiler == nil {
				m.Compiler = &CompilerSpec{}
			}
			if err := m.Compiler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrainStartTime == nil {
				m.TrainStartTime = &v1.Time{}
			}
			if err := m.TrainStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainCompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrainCompletionTime == nil {
				m.TrainCompletionTime = &v1.Time{}
			}
			if err := m.TrainCompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestStartTime == nil {
				m.TestStartTime = &v1.Time{}
			}
			if err := m.TestStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestCompletionTime == nil {
				m.TestCompletionTime = &v1.Time{}
			}
			if err := m.TestCompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletionTime == nil {
				m.CompletionTime = &v1.Time{}
			}
			if err := m.CompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CVScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CVScore = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TrainScore = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TestScore = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Cost = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Best", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Best = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrainResult = append(m.TrainResult, v1alpha11.Measurement{})
			if err := m.TrainResult[len(m.TrainResult)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestResult = append(m.TestResult, v1alpha11.Measurement{})
			if err := m.TestResult[len(m.TestResult)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = ModelPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManifestUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManifestUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightsUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeightsUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelEncoderUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelEncoderUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogsUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MisclassUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MisclassUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForecastUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForecastUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, ModelCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelTestResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelTestResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelTestResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &v1.Time{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, v1alpha11.Measurement{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Error = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelTestSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelTestSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelTestSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinScores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinScores = append(m.MinScores, TestScore{})
			if err := m.MinScores[len(m.MinScores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxTime = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NNLayerParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NNLayerParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NNLayerParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Notebook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notebook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notebook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = NotebookConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Notebook{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookRun) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookRun: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookRun: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookRunCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookRunCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookRunCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = NotebookRunConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookRunList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookRunList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookRunList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, NotebookRun{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookRunSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookRunSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookRunSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotebookName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NotebookName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, NotebookVarValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookRunStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookRunStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookRunStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = NotebookRunPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletionTime == nil {
				m.CompletionTime = &v1.Time{}
			}
			if err := m.CompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, NotebookRunCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchemaRef == nil {
				m.SchemaRef = &v11.ObjectReference{}
			}
			if err := m.SchemaRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ImageName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Requirements = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebPackages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DebPackages = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vars", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vars = append(m.Vars, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha1.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, NotebookCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookVarValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookVarValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookVarValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumericPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumericPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumericPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imputer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.Imputator(dAtA[iNdEx:postIndex])
			m.Imputer = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scaler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.Scaler(dAtA[iNdEx:postIndex])
			m.Scaler = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schedule == nil {
				m.Schedule = &v1alpha11.RunSchedule{}
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GithubEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GithubEvents == nil {
				m.GithubEvents = &v1alpha11.GithubEvents{}
			}
			if err := m.GithubEvents.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreprocessingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreprocessingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreprocessingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categorical", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Categorical == nil {
				m.Categorical = &CategoricalPipelineSpec{}
			}
			if err := m.Categorical.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numeric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Numeric == nil {
				m.Numeric = &NumericPipelineSpec{}
			}
			if err := m.Numeric.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Text == nil {
				m.Text = &TextPipelineSpec{}
			}
			if err := m.Text.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &ImagePipelineSpec{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Audio == nil {
				m.Audio = &AudioPipelineSpec{}
			}
			if err := m.Audio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &VideoPipelineSpec{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataTime == nil {
				m.DataTime = &DateTimePipelineSpec{}
			}
			if err := m.DataTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.FeatureSelector(dAtA[iNdEx:postIndex])
			m.Selector = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reducer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.DimReducer(dAtA[iNdEx:postIndex])
			m.Reducer = &s
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imbalanced", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Imbalanced = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProdStageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProdStageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProdStageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServingSiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServingSiteName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PredictorName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Weight = &v2
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualApproval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ManualApproval = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Report) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Report: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Report: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = ReportConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Report{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EntityRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha1.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := ReportType(dAtA[iNdEx:postIndex])
			m.ReportType = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := ReportFormat(dAtA[iNdEx:postIndex])
			m.Format = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifierRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NotifierRef = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletionTime == nil {
				m.CompletionTime = &v1.Time{}
			}
			if err := m.CompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = ReportPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, ReportCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Study) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Study: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Study: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StudyCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StudyCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StudyCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = StudyConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StudyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StudyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StudyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Study{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StudySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StudySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StudySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabRef == nil {
				m.LabRef = &v11.ObjectReference{}
			}
			if err := m.LabRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.MLTask(dAtA[iNdEx:postIndex])
			m.Task = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objective", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex])
			m.Objective = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Search == nil {
				m.Search = &ModelSearchSpec{}
			}
			if err := m.Search.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preprocessing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Preprocessing == nil {
				m.Preprocessing = &PreprocessingSpec{}
			}
			if err := m.Preprocessing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Training", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Training == nil {
				m.Training = &TrainingSpec{}
			}
			if err := m.Training.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Split", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Split == nil {
				m.Split = &DataSplit{}
			}
			if err := m.Split.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aborted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Aborted = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reported = &b
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Paused = &b
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profiled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Profiled = &b
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelPublished", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ModelPublished = &b
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelImagePushed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ModelImagePushed = &b
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha1.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hierarchy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hierarchy == nil {
				m.Hierarchy = &Hierarchy{}
			}
			if err := m.Hierarchy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StudyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StudyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StudyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Models", wireType)
			}
			m.Models = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Models |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitingToTrainModels", wireType)
			}
			m.WaitingToTrainModels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitingToTrainModels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingModels", wireType)
			}
			m.TrainingModels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingModels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelsFailedTraining", wireType)
			}
			m.ModelsFailedTraining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelsFailedTraining |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainedModels", wireType)
			}
			m.TrainedModels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainedModels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitingToTestModels", wireType)
			}
			m.WaitingToTestModels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitingToTestModels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingModels", wireType)
			}
			m.TestingModels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestingModels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelsFailedTesting", wireType)
			}
			m.ModelsFailedTesting = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelsFailedTesting |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestedModels", wireType)
			}
			m.TestedModels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestedModels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trainers", wireType)
			}
			m.Trainers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Trainers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeTrainers", wireType)
			}
			m.FreeTrainers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeTrainers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusyTrainers", wireType)
			}
			m.BusyTrainers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusyTrainers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &v1.Time{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrainingStartTime == nil {
				m.TrainingStartTime = &v1.Time{}
			}
			if err := m.TrainingStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingCompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrainingCompletionTime == nil {
				m.TrainingCompletionTime = &v1.Time{}
			}
			if err := m.TrainingCompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestingStartTime == nil {
				m.TestingStartTime = &v1.Time{}
			}
			if err := m.TestingStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingCompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestingCompletionTime == nil {
				m.TestingCompletionTime = &v1.Time{}
			}
			if err := m.TestingCompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletionTime == nil {
				m.CompletionTime = &v1.Time{}
			}
			if err := m.CompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BestModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestModelScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BestModelScore = float64(math.Float64frombits(v))
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = StudyPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, StudyCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuccessiveHalvingOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuccessiveHalvingOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuccessiveHalvingOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBudget", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxBudget = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EliminationRate", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EliminationRate = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := ModalityType(dAtA[iNdEx:postIndex])
			m.Modality = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuccessiveHalvingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuccessiveHalvingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuccessiveHalvingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Budget", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Budget = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bracket", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bracket = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rung", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rung = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConfID = &v
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := ModalityType(dAtA[iNdEx:postIndex])
			m.Modality = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Score = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.TextTransformer(dAtA[iNdEx:postIndex])
			m.Encoder = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokenizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Tokenizer = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopWords", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.StopWords = &b
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Pos = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lemma", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Lemma = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stem", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Stem = &b
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Embedding = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrainingResourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrainingResourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrainingResourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gpu = ResourceSize(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpu = ResourceSize(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mem = ResourceSize(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrainingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrainingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrainingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Priority = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.CvType(dAtA[iNdEx:postIndex])
			m.CvType = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CV", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CV = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Folds", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Folds = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Retry = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvalMetrics", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvalMetrics = append(m.EvalMetrics, github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarlyStop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.EarlyStop = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckpointInterval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckpointInterval = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forecast", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Forecast == nil {
				m.Forecast = &ForecastingSpec{}
			}
			if err := m.Forecast.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SH", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SH == nil {
				m.SH = &SuccessiveHalvingSpec{}
			}
			if err := m.SH.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Seed = &v2
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrainingStageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrainingStageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrainingStageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotebookName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NotebookName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LabName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.StudyName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinScore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinScore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualApproval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ManualApproval = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UATStageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UATStageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UATStageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServingSiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServingSiteName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tests = append(m.Tests, ModelTestSpec{})
			if err := m.Tests[len(m.Tests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Auto = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkloadClassName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Featurizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modeldapi_pkg_apis_catalog_v1alpha1.VideoFeaturizer(dAtA[iNdEx:postIndex])
			m.Featurizer = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenerated(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenerated
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenerated
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenerated
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenerated        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenerated          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenerated = fmt.Errorf("proto: unexpected end of group")
)
