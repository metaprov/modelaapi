/**
*
* Copyright (C) 2017 modela authors
* For license information, see LICENSE.txt
 */ // Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/metaprov/modelaapi/pkg/apis/data/v1alpha1/generated.proto

package v1alpha1

import (
	encoding_binary "encoding/binary"
	fmt "fmt"

	io "io"

	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1 "github.com/metaprov/modelaapi/pkg/apis/catalog/v1alpha1"
	v1alpha1 "github.com/metaprov/modelaapi/pkg/apis/catalog/v1alpha1"
	k8s_io_api_core_v1 "k8s.io/api/core/v1"
	v11 "k8s.io/api/core/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

func (m *ApprovalReviewStatus) Reset()      { *m = ApprovalReviewStatus{} }
func (*ApprovalReviewStatus) ProtoMessage() {}
func (*ApprovalReviewStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{0}
}
func (m *ApprovalReviewStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalReviewStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ApprovalReviewStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalReviewStatus.Merge(m, src)
}
func (m *ApprovalReviewStatus) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalReviewStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalReviewStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalReviewStatus proto.InternalMessageInfo

func (m *ApprovalSpec) Reset()      { *m = ApprovalSpec{} }
func (*ApprovalSpec) ProtoMessage() {}
func (*ApprovalSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{1}
}
func (m *ApprovalSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ApprovalSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalSpec.Merge(m, src)
}
func (m *ApprovalSpec) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalSpec proto.InternalMessageInfo

func (m *ApprovalStatus) Reset()      { *m = ApprovalStatus{} }
func (*ApprovalStatus) ProtoMessage() {}
func (*ApprovalStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{2}
}
func (m *ApprovalStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ApprovalStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalStatus.Merge(m, src)
}
func (m *ApprovalStatus) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalStatus proto.InternalMessageInfo

func (m *BarChartSpec) Reset()      { *m = BarChartSpec{} }
func (*BarChartSpec) ProtoMessage() {}
func (*BarChartSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{3}
}
func (m *BarChartSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BarChartSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BarChartSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BarChartSpec.Merge(m, src)
}
func (m *BarChartSpec) XXX_Size() int {
	return m.Size()
}
func (m *BarChartSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BarChartSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BarChartSpec proto.InternalMessageInfo

func (m *Column) Reset()      { *m = Column{} }
func (*Column) ProtoMessage() {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{4}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.Size()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

func (m *ColumnHistogram) Reset()      { *m = ColumnHistogram{} }
func (*ColumnHistogram) ProtoMessage() {}
func (*ColumnHistogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{5}
}
func (m *ColumnHistogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnHistogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnHistogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnHistogram.Merge(m, src)
}
func (m *ColumnHistogram) XXX_Size() int {
	return m.Size()
}
func (m *ColumnHistogram) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnHistogram.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnHistogram proto.InternalMessageInfo

func (m *ColumnSpec) Reset()      { *m = ColumnSpec{} }
func (*ColumnSpec) ProtoMessage() {}
func (*ColumnSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{6}
}
func (m *ColumnSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnSpec.Merge(m, src)
}
func (m *ColumnSpec) XXX_Size() int {
	return m.Size()
}
func (m *ColumnSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnSpec proto.InternalMessageInfo

func (m *ComponentSpec) Reset()      { *m = ComponentSpec{} }
func (*ComponentSpec) ProtoMessage() {}
func (*ComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{7}
}
func (m *ComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComponentSpec.Merge(m, src)
}
func (m *ComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *ComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ComponentSpec proto.InternalMessageInfo

func (m *ComponentView) Reset()      { *m = ComponentView{} }
func (*ComponentView) ProtoMessage() {}
func (*ComponentView) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{8}
}
func (m *ComponentView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComponentView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ComponentView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComponentView.Merge(m, src)
}
func (m *ComponentView) XXX_Size() int {
	return m.Size()
}
func (m *ComponentView) XXX_DiscardUnknown() {
	xxx_messageInfo_ComponentView.DiscardUnknown(m)
}

var xxx_messageInfo_ComponentView proto.InternalMessageInfo

func (m *Correlation) Reset()      { *m = Correlation{} }
func (*Correlation) ProtoMessage() {}
func (*Correlation) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{9}
}
func (m *Correlation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Correlation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Correlation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Correlation.Merge(m, src)
}
func (m *Correlation) XXX_Size() int {
	return m.Size()
}
func (m *Correlation) XXX_DiscardUnknown() {
	xxx_messageInfo_Correlation.DiscardUnknown(m)
}

var xxx_messageInfo_Correlation proto.InternalMessageInfo

func (m *CorrelationSpec) Reset()      { *m = CorrelationSpec{} }
func (*CorrelationSpec) ProtoMessage() {}
func (*CorrelationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{10}
}
func (m *CorrelationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CorrelationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CorrelationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CorrelationSpec.Merge(m, src)
}
func (m *CorrelationSpec) XXX_Size() int {
	return m.Size()
}
func (m *CorrelationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CorrelationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CorrelationSpec proto.InternalMessageInfo

func (m *CsvFileSpec) Reset()      { *m = CsvFileSpec{} }
func (*CsvFileSpec) ProtoMessage() {}
func (*CsvFileSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{11}
}
func (m *CsvFileSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CsvFileSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CsvFileSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CsvFileSpec.Merge(m, src)
}
func (m *CsvFileSpec) XXX_Size() int {
	return m.Size()
}
func (m *CsvFileSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CsvFileSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CsvFileSpec proto.InternalMessageInfo

func (m *DataInputSpec) Reset()      { *m = DataInputSpec{} }
func (*DataInputSpec) ProtoMessage() {}
func (*DataInputSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{12}
}
func (m *DataInputSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataInputSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataInputSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataInputSpec.Merge(m, src)
}
func (m *DataInputSpec) XXX_Size() int {
	return m.Size()
}
func (m *DataInputSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DataInputSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DataInputSpec proto.InternalMessageInfo

func (m *DataOutputSpec) Reset()      { *m = DataOutputSpec{} }
func (*DataOutputSpec) ProtoMessage() {}
func (*DataOutputSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{13}
}
func (m *DataOutputSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataOutputSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataOutputSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataOutputSpec.Merge(m, src)
}
func (m *DataOutputSpec) XXX_Size() int {
	return m.Size()
}
func (m *DataOutputSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DataOutputSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DataOutputSpec proto.InternalMessageInfo

func (m *DataPipeline) Reset()      { *m = DataPipeline{} }
func (*DataPipeline) ProtoMessage() {}
func (*DataPipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{14}
}
func (m *DataPipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataPipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataPipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataPipeline.Merge(m, src)
}
func (m *DataPipeline) XXX_Size() int {
	return m.Size()
}
func (m *DataPipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_DataPipeline.DiscardUnknown(m)
}

var xxx_messageInfo_DataPipeline proto.InternalMessageInfo

func (m *DataPipelineList) Reset()      { *m = DataPipelineList{} }
func (*DataPipelineList) ProtoMessage() {}
func (*DataPipelineList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{15}
}
func (m *DataPipelineList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataPipelineList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataPipelineList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataPipelineList.Merge(m, src)
}
func (m *DataPipelineList) XXX_Size() int {
	return m.Size()
}
func (m *DataPipelineList) XXX_DiscardUnknown() {
	xxx_messageInfo_DataPipelineList.DiscardUnknown(m)
}

var xxx_messageInfo_DataPipelineList proto.InternalMessageInfo

func (m *DataPipelineRun) Reset()      { *m = DataPipelineRun{} }
func (*DataPipelineRun) ProtoMessage() {}
func (*DataPipelineRun) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{16}
}
func (m *DataPipelineRun) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataPipelineRun) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataPipelineRun) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataPipelineRun.Merge(m, src)
}
func (m *DataPipelineRun) XXX_Size() int {
	return m.Size()
}
func (m *DataPipelineRun) XXX_DiscardUnknown() {
	xxx_messageInfo_DataPipelineRun.DiscardUnknown(m)
}

var xxx_messageInfo_DataPipelineRun proto.InternalMessageInfo

func (m *DataPipelineRunCondition) Reset()      { *m = DataPipelineRunCondition{} }
func (*DataPipelineRunCondition) ProtoMessage() {}
func (*DataPipelineRunCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{17}
}
func (m *DataPipelineRunCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataPipelineRunCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataPipelineRunCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataPipelineRunCondition.Merge(m, src)
}
func (m *DataPipelineRunCondition) XXX_Size() int {
	return m.Size()
}
func (m *DataPipelineRunCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_DataPipelineRunCondition.DiscardUnknown(m)
}

var xxx_messageInfo_DataPipelineRunCondition proto.InternalMessageInfo

func (m *DataPipelineRunList) Reset()      { *m = DataPipelineRunList{} }
func (*DataPipelineRunList) ProtoMessage() {}
func (*DataPipelineRunList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{18}
}
func (m *DataPipelineRunList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataPipelineRunList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataPipelineRunList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataPipelineRunList.Merge(m, src)
}
func (m *DataPipelineRunList) XXX_Size() int {
	return m.Size()
}
func (m *DataPipelineRunList) XXX_DiscardUnknown() {
	xxx_messageInfo_DataPipelineRunList.DiscardUnknown(m)
}

var xxx_messageInfo_DataPipelineRunList proto.InternalMessageInfo

func (m *DataPipelineRunSpec) Reset()      { *m = DataPipelineRunSpec{} }
func (*DataPipelineRunSpec) ProtoMessage() {}
func (*DataPipelineRunSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{19}
}
func (m *DataPipelineRunSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataPipelineRunSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataPipelineRunSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataPipelineRunSpec.Merge(m, src)
}
func (m *DataPipelineRunSpec) XXX_Size() int {
	return m.Size()
}
func (m *DataPipelineRunSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DataPipelineRunSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DataPipelineRunSpec proto.InternalMessageInfo

func (m *DataPipelineRunStatus) Reset()      { *m = DataPipelineRunStatus{} }
func (*DataPipelineRunStatus) ProtoMessage() {}
func (*DataPipelineRunStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{20}
}
func (m *DataPipelineRunStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataPipelineRunStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataPipelineRunStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataPipelineRunStatus.Merge(m, src)
}
func (m *DataPipelineRunStatus) XXX_Size() int {
	return m.Size()
}
func (m *DataPipelineRunStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DataPipelineRunStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DataPipelineRunStatus proto.InternalMessageInfo

func (m *DataPipelineSpec) Reset()      { *m = DataPipelineSpec{} }
func (*DataPipelineSpec) ProtoMessage() {}
func (*DataPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{21}
}
func (m *DataPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataPipelineSpec.Merge(m, src)
}
func (m *DataPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *DataPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DataPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DataPipelineSpec proto.InternalMessageInfo

func (m *DataPipelineStatus) Reset()      { *m = DataPipelineStatus{} }
func (*DataPipelineStatus) ProtoMessage() {}
func (*DataPipelineStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{22}
}
func (m *DataPipelineStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataPipelineStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataPipelineStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataPipelineStatus.Merge(m, src)
}
func (m *DataPipelineStatus) XXX_Size() int {
	return m.Size()
}
func (m *DataPipelineStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DataPipelineStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DataPipelineStatus proto.InternalMessageInfo

func (m *DataProduct) Reset()      { *m = DataProduct{} }
func (*DataProduct) ProtoMessage() {}
func (*DataProduct) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{23}
}
func (m *DataProduct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProduct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataProduct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProduct.Merge(m, src)
}
func (m *DataProduct) XXX_Size() int {
	return m.Size()
}
func (m *DataProduct) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProduct.DiscardUnknown(m)
}

var xxx_messageInfo_DataProduct proto.InternalMessageInfo

func (m *DataProductList) Reset()      { *m = DataProductList{} }
func (*DataProductList) ProtoMessage() {}
func (*DataProductList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{24}
}
func (m *DataProductList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProductList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataProductList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProductList.Merge(m, src)
}
func (m *DataProductList) XXX_Size() int {
	return m.Size()
}
func (m *DataProductList) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProductList.DiscardUnknown(m)
}

var xxx_messageInfo_DataProductList proto.InternalMessageInfo

func (m *DataProductSpec) Reset()      { *m = DataProductSpec{} }
func (*DataProductSpec) ProtoMessage() {}
func (*DataProductSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{25}
}
func (m *DataProductSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProductSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataProductSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProductSpec.Merge(m, src)
}
func (m *DataProductSpec) XXX_Size() int {
	return m.Size()
}
func (m *DataProductSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProductSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DataProductSpec proto.InternalMessageInfo

func (m *DataProductStatus) Reset()      { *m = DataProductStatus{} }
func (*DataProductStatus) ProtoMessage() {}
func (*DataProductStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{26}
}
func (m *DataProductStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProductStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataProductStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProductStatus.Merge(m, src)
}
func (m *DataProductStatus) XXX_Size() int {
	return m.Size()
}
func (m *DataProductStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProductStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DataProductStatus proto.InternalMessageInfo

func (m *DataProductVersion) Reset()      { *m = DataProductVersion{} }
func (*DataProductVersion) ProtoMessage() {}
func (*DataProductVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{27}
}
func (m *DataProductVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProductVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataProductVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProductVersion.Merge(m, src)
}
func (m *DataProductVersion) XXX_Size() int {
	return m.Size()
}
func (m *DataProductVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProductVersion.DiscardUnknown(m)
}

var xxx_messageInfo_DataProductVersion proto.InternalMessageInfo

func (m *DataProductVersionList) Reset()      { *m = DataProductVersionList{} }
func (*DataProductVersionList) ProtoMessage() {}
func (*DataProductVersionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{28}
}
func (m *DataProductVersionList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProductVersionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataProductVersionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProductVersionList.Merge(m, src)
}
func (m *DataProductVersionList) XXX_Size() int {
	return m.Size()
}
func (m *DataProductVersionList) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProductVersionList.DiscardUnknown(m)
}

var xxx_messageInfo_DataProductVersionList proto.InternalMessageInfo

func (m *DataProductVersionSpec) Reset()      { *m = DataProductVersionSpec{} }
func (*DataProductVersionSpec) ProtoMessage() {}
func (*DataProductVersionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{29}
}
func (m *DataProductVersionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProductVersionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataProductVersionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProductVersionSpec.Merge(m, src)
}
func (m *DataProductVersionSpec) XXX_Size() int {
	return m.Size()
}
func (m *DataProductVersionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProductVersionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DataProductVersionSpec proto.InternalMessageInfo

func (m *DataProductVersionStatus) Reset()      { *m = DataProductVersionStatus{} }
func (*DataProductVersionStatus) ProtoMessage() {}
func (*DataProductVersionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{30}
}
func (m *DataProductVersionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProductVersionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataProductVersionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProductVersionStatus.Merge(m, src)
}
func (m *DataProductVersionStatus) XXX_Size() int {
	return m.Size()
}
func (m *DataProductVersionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProductVersionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DataProductVersionStatus proto.InternalMessageInfo

func (m *DataSource) Reset()      { *m = DataSource{} }
func (*DataSource) ProtoMessage() {}
func (*DataSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{31}
}
func (m *DataSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSource.Merge(m, src)
}
func (m *DataSource) XXX_Size() int {
	return m.Size()
}
func (m *DataSource) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSource.DiscardUnknown(m)
}

var xxx_messageInfo_DataSource proto.InternalMessageInfo

func (m *DataSourceList) Reset()      { *m = DataSourceList{} }
func (*DataSourceList) ProtoMessage() {}
func (*DataSourceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{32}
}
func (m *DataSourceList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSourceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataSourceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSourceList.Merge(m, src)
}
func (m *DataSourceList) XXX_Size() int {
	return m.Size()
}
func (m *DataSourceList) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSourceList.DiscardUnknown(m)
}

var xxx_messageInfo_DataSourceList proto.InternalMessageInfo

func (m *DataSourceSpec) Reset()      { *m = DataSourceSpec{} }
func (*DataSourceSpec) ProtoMessage() {}
func (*DataSourceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{33}
}
func (m *DataSourceSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSourceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataSourceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSourceSpec.Merge(m, src)
}
func (m *DataSourceSpec) XXX_Size() int {
	return m.Size()
}
func (m *DataSourceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSourceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DataSourceSpec proto.InternalMessageInfo

func (m *DataSourceStatus) Reset()      { *m = DataSourceStatus{} }
func (*DataSourceStatus) ProtoMessage() {}
func (*DataSourceStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{34}
}
func (m *DataSourceStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSourceStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataSourceStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSourceStatus.Merge(m, src)
}
func (m *DataSourceStatus) XXX_Size() int {
	return m.Size()
}
func (m *DataSourceStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSourceStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DataSourceStatus proto.InternalMessageInfo

func (m *Dataset) Reset()      { *m = Dataset{} }
func (*Dataset) ProtoMessage() {}
func (*Dataset) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{35}
}
func (m *Dataset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dataset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Dataset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dataset.Merge(m, src)
}
func (m *Dataset) XXX_Size() int {
	return m.Size()
}
func (m *Dataset) XXX_DiscardUnknown() {
	xxx_messageInfo_Dataset.DiscardUnknown(m)
}

var xxx_messageInfo_Dataset proto.InternalMessageInfo

func (m *DatasetGroupByStatus) Reset()      { *m = DatasetGroupByStatus{} }
func (*DatasetGroupByStatus) ProtoMessage() {}
func (*DatasetGroupByStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{36}
}
func (m *DatasetGroupByStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatasetGroupByStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatasetGroupByStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatasetGroupByStatus.Merge(m, src)
}
func (m *DatasetGroupByStatus) XXX_Size() int {
	return m.Size()
}
func (m *DatasetGroupByStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DatasetGroupByStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DatasetGroupByStatus proto.InternalMessageInfo

func (m *DatasetList) Reset()      { *m = DatasetList{} }
func (*DatasetList) ProtoMessage() {}
func (*DatasetList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{37}
}
func (m *DatasetList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatasetList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatasetList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatasetList.Merge(m, src)
}
func (m *DatasetList) XXX_Size() int {
	return m.Size()
}
func (m *DatasetList) XXX_DiscardUnknown() {
	xxx_messageInfo_DatasetList.DiscardUnknown(m)
}

var xxx_messageInfo_DatasetList proto.InternalMessageInfo

func (m *DatasetSnapshot) Reset()      { *m = DatasetSnapshot{} }
func (*DatasetSnapshot) ProtoMessage() {}
func (*DatasetSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{38}
}
func (m *DatasetSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatasetSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatasetSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatasetSnapshot.Merge(m, src)
}
func (m *DatasetSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *DatasetSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_DatasetSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_DatasetSnapshot proto.InternalMessageInfo

func (m *DatasetSnapshotList) Reset()      { *m = DatasetSnapshotList{} }
func (*DatasetSnapshotList) ProtoMessage() {}
func (*DatasetSnapshotList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{39}
}
func (m *DatasetSnapshotList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatasetSnapshotList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatasetSnapshotList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatasetSnapshotList.Merge(m, src)
}
func (m *DatasetSnapshotList) XXX_Size() int {
	return m.Size()
}
func (m *DatasetSnapshotList) XXX_DiscardUnknown() {
	xxx_messageInfo_DatasetSnapshotList.DiscardUnknown(m)
}

var xxx_messageInfo_DatasetSnapshotList proto.InternalMessageInfo

func (m *DatasetSnapshotSpec) Reset()      { *m = DatasetSnapshotSpec{} }
func (*DatasetSnapshotSpec) ProtoMessage() {}
func (*DatasetSnapshotSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{40}
}
func (m *DatasetSnapshotSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatasetSnapshotSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatasetSnapshotSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatasetSnapshotSpec.Merge(m, src)
}
func (m *DatasetSnapshotSpec) XXX_Size() int {
	return m.Size()
}
func (m *DatasetSnapshotSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DatasetSnapshotSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DatasetSnapshotSpec proto.InternalMessageInfo

func (m *DatasetSnapshotStatus) Reset()      { *m = DatasetSnapshotStatus{} }
func (*DatasetSnapshotStatus) ProtoMessage() {}
func (*DatasetSnapshotStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{41}
}
func (m *DatasetSnapshotStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatasetSnapshotStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatasetSnapshotStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatasetSnapshotStatus.Merge(m, src)
}
func (m *DatasetSnapshotStatus) XXX_Size() int {
	return m.Size()
}
func (m *DatasetSnapshotStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DatasetSnapshotStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DatasetSnapshotStatus proto.InternalMessageInfo

func (m *DatasetSpec) Reset()      { *m = DatasetSpec{} }
func (*DatasetSpec) ProtoMessage() {}
func (*DatasetSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{42}
}
func (m *DatasetSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatasetSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatasetSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatasetSpec.Merge(m, src)
}
func (m *DatasetSpec) XXX_Size() int {
	return m.Size()
}
func (m *DatasetSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DatasetSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DatasetSpec proto.InternalMessageInfo

func (m *DatasetStatistics) Reset()      { *m = DatasetStatistics{} }
func (*DatasetStatistics) ProtoMessage() {}
func (*DatasetStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{43}
}
func (m *DatasetStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatasetStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatasetStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatasetStatistics.Merge(m, src)
}
func (m *DatasetStatistics) XXX_Size() int {
	return m.Size()
}
func (m *DatasetStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_DatasetStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_DatasetStatistics proto.InternalMessageInfo

func (m *DatasetStatus) Reset()      { *m = DatasetStatus{} }
func (*DatasetStatus) ProtoMessage() {}
func (*DatasetStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{44}
}
func (m *DatasetStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatasetStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatasetStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatasetStatus.Merge(m, src)
}
func (m *DatasetStatus) XXX_Size() int {
	return m.Size()
}
func (m *DatasetStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DatasetStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DatasetStatus proto.InternalMessageInfo

func (m *DriftThreshold) Reset()      { *m = DriftThreshold{} }
func (*DriftThreshold) ProtoMessage() {}
func (*DriftThreshold) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{45}
}
func (m *DriftThreshold) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DriftThreshold) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DriftThreshold) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DriftThreshold.Merge(m, src)
}
func (m *DriftThreshold) XXX_Size() int {
	return m.Size()
}
func (m *DriftThreshold) XXX_DiscardUnknown() {
	xxx_messageInfo_DriftThreshold.DiscardUnknown(m)
}

var xxx_messageInfo_DriftThreshold proto.InternalMessageInfo

func (m *Entity) Reset()      { *m = Entity{} }
func (*Entity) ProtoMessage() {}
func (*Entity) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{46}
}
func (m *Entity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Entity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entity.Merge(m, src)
}
func (m *Entity) XXX_Size() int {
	return m.Size()
}
func (m *Entity) XXX_DiscardUnknown() {
	xxx_messageInfo_Entity.DiscardUnknown(m)
}

var xxx_messageInfo_Entity proto.InternalMessageInfo

func (m *EntityList) Reset()      { *m = EntityList{} }
func (*EntityList) ProtoMessage() {}
func (*EntityList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{47}
}
func (m *EntityList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntityList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EntityList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntityList.Merge(m, src)
}
func (m *EntityList) XXX_Size() int {
	return m.Size()
}
func (m *EntityList) XXX_DiscardUnknown() {
	xxx_messageInfo_EntityList.DiscardUnknown(m)
}

var xxx_messageInfo_EntityList proto.InternalMessageInfo

func (m *EntitySpec) Reset()      { *m = EntitySpec{} }
func (*EntitySpec) ProtoMessage() {}
func (*EntitySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{48}
}
func (m *EntitySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntitySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EntitySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntitySpec.Merge(m, src)
}
func (m *EntitySpec) XXX_Size() int {
	return m.Size()
}
func (m *EntitySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_EntitySpec.DiscardUnknown(m)
}

var xxx_messageInfo_EntitySpec proto.InternalMessageInfo

func (m *EntityStatus) Reset()      { *m = EntityStatus{} }
func (*EntityStatus) ProtoMessage() {}
func (*EntityStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{49}
}
func (m *EntityStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntityStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EntityStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntityStatus.Merge(m, src)
}
func (m *EntityStatus) XXX_Size() int {
	return m.Size()
}
func (m *EntityStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_EntityStatus.DiscardUnknown(m)
}

var xxx_messageInfo_EntityStatus proto.InternalMessageInfo

func (m *ExcelNotebookSpec) Reset()      { *m = ExcelNotebookSpec{} }
func (*ExcelNotebookSpec) ProtoMessage() {}
func (*ExcelNotebookSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{50}
}
func (m *ExcelNotebookSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExcelNotebookSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExcelNotebookSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExcelNotebookSpec.Merge(m, src)
}
func (m *ExcelNotebookSpec) XXX_Size() int {
	return m.Size()
}
func (m *ExcelNotebookSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ExcelNotebookSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ExcelNotebookSpec proto.InternalMessageInfo

func (m *ExcelSheetArea) Reset()      { *m = ExcelSheetArea{} }
func (*ExcelSheetArea) ProtoMessage() {}
func (*ExcelSheetArea) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{51}
}
func (m *ExcelSheetArea) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExcelSheetArea) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExcelSheetArea) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExcelSheetArea.Merge(m, src)
}
func (m *ExcelSheetArea) XXX_Size() int {
	return m.Size()
}
func (m *ExcelSheetArea) XXX_DiscardUnknown() {
	xxx_messageInfo_ExcelSheetArea.DiscardUnknown(m)
}

var xxx_messageInfo_ExcelSheetArea proto.InternalMessageInfo

func (m *FeatureGroup) Reset()      { *m = FeatureGroup{} }
func (*FeatureGroup) ProtoMessage() {}
func (*FeatureGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{52}
}
func (m *FeatureGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureGroup.Merge(m, src)
}
func (m *FeatureGroup) XXX_Size() int {
	return m.Size()
}
func (m *FeatureGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureGroup.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureGroup proto.InternalMessageInfo

func (m *FeatureGroupList) Reset()      { *m = FeatureGroupList{} }
func (*FeatureGroupList) ProtoMessage() {}
func (*FeatureGroupList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{53}
}
func (m *FeatureGroupList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureGroupList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureGroupList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureGroupList.Merge(m, src)
}
func (m *FeatureGroupList) XXX_Size() int {
	return m.Size()
}
func (m *FeatureGroupList) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureGroupList.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureGroupList proto.InternalMessageInfo

func (m *FeatureGroupSpec) Reset()      { *m = FeatureGroupSpec{} }
func (*FeatureGroupSpec) ProtoMessage() {}
func (*FeatureGroupSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{54}
}
func (m *FeatureGroupSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureGroupSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureGroupSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureGroupSpec.Merge(m, src)
}
func (m *FeatureGroupSpec) XXX_Size() int {
	return m.Size()
}
func (m *FeatureGroupSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureGroupSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureGroupSpec proto.InternalMessageInfo

func (m *FeatureGroupStatus) Reset()      { *m = FeatureGroupStatus{} }
func (*FeatureGroupStatus) ProtoMessage() {}
func (*FeatureGroupStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{55}
}
func (m *FeatureGroupStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureGroupStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureGroupStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureGroupStatus.Merge(m, src)
}
func (m *FeatureGroupStatus) XXX_Size() int {
	return m.Size()
}
func (m *FeatureGroupStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureGroupStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureGroupStatus proto.InternalMessageInfo

func (m *FeatureHistogram) Reset()      { *m = FeatureHistogram{} }
func (*FeatureHistogram) ProtoMessage() {}
func (*FeatureHistogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{56}
}
func (m *FeatureHistogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureHistogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureHistogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureHistogram.Merge(m, src)
}
func (m *FeatureHistogram) XXX_Size() int {
	return m.Size()
}
func (m *FeatureHistogram) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureHistogram.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureHistogram proto.InternalMessageInfo

func (m *FeatureHistogramList) Reset()      { *m = FeatureHistogramList{} }
func (*FeatureHistogramList) ProtoMessage() {}
func (*FeatureHistogramList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{57}
}
func (m *FeatureHistogramList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureHistogramList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureHistogramList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureHistogramList.Merge(m, src)
}
func (m *FeatureHistogramList) XXX_Size() int {
	return m.Size()
}
func (m *FeatureHistogramList) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureHistogramList.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureHistogramList proto.InternalMessageInfo

func (m *FeatureHistogramSpec) Reset()      { *m = FeatureHistogramSpec{} }
func (*FeatureHistogramSpec) ProtoMessage() {}
func (*FeatureHistogramSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{58}
}
func (m *FeatureHistogramSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureHistogramSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureHistogramSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureHistogramSpec.Merge(m, src)
}
func (m *FeatureHistogramSpec) XXX_Size() int {
	return m.Size()
}
func (m *FeatureHistogramSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureHistogramSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureHistogramSpec proto.InternalMessageInfo

func (m *FeatureHistogramStatus) Reset()      { *m = FeatureHistogramStatus{} }
func (*FeatureHistogramStatus) ProtoMessage() {}
func (*FeatureHistogramStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{59}
}
func (m *FeatureHistogramStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureHistogramStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureHistogramStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureHistogramStatus.Merge(m, src)
}
func (m *FeatureHistogramStatus) XXX_Size() int {
	return m.Size()
}
func (m *FeatureHistogramStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureHistogramStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureHistogramStatus proto.InternalMessageInfo

func (m *FeatureStatistics) Reset()      { *m = FeatureStatistics{} }
func (*FeatureStatistics) ProtoMessage() {}
func (*FeatureStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{60}
}
func (m *FeatureStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FeatureStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureStatistics.Merge(m, src)
}
func (m *FeatureStatistics) XXX_Size() int {
	return m.Size()
}
func (m *FeatureStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureStatistics proto.InternalMessageInfo

func (m *FlatFileFormatSpec) Reset()      { *m = FlatFileFormatSpec{} }
func (*FlatFileFormatSpec) ProtoMessage() {}
func (*FlatFileFormatSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{61}
}
func (m *FlatFileFormatSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlatFileFormatSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FlatFileFormatSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlatFileFormatSpec.Merge(m, src)
}
func (m *FlatFileFormatSpec) XXX_Size() int {
	return m.Size()
}
func (m *FlatFileFormatSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FlatFileFormatSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FlatFileFormatSpec proto.InternalMessageInfo

func (m *GaugeSpec) Reset()      { *m = GaugeSpec{} }
func (*GaugeSpec) ProtoMessage() {}
func (*GaugeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{62}
}
func (m *GaugeSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GaugeSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GaugeSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GaugeSpec.Merge(m, src)
}
func (m *GaugeSpec) XXX_Size() int {
	return m.Size()
}
func (m *GaugeSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_GaugeSpec.DiscardUnknown(m)
}

var xxx_messageInfo_GaugeSpec proto.InternalMessageInfo

func (m *GitLocation) Reset()      { *m = GitLocation{} }
func (*GitLocation) ProtoMessage() {}
func (*GitLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{63}
}
func (m *GitLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GitLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GitLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GitLocation.Merge(m, src)
}
func (m *GitLocation) XXX_Size() int {
	return m.Size()
}
func (m *GitLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_GitLocation.DiscardUnknown(m)
}

var xxx_messageInfo_GitLocation proto.InternalMessageInfo

func (m *GroupBySpec) Reset()      { *m = GroupBySpec{} }
func (*GroupBySpec) ProtoMessage() {}
func (*GroupBySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{64}
}
func (m *GroupBySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupBySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GroupBySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupBySpec.Merge(m, src)
}
func (m *GroupBySpec) XXX_Size() int {
	return m.Size()
}
func (m *GroupBySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupBySpec.DiscardUnknown(m)
}

var xxx_messageInfo_GroupBySpec proto.InternalMessageInfo

func (m *GroupDatasetLocationStatus) Reset()      { *m = GroupDatasetLocationStatus{} }
func (*GroupDatasetLocationStatus) ProtoMessage() {}
func (*GroupDatasetLocationStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{65}
}
func (m *GroupDatasetLocationStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupDatasetLocationStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GroupDatasetLocationStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupDatasetLocationStatus.Merge(m, src)
}
func (m *GroupDatasetLocationStatus) XXX_Size() int {
	return m.Size()
}
func (m *GroupDatasetLocationStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupDatasetLocationStatus.DiscardUnknown(m)
}

var xxx_messageInfo_GroupDatasetLocationStatus proto.InternalMessageInfo

func (m *HistogramSpec) Reset()      { *m = HistogramSpec{} }
func (*HistogramSpec) ProtoMessage() {}
func (*HistogramSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{66}
}
func (m *HistogramSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistogramSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HistogramSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistogramSpec.Merge(m, src)
}
func (m *HistogramSpec) XXX_Size() int {
	return m.Size()
}
func (m *HistogramSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_HistogramSpec.DiscardUnknown(m)
}

var xxx_messageInfo_HistogramSpec proto.InternalMessageInfo

func (m *ImageLocation) Reset()      { *m = ImageLocation{} }
func (*ImageLocation) ProtoMessage() {}
func (*ImageLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{67}
}
func (m *ImageLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ImageLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageLocation.Merge(m, src)
}
func (m *ImageLocation) XXX_Size() int {
	return m.Size()
}
func (m *ImageLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageLocation.DiscardUnknown(m)
}

var xxx_messageInfo_ImageLocation proto.InternalMessageInfo

func (m *KPI) Reset()      { *m = KPI{} }
func (*KPI) ProtoMessage() {}
func (*KPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{68}
}
func (m *KPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *KPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KPI.Merge(m, src)
}
func (m *KPI) XXX_Size() int {
	return m.Size()
}
func (m *KPI) XXX_DiscardUnknown() {
	xxx_messageInfo_KPI.DiscardUnknown(m)
}

var xxx_messageInfo_KPI proto.InternalMessageInfo

func (m *LabelingRule) Reset()      { *m = LabelingRule{} }
func (*LabelingRule) ProtoMessage() {}
func (*LabelingRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{69}
}
func (m *LabelingRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelingRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LabelingRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelingRule.Merge(m, src)
}
func (m *LabelingRule) XXX_Size() int {
	return m.Size()
}
func (m *LabelingRule) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelingRule.DiscardUnknown(m)
}

var xxx_messageInfo_LabelingRule proto.InternalMessageInfo

func (m *LabelingSpec) Reset()      { *m = LabelingSpec{} }
func (*LabelingSpec) ProtoMessage() {}
func (*LabelingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{70}
}
func (m *LabelingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LabelingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelingSpec.Merge(m, src)
}
func (m *LabelingSpec) XXX_Size() int {
	return m.Size()
}
func (m *LabelingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LabelingSpec proto.InternalMessageInfo

func (m *LineChartSpec) Reset()      { *m = LineChartSpec{} }
func (*LineChartSpec) ProtoMessage() {}
func (*LineChartSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{71}
}
func (m *LineChartSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LineChartSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LineChartSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LineChartSpec.Merge(m, src)
}
func (m *LineChartSpec) XXX_Size() int {
	return m.Size()
}
func (m *LineChartSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LineChartSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LineChartSpec proto.InternalMessageInfo

func (m *MaterializationSpec) Reset()      { *m = MaterializationSpec{} }
func (*MaterializationSpec) ProtoMessage() {}
func (*MaterializationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{72}
}
func (m *MaterializationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MaterializationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializationSpec.Merge(m, src)
}
func (m *MaterializationSpec) XXX_Size() int {
	return m.Size()
}
func (m *MaterializationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializationSpec proto.InternalMessageInfo

func (m *MetricSpec) Reset()      { *m = MetricSpec{} }
func (*MetricSpec) ProtoMessage() {}
func (*MetricSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{73}
}
func (m *MetricSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetricSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricSpec.Merge(m, src)
}
func (m *MetricSpec) XXX_Size() int {
	return m.Size()
}
func (m *MetricSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MetricSpec proto.InternalMessageInfo

func (m *OutlierStatistics) Reset()      { *m = OutlierStatistics{} }
func (*OutlierStatistics) ProtoMessage() {}
func (*OutlierStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{74}
}
func (m *OutlierStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutlierStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OutlierStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutlierStatistics.Merge(m, src)
}
func (m *OutlierStatistics) XXX_Size() int {
	return m.Size()
}
func (m *OutlierStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_OutlierStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_OutlierStatistics proto.InternalMessageInfo

func (m *PageSpec) Reset()      { *m = PageSpec{} }
func (*PageSpec) ProtoMessage() {}
func (*PageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{75}
}
func (m *PageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PageSpec.Merge(m, src)
}
func (m *PageSpec) XXX_Size() int {
	return m.Size()
}
func (m *PageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PageSpec proto.InternalMessageInfo

func (m *ParquetFileSpec) Reset()      { *m = ParquetFileSpec{} }
func (*ParquetFileSpec) ProtoMessage() {}
func (*ParquetFileSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{76}
}
func (m *ParquetFileSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParquetFileSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ParquetFileSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParquetFileSpec.Merge(m, src)
}
func (m *ParquetFileSpec) XXX_Size() int {
	return m.Size()
}
func (m *ParquetFileSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ParquetFileSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ParquetFileSpec proto.InternalMessageInfo

func (m *Recipe) Reset()      { *m = Recipe{} }
func (*Recipe) ProtoMessage() {}
func (*Recipe) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{77}
}
func (m *Recipe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Recipe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Recipe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Recipe.Merge(m, src)
}
func (m *Recipe) XXX_Size() int {
	return m.Size()
}
func (m *Recipe) XXX_DiscardUnknown() {
	xxx_messageInfo_Recipe.DiscardUnknown(m)
}

var xxx_messageInfo_Recipe proto.InternalMessageInfo

func (m *RecipeInputSpec) Reset()      { *m = RecipeInputSpec{} }
func (*RecipeInputSpec) ProtoMessage() {}
func (*RecipeInputSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{78}
}
func (m *RecipeInputSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecipeInputSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecipeInputSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecipeInputSpec.Merge(m, src)
}
func (m *RecipeInputSpec) XXX_Size() int {
	return m.Size()
}
func (m *RecipeInputSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RecipeInputSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RecipeInputSpec proto.InternalMessageInfo

func (m *RecipeList) Reset()      { *m = RecipeList{} }
func (*RecipeList) ProtoMessage() {}
func (*RecipeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{79}
}
func (m *RecipeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecipeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecipeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecipeList.Merge(m, src)
}
func (m *RecipeList) XXX_Size() int {
	return m.Size()
}
func (m *RecipeList) XXX_DiscardUnknown() {
	xxx_messageInfo_RecipeList.DiscardUnknown(m)
}

var xxx_messageInfo_RecipeList proto.InternalMessageInfo

func (m *RecipeOutputSpec) Reset()      { *m = RecipeOutputSpec{} }
func (*RecipeOutputSpec) ProtoMessage() {}
func (*RecipeOutputSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{80}
}
func (m *RecipeOutputSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecipeOutputSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecipeOutputSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecipeOutputSpec.Merge(m, src)
}
func (m *RecipeOutputSpec) XXX_Size() int {
	return m.Size()
}
func (m *RecipeOutputSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RecipeOutputSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RecipeOutputSpec proto.InternalMessageInfo

func (m *RecipePartSpec) Reset()      { *m = RecipePartSpec{} }
func (*RecipePartSpec) ProtoMessage() {}
func (*RecipePartSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{81}
}
func (m *RecipePartSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecipePartSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecipePartSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecipePartSpec.Merge(m, src)
}
func (m *RecipePartSpec) XXX_Size() int {
	return m.Size()
}
func (m *RecipePartSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RecipePartSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RecipePartSpec proto.InternalMessageInfo

func (m *RecipeRun) Reset()      { *m = RecipeRun{} }
func (*RecipeRun) ProtoMessage() {}
func (*RecipeRun) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{82}
}
func (m *RecipeRun) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecipeRun) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecipeRun) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecipeRun.Merge(m, src)
}
func (m *RecipeRun) XXX_Size() int {
	return m.Size()
}
func (m *RecipeRun) XXX_DiscardUnknown() {
	xxx_messageInfo_RecipeRun.DiscardUnknown(m)
}

var xxx_messageInfo_RecipeRun proto.InternalMessageInfo

func (m *RecipeRunList) Reset()      { *m = RecipeRunList{} }
func (*RecipeRunList) ProtoMessage() {}
func (*RecipeRunList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{83}
}
func (m *RecipeRunList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecipeRunList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecipeRunList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecipeRunList.Merge(m, src)
}
func (m *RecipeRunList) XXX_Size() int {
	return m.Size()
}
func (m *RecipeRunList) XXX_DiscardUnknown() {
	xxx_messageInfo_RecipeRunList.DiscardUnknown(m)
}

var xxx_messageInfo_RecipeRunList proto.InternalMessageInfo

func (m *RecipeRunSpec) Reset()      { *m = RecipeRunSpec{} }
func (*RecipeRunSpec) ProtoMessage() {}
func (*RecipeRunSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{84}
}
func (m *RecipeRunSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecipeRunSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecipeRunSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecipeRunSpec.Merge(m, src)
}
func (m *RecipeRunSpec) XXX_Size() int {
	return m.Size()
}
func (m *RecipeRunSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RecipeRunSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RecipeRunSpec proto.InternalMessageInfo

func (m *RecipeRunStatus) Reset()      { *m = RecipeRunStatus{} }
func (*RecipeRunStatus) ProtoMessage() {}
func (*RecipeRunStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{85}
}
func (m *RecipeRunStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecipeRunStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecipeRunStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecipeRunStatus.Merge(m, src)
}
func (m *RecipeRunStatus) XXX_Size() int {
	return m.Size()
}
func (m *RecipeRunStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RecipeRunStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RecipeRunStatus proto.InternalMessageInfo

func (m *RecipeSpec) Reset()      { *m = RecipeSpec{} }
func (*RecipeSpec) ProtoMessage() {}
func (*RecipeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{86}
}
func (m *RecipeSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecipeSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecipeSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecipeSpec.Merge(m, src)
}
func (m *RecipeSpec) XXX_Size() int {
	return m.Size()
}
func (m *RecipeSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RecipeSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RecipeSpec proto.InternalMessageInfo

func (m *RecipeStatus) Reset()      { *m = RecipeStatus{} }
func (*RecipeStatus) ProtoMessage() {}
func (*RecipeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{87}
}
func (m *RecipeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecipeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecipeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecipeStatus.Merge(m, src)
}
func (m *RecipeStatus) XXX_Size() int {
	return m.Size()
}
func (m *RecipeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RecipeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RecipeStatus proto.InternalMessageInfo

func (m *RecipeStep) Reset()      { *m = RecipeStep{} }
func (*RecipeStep) ProtoMessage() {}
func (*RecipeStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{88}
}
func (m *RecipeStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecipeStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecipeStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecipeStep.Merge(m, src)
}
func (m *RecipeStep) XXX_Size() int {
	return m.Size()
}
func (m *RecipeStep) XXX_DiscardUnknown() {
	xxx_messageInfo_RecipeStep.DiscardUnknown(m)
}

var xxx_messageInfo_RecipeStep proto.InternalMessageInfo

func (m *RecipeStepParam) Reset()      { *m = RecipeStepParam{} }
func (*RecipeStepParam) ProtoMessage() {}
func (*RecipeStepParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{89}
}
func (m *RecipeStepParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecipeStepParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecipeStepParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecipeStepParam.Merge(m, src)
}
func (m *RecipeStepParam) XXX_Size() int {
	return m.Size()
}
func (m *RecipeStepParam) XXX_DiscardUnknown() {
	xxx_messageInfo_RecipeStepParam.DiscardUnknown(m)
}

var xxx_messageInfo_RecipeStepParam proto.InternalMessageInfo

func (m *RecommendationSchema) Reset()      { *m = RecommendationSchema{} }
func (*RecommendationSchema) ProtoMessage() {}
func (*RecommendationSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{90}
}
func (m *RecommendationSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecommendationSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecommendationSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecommendationSchema.Merge(m, src)
}
func (m *RecommendationSchema) XXX_Size() int {
	return m.Size()
}
func (m *RecommendationSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_RecommendationSchema.DiscardUnknown(m)
}

var xxx_messageInfo_RecommendationSchema proto.InternalMessageInfo

func (m *RelationshipSpec) Reset()      { *m = RelationshipSpec{} }
func (*RelationshipSpec) ProtoMessage() {}
func (*RelationshipSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{91}
}
func (m *RelationshipSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationshipSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RelationshipSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationshipSpec.Merge(m, src)
}
func (m *RelationshipSpec) XXX_Size() int {
	return m.Size()
}
func (m *RelationshipSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationshipSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RelationshipSpec proto.InternalMessageInfo

func (m *RowSpec) Reset()      { *m = RowSpec{} }
func (*RowSpec) ProtoMessage() {}
func (*RowSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{92}
}
func (m *RowSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RowSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowSpec.Merge(m, src)
}
func (m *RowSpec) XXX_Size() int {
	return m.Size()
}
func (m *RowSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RowSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RowSpec proto.InternalMessageInfo

func (m *SampleSpec) Reset()      { *m = SampleSpec{} }
func (*SampleSpec) ProtoMessage() {}
func (*SampleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{93}
}
func (m *SampleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SampleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SampleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SampleSpec.Merge(m, src)
}
func (m *SampleSpec) XXX_Size() int {
	return m.Size()
}
func (m *SampleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SampleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SampleSpec proto.InternalMessageInfo

func (m *ScatterPlotSpec) Reset()      { *m = ScatterPlotSpec{} }
func (*ScatterPlotSpec) ProtoMessage() {}
func (*ScatterPlotSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{94}
}
func (m *ScatterPlotSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScatterPlotSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ScatterPlotSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScatterPlotSpec.Merge(m, src)
}
func (m *ScatterPlotSpec) XXX_Size() int {
	return m.Size()
}
func (m *ScatterPlotSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ScatterPlotSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ScatterPlotSpec proto.InternalMessageInfo

func (m *Schema) Reset()      { *m = Schema{} }
func (*Schema) ProtoMessage() {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{95}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(m, src)
}
func (m *Schema) XXX_Size() int {
	return m.Size()
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

func (m *SyntheticSpec) Reset()      { *m = SyntheticSpec{} }
func (*SyntheticSpec) ProtoMessage() {}
func (*SyntheticSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{96}
}
func (m *SyntheticSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyntheticSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SyntheticSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyntheticSpec.Merge(m, src)
}
func (m *SyntheticSpec) XXX_Size() int {
	return m.Size()
}
func (m *SyntheticSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SyntheticSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SyntheticSpec proto.InternalMessageInfo

func (m *TableSpec) Reset()      { *m = TableSpec{} }
func (*TableSpec) ProtoMessage() {}
func (*TableSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{97}
}
func (m *TableSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableSpec.Merge(m, src)
}
func (m *TableSpec) XXX_Size() int {
	return m.Size()
}
func (m *TableSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TableSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TableSpec proto.InternalMessageInfo

func (m *TimeSeriesSchema) Reset()      { *m = TimeSeriesSchema{} }
func (*TimeSeriesSchema) ProtoMessage() {}
func (*TimeSeriesSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c557a5a515a9338, []int{98}
}
func (m *TimeSeriesSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeSeriesSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TimeSeriesSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeSeriesSchema.Merge(m, src)
}
func (m *TimeSeriesSchema) XXX_Size() int {
	return m.Size()
}
func (m *TimeSeriesSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeSeriesSchema.DiscardUnknown(m)
}

var xxx_messageInfo_TimeSeriesSchema proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ApprovalReviewStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.ApprovalReviewStatus")
	proto.RegisterType((*ApprovalSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.ApprovalSpec")
	proto.RegisterType((*ApprovalStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.ApprovalStatus")
	proto.RegisterType((*BarChartSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.BarChartSpec")
	proto.RegisterType((*Column)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.Column")
	proto.RegisterType((*ColumnHistogram)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.ColumnHistogram")
	proto.RegisterType((*ColumnSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.ColumnSpec")
	proto.RegisterType((*ComponentSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.ComponentSpec")
	proto.RegisterType((*ComponentView)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.ComponentView")
	proto.RegisterType((*Correlation)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.Correlation")
	proto.RegisterType((*CorrelationSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.CorrelationSpec")
	proto.RegisterType((*CsvFileSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.CsvFileSpec")
	proto.RegisterType((*DataInputSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataInputSpec")
	proto.RegisterType((*DataOutputSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataOutputSpec")
	proto.RegisterType((*DataPipeline)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataPipeline")
	proto.RegisterType((*DataPipelineList)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataPipelineList")
	proto.RegisterType((*DataPipelineRun)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataPipelineRun")
	proto.RegisterType((*DataPipelineRunCondition)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataPipelineRunCondition")
	proto.RegisterType((*DataPipelineRunList)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataPipelineRunList")
	proto.RegisterType((*DataPipelineRunSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataPipelineRunSpec")
	proto.RegisterType((*DataPipelineRunStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataPipelineRunStatus")
	proto.RegisterType((*DataPipelineSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataPipelineSpec")
	proto.RegisterMapType((map[string]string)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataPipelineSpec.DatasetSelectorEntry")
	proto.RegisterType((*DataPipelineStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataPipelineStatus")
	proto.RegisterType((*DataProduct)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataProduct")
	proto.RegisterType((*DataProductList)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataProductList")
	proto.RegisterType((*DataProductSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataProductSpec")
	proto.RegisterType((*DataProductStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataProductStatus")
	proto.RegisterType((*DataProductVersion)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataProductVersion")
	proto.RegisterType((*DataProductVersionList)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataProductVersionList")
	proto.RegisterType((*DataProductVersionSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataProductVersionSpec")
	proto.RegisterType((*DataProductVersionStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataProductVersionStatus")
	proto.RegisterType((*DataSource)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataSource")
	proto.RegisterType((*DataSourceList)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataSourceList")
	proto.RegisterType((*DataSourceSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataSourceSpec")
	proto.RegisterType((*DataSourceStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DataSourceStatus")
	proto.RegisterType((*Dataset)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.Dataset")
	proto.RegisterType((*DatasetGroupByStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DatasetGroupByStatus")
	proto.RegisterType((*DatasetList)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DatasetList")
	proto.RegisterType((*DatasetSnapshot)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DatasetSnapshot")
	proto.RegisterType((*DatasetSnapshotList)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DatasetSnapshotList")
	proto.RegisterType((*DatasetSnapshotSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DatasetSnapshotSpec")
	proto.RegisterType((*DatasetSnapshotStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DatasetSnapshotStatus")
	proto.RegisterType((*DatasetSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DatasetSpec")
	proto.RegisterType((*DatasetStatistics)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DatasetStatistics")
	proto.RegisterType((*DatasetStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DatasetStatus")
	proto.RegisterType((*DriftThreshold)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.DriftThreshold")
	proto.RegisterType((*Entity)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.Entity")
	proto.RegisterType((*EntityList)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.EntityList")
	proto.RegisterType((*EntitySpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.EntitySpec")
	proto.RegisterType((*EntityStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.EntityStatus")
	proto.RegisterType((*ExcelNotebookSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.ExcelNotebookSpec")
	proto.RegisterType((*ExcelSheetArea)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.ExcelSheetArea")
	proto.RegisterType((*FeatureGroup)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.FeatureGroup")
	proto.RegisterType((*FeatureGroupList)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.FeatureGroupList")
	proto.RegisterType((*FeatureGroupSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.FeatureGroupSpec")
	proto.RegisterType((*FeatureGroupStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.FeatureGroupStatus")
	proto.RegisterType((*FeatureHistogram)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.FeatureHistogram")
	proto.RegisterType((*FeatureHistogramList)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.FeatureHistogramList")
	proto.RegisterType((*FeatureHistogramSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.FeatureHistogramSpec")
	proto.RegisterType((*FeatureHistogramStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.FeatureHistogramStatus")
	proto.RegisterType((*FeatureStatistics)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.FeatureStatistics")
	proto.RegisterType((*FlatFileFormatSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.FlatFileFormatSpec")
	proto.RegisterType((*GaugeSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.GaugeSpec")
	proto.RegisterType((*GitLocation)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.GitLocation")
	proto.RegisterType((*GroupBySpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.GroupBySpec")
	proto.RegisterType((*GroupDatasetLocationStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.GroupDatasetLocationStatus")
	proto.RegisterType((*HistogramSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.HistogramSpec")
	proto.RegisterType((*ImageLocation)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.ImageLocation")
	proto.RegisterType((*KPI)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.KPI")
	proto.RegisterType((*LabelingRule)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.LabelingRule")
	proto.RegisterType((*LabelingSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.LabelingSpec")
	proto.RegisterType((*LineChartSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.LineChartSpec")
	proto.RegisterType((*MaterializationSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.MaterializationSpec")
	proto.RegisterType((*MetricSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.MetricSpec")
	proto.RegisterType((*OutlierStatistics)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.OutlierStatistics")
	proto.RegisterType((*PageSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.PageSpec")
	proto.RegisterType((*ParquetFileSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.ParquetFileSpec")
	proto.RegisterType((*Recipe)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.Recipe")
	proto.RegisterType((*RecipeInputSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecipeInputSpec")
	proto.RegisterType((*RecipeList)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecipeList")
	proto.RegisterType((*RecipeOutputSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecipeOutputSpec")
	proto.RegisterType((*RecipePartSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecipePartSpec")
	proto.RegisterType((*RecipeRun)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecipeRun")
	proto.RegisterType((*RecipeRunList)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecipeRunList")
	proto.RegisterType((*RecipeRunSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecipeRunSpec")
	proto.RegisterType((*RecipeRunStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecipeRunStatus")
	proto.RegisterType((*RecipeSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecipeSpec")
	proto.RegisterType((*RecipeStatus)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecipeStatus")
	proto.RegisterType((*RecipeStep)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecipeStep")
	proto.RegisterType((*RecipeStepParam)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecipeStepParam")
	proto.RegisterType((*RecommendationSchema)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RecommendationSchema")
	proto.RegisterType((*RelationshipSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RelationshipSpec")
	proto.RegisterType((*RowSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.RowSpec")
	proto.RegisterType((*SampleSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.SampleSpec")
	proto.RegisterType((*ScatterPlotSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.ScatterPlotSpec")
	proto.RegisterType((*Schema)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.Schema")
	proto.RegisterType((*SyntheticSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.SyntheticSpec")
	proto.RegisterType((*TableSpec)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.TableSpec")
	proto.RegisterType((*TimeSeriesSchema)(nil), "github.com.metaprov.modelaapi.pkg.apis.data.v1alpha1.TimeSeriesSchema")
}

func init() {
	proto.RegisterFile("github.com/metaprov/modelaapi/pkg/apis/data/v1alpha1/generated.proto", fileDescriptor_0c557a5a515a9338)
}

var fileDescriptor_0c557a5a515a9338 = []byte{
	// 10308 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x7d, 0x6d, 0x8c, 0x1c, 0xc9,
	0x75, 0x98, 0x7a, 0x76, 0x67, 0x77, 0xb6, 0x76, 0x97, 0xcb, 0x2d, 0xf2, 0x78, 0x73, 0x34, 0xc5,
	0xa1, 0xe6, 0xc2, 0x13, 0x4f, 0x3a, 0x2d, 0x75, 0xcc, 0x51, 0x47, 0xc8, 0x3a, 0x89, 0xfb, 0x49,
	0xee, 0x71, 0x97, 0x5c, 0xbf, 0x59, 0xde, 0xc9, 0x17, 0xd9, 0xba, 0xde, 0x99, 0x9a, 0x99, 0xbe,
	0xed, 0xe9, 0x1e, 0x76, 0xf7, 0xec, 0x87, 0x6c, 0x58, 0x4a, 0xfc, 0x21, 0x21, 0x12, 0x02, 0x25,
	0x40, 0x80, 0x04, 0x09, 0x62, 0xc4, 0xf1, 0x5f, 0x27, 0x08, 0x10, 0x24, 0x86, 0x81, 0xc4, 0x08,
	0x62, 0x24, 0x0a, 0xe0, 0x20, 0x02, 0x04, 0x23, 0x72, 0x12, 0xac, 0xad, 0x0d, 0x84, 0x20, 0x3f,
	0x82, 0x20, 0x41, 0x7e, 0xd1, 0x08, 0x62, 0xd4, 0xab, 0xcf, 0xee, 0x99, 0xe1, 0x2d, 0x67, 0x66,
	0xf7, 0x7c, 0xff, 0x66, 0xde, 0x7b, 0xf5, 0x5e, 0x55, 0x75, 0xd5, 0xab, 0xf7, 0x5e, 0xbd, 0xaa,
	0x22, 0x2b, 0x0d, 0x2f, 0x69, 0x76, 0x76, 0x16, 0xaa, 0x61, 0xeb, 0x66, 0x8b, 0x25, 0x6e, 0x3b,
	0x0a, 0xf7, 0x6e, 0xb6, 0xc2, 0x1a, 0xf3, 0x5d, 0xb7, 0xed, 0xdd, 0x6c, 0xef, 0x36, 0x6e, 0xba,
	0x6d, 0x2f, 0xbe, 0x59, 0x73, 0x13, 0xf7, 0xe6, 0xde, 0xeb, 0xae, 0xdf, 0x6e, 0xba, 0xaf, 0xdf,
	0x6c, 0xb0, 0x80, 0x45, 0x6e, 0xc2, 0x6a, 0x0b, 0xed, 0x28, 0x4c, 0x42, 0xfa, 0x86, 0xe1, 0xb2,
	0xa0, 0xb8, 0x2c, 0x68, 0x2e, 0x0b, 0xed, 0xdd, 0xc6, 0x02, 0xe7, 0xb2, 0xc0, 0xb9, 0x2c, 0x28,
	0x2e, 0x97, 0x3f, 0x67, 0xc9, 0x6e, 0x84, 0x8d, 0xf0, 0x26, 0x32, 0xdb, 0xe9, 0xd4, 0xf1, 0x1f,
	0xfe, 0xc1, 0x5f, 0x42, 0xc8, 0xe5, 0x7b, 0x27, 0xac, 0x6a, 0xd5, 0x4d, 0x5c, 0x3f, 0x6c, 0xf4,
	0xad, 0xed, 0xe5, 0xf2, 0xee, 0x9d, 0x78, 0xc1, 0x0b, 0x39, 0xf5, 0xcd, 0x6a, 0x18, 0xb1, 0x9b,
	0x7b, 0xdd, 0x34, 0x6f, 0x18, 0x9a, 0x96, 0x5b, 0x6d, 0x7a, 0x01, 0x8b, 0x0e, 0x8d, 0x08, 0x2e,
	0xbe, 0x57, 0xa9, 0x9b, 0xfd, 0x4a, 0x45, 0x9d, 0x20, 0xf1, 0x5a, 0xac, 0xab, 0xc0, 0x17, 0x3e,
	0xac, 0x40, 0x5c, 0x6d, 0xb2, 0x96, 0x9b, 0x2d, 0x57, 0xfe, 0x7f, 0x0e, 0xb9, 0xb8, 0xd8, 0xe6,
	0x3d, 0xe0, 0xfa, 0xc0, 0xf6, 0x3c, 0xb6, 0x5f, 0x49, 0xdc, 0xa4, 0x13, 0xd3, 0xd7, 0x48, 0x21,
	0xc2, 0xff, 0x2c, 0x2a, 0x3a, 0xd7, 0x9c, 0x1b, 0x53, 0x4b, 0xe7, 0x7f, 0x70, 0x54, 0xfa, 0xc4,
	0xf1, 0x51, 0xa9, 0x00, 0x12, 0x0e, 0x9a, 0x82, 0x7e, 0x81, 0x4c, 0x44, 0x2c, 0xee, 0xf8, 0x49,
	0x31, 0x87, 0xb4, 0x57, 0x25, 0xed, 0x04, 0x20, 0xf4, 0xe9, 0x51, 0x69, 0x46, 0x49, 0xd9, 0x3e,
	0x6c, 0x33, 0x90, 0xd4, 0xf4, 0x3d, 0x42, 0x5c, 0x84, 0xb3, 0xda, 0x62, 0x52, 0x1c, 0xbb, 0xe6,
	0xdc, 0x98, 0xbe, 0xf5, 0x99, 0x05, 0xd1, 0x96, 0x05, 0xbb, 0x2d, 0xe6, 0xd3, 0xf3, 0x2e, 0x5b,
	0xd8, 0x7b, 0x7d, 0x61, 0xdb, 0x6b, 0xb1, 0xa5, 0x73, 0xc7, 0x47, 0x25, 0xb2, 0xa8, 0x39, 0x80,
	0xc5, 0x8d, 0xbe, 0x4c, 0xf2, 0x41, 0x98, 0xb0, 0xb8, 0x38, 0x8e, 0x55, 0x9a, 0x95, 0x55, 0xca,
	0x3f, 0xe4, 0x40, 0x10, 0xb8, 0xf2, 0x6f, 0x3b, 0x44, 0xd7, 0xac, 0xd2, 0x66, 0x55, 0x7a, 0x9d,
	0x4c, 0xb2, 0xc0, 0xdd, 0xf1, 0x59, 0x0d, 0x9b, 0x5d, 0x58, 0x9a, 0x3e, 0x3e, 0x2a, 0x4d, 0xae,
	0x0a, 0x10, 0x28, 0x1c, 0x5d, 0x21, 0x33, 0x35, 0x56, 0xf5, 0x62, 0x2f, 0x0c, 0x78, 0x83, 0x64,
	0xb3, 0xaf, 0x1d, 0x1f, 0x95, 0x66, 0x56, 0x2c, 0xf8, 0xd3, 0xcc, 0x7f, 0x48, 0x95, 0xa2, 0x9f,
	0x26, 0x93, 0x2d, 0xd6, 0xda, 0x61, 0x51, 0x5c, 0x1c, 0xbb, 0x36, 0xc6, 0x2b, 0x79, 0x7c, 0x54,
	0x9a, 0x52, 0xfd, 0x1b, 0x83, 0xc2, 0x96, 0x7f, 0xdf, 0x21, 0xe7, 0x74, 0x35, 0xc5, 0x07, 0xfa,
	0x02, 0x99, 0x88, 0xf1, 0x97, 0xfc, 0x3c, 0xba, 0xcb, 0x05, 0xbe, 0xbb, 0xcb, 0x05, 0x35, 0xed,
	0x90, 0x49, 0xf1, 0xd9, 0xe2, 0x62, 0xee, 0xda, 0xd8, 0x8d, 0xe9, 0x5b, 0x6f, 0x2f, 0x0c, 0x32,
	0xe9, 0x16, 0x7a, 0x8d, 0x9a, 0xa5, 0x39, 0x59, 0x89, 0x49, 0x01, 0x8d, 0x41, 0xc9, 0x2a, 0xff,
	0x8e, 0x43, 0x66, 0x96, 0xdc, 0x68, 0xb9, 0xe9, 0x46, 0x09, 0x76, 0xf4, 0xeb, 0x64, 0x9a, 0x33,
	0x8c, 0x59, 0xf2, 0xd0, 0x6d, 0x31, 0xd9, 0x88, 0xb9, 0xe3, 0xa3, 0xd2, 0xf4, 0x8a, 0x01, 0x83,
	0x4d, 0x43, 0x2f, 0x10, 0xe7, 0x40, 0xf6, 0x74, 0xfe, 0xf8, 0xa8, 0xe4, 0x7c, 0x15, 0x9c, 0x03,
	0x0e, 0x3c, 0xc4, 0x91, 0x23, 0x81, 0x3f, 0x0f, 0xce, 0x21, 0x2d, 0x93, 0x09, 0x9f, 0x35, 0x58,
	0x50, 0xc3, 0x8f, 0x5f, 0x58, 0x22, 0xbc, 0x63, 0x36, 0x10, 0x02, 0x12, 0x43, 0xaf, 0x90, 0xf1,
	0x38, 0x8c, 0x92, 0x62, 0x1e, 0x29, 0x0a, 0xc7, 0x47, 0xa5, 0xf1, 0x4a, 0x18, 0x25, 0x80, 0xd0,
	0xf2, 0x1f, 0x5c, 0x20, 0x13, 0xcb, 0xa1, 0xdf, 0x69, 0x05, 0xf4, 0x1a, 0x19, 0x0f, 0x4c, 0x15,
	0x67, 0x64, 0x13, 0xc7, 0xb1, 0x7e, 0x88, 0xc1, 0xb6, 0x78, 0x71, 0xdb, 0x77, 0x0f, 0xb1, 0x2d,
	0x39, 0xab, 0x2d, 0x06, 0x0c, 0x36, 0x0d, 0x6d, 0x93, 0x02, 0x6f, 0x5a, 0xc2, 0x07, 0x8f, 0xa8,
	0xfd, 0xb6, 0x9a, 0x5f, 0xbc, 0xfd, 0x72, 0xf0, 0xdc, 0x1d, 0x50, 0x55, 0x2d, 0x28, 0x1e, 0xa0,
	0xa5, 0xd0, 0x26, 0x99, 0xa8, 0x87, 0x51, 0xcb, 0x4d, 0xe4, 0x84, 0xd8, 0xe2, 0x7d, 0xb2, 0x86,
	0x90, 0xa7, 0x47, 0xa5, 0xa5, 0x61, 0x24, 0xad, 0x84, 0x2d, 0xd7, 0x0b, 0x40, 0xf2, 0xc7, 0xee,
	0x60, 0x71, 0x35, 0xf2, 0xda, 0x89, 0x17, 0x06, 0xd8, 0xc1, 0xaa, 0x3b, 0x0c, 0x18, 0x6c, 0x1a,
	0xfe, 0xc1, 0xbc, 0x46, 0x10, 0x46, 0xac, 0x38, 0x61, 0x3e, 0xd8, 0x3a, 0x42, 0x40, 0x62, 0x38,
	0x4d, 0xe2, 0x46, 0x0d, 0x96, 0x14, 0x27, 0x0d, 0xcd, 0x36, 0x42, 0x40, 0x62, 0xe8, 0x0d, 0x52,
	0x08, 0x3a, 0xbe, 0xcf, 0x27, 0x69, 0xb1, 0x80, 0x54, 0x33, 0xbc, 0x4b, 0x1f, 0x4a, 0x18, 0x68,
	0x2c, 0xbd, 0x44, 0x72, 0xed, 0xdd, 0xe2, 0x14, 0xd2, 0x4c, 0x1c, 0x1f, 0x95, 0x72, 0x5b, 0x0f,
	0x20, 0xd7, 0xde, 0xe5, 0xf0, 0xfa, 0x6e, 0x91, 0x18, 0xf8, 0xda, 0x03, 0xc8, 0xd5, 0x77, 0xe9,
	0x02, 0x21, 0xad, 0x8e, 0x9f, 0x78, 0x6d, 0x9f, 0x3d, 0xaa, 0x17, 0xa7, 0xaf, 0x39, 0x37, 0xf2,
	0x42, 0xfd, 0x6c, 0x6a, 0x28, 0x58, 0x14, 0x5c, 0x91, 0xb4, 0xdc, 0x03, 0xaf, 0xd5, 0x69, 0x15,
	0x67, 0xae, 0x39, 0x37, 0x1c, 0xa1, 0x48, 0x36, 0x05, 0x08, 0x14, 0x8e, 0xde, 0x25, 0xe7, 0xd9,
	0x41, 0xd5, 0xef, 0xc4, 0xde, 0x1e, 0x93, 0xc8, 0xe2, 0x2c, 0x0a, 0xbf, 0x78, 0x7c, 0x54, 0x3a,
	0xbf, 0x9a, 0xc1, 0x41, 0x17, 0x35, 0x0a, 0xf2, 0x02, 0x2c, 0x78, 0xce, 0x12, 0x24, 0x40, 0xa0,
	0x70, 0x69, 0x41, 0x92, 0x7e, 0xae, 0x97, 0x20, 0x59, 0xb0, 0x8b, 0x9a, 0x7e, 0x96, 0x4c, 0xb5,
	0xdc, 0x83, 0x0d, 0x16, 0x34, 0x92, 0x66, 0xf1, 0x3c, 0x76, 0x00, 0xea, 0xab, 0x4d, 0x05, 0x04,
	0x83, 0x47, 0x62, 0x2f, 0x90, 0xc4, 0xf3, 0x16, 0xb1, 0x02, 0x82, 0xc1, 0xf3, 0x26, 0xb4, 0xdd,
	0x24, 0x61, 0x51, 0x50, 0xa4, 0x38, 0x58, 0xb0, 0x09, 0x5b, 0x02, 0x04, 0x0a, 0xc7, 0x3f, 0x6e,
	0xc4, 0x9e, 0x74, 0xbc, 0x88, 0xd5, 0x8a, 0x17, 0xcc, 0xc7, 0x05, 0x09, 0x03, 0x8d, 0x45, 0x2d,
	0x7e, 0xe0, 0xb6, 0xda, 0x3e, 0x2b, 0x5e, 0x34, 0x0c, 0x57, 0x05, 0x08, 0x14, 0x8e, 0xbe, 0x41,
	0x66, 0xd8, 0x01, 0x67, 0xed, 0xfa, 0x2b, 0x61, 0x35, 0x2e, 0xbe, 0x20, 0x16, 0x3a, 0xae, 0xc5,
	0x57, 0x2d, 0x38, 0xa4, 0xa8, 0xb8, 0xe2, 0x60, 0x41, 0xa7, 0x55, 0xbc, 0x84, 0x2a, 0x1b, 0x15,
	0xc7, 0x6a, 0xd0, 0x69, 0x01, 0x42, 0x79, 0x25, 0x5b, 0xee, 0xc1, 0x7a, 0xc2, 0x5a, 0x71, 0xb1,
	0x88, 0xed, 0xc6, 0x4a, 0x6e, 0x4a, 0x18, 0x68, 0x2c, 0x52, 0x7a, 0x81, 0xa0, 0x7c, 0xc9, 0xa2,
	0x94, 0x30, 0xd0, 0x58, 0x3e, 0xa1, 0x3a, 0x81, 0xf7, 0xa4, 0xc3, 0x04, 0xf1, 0x65, 0x6c, 0x3b,
	0x4e, 0xa8, 0xc7, 0x06, 0x0c, 0x36, 0x0d, 0x7d, 0x89, 0x8c, 0xb5, 0x3d, 0xaf, 0x78, 0x05, 0x49,
	0x27, 0x8f, 0x8f, 0x4a, 0x63, 0x5b, 0xeb, 0xeb, 0xc0, 0x61, 0x88, 0x6a, 0x7a, 0xc5, 0x4f, 0x5a,
	0xa8, 0xfb, 0x1c, 0xd5, 0xf4, 0xf8, 0x57, 0xe3, 0x76, 0x01, 0xab, 0x26, 0xac, 0x56, 0x2c, 0x21,
	0x01, 0x7e, 0xb5, 0x2d, 0x05, 0x04, 0x83, 0xa7, 0x6f, 0x91, 0xb9, 0x1a, 0xab, 0xbb, 0x1d, 0x3f,
	0x79, 0xc7, 0xf5, 0x3b, 0xec, 0x61, 0xa7, 0x55, 0xbc, 0x86, 0x03, 0xf0, 0xc2, 0xf1, 0x51, 0x69,
	0x6e, 0x25, 0x8d, 0x82, 0x2c, 0x2d, 0xaf, 0x86, 0x1f, 0x36, 0x8a, 0x9f, 0x32, 0xd5, 0xd8, 0x08,
	0x1b, 0xc0, 0x61, 0x7c, 0x0e, 0xb6, 0x3a, 0xc5, 0x32, 0x32, 0xc3, 0x39, 0xb8, 0xd9, 0x81, 0x5c,
	0xab, 0x43, 0x4b, 0x24, 0x1f, 0x7b, 0x8d, 0x96, 0x5b, 0x7c, 0x19, 0x51, 0x53, 0x7c, 0x39, 0xaf,
	0x70, 0x00, 0x08, 0x38, 0x7d, 0x93, 0xcc, 0xc6, 0xbb, 0x6c, 0x7f, 0xbb, 0x19, 0xb1, 0xb8, 0x19,
	0xfa, 0xb5, 0xe2, 0x5f, 0x42, 0xc2, 0xf9, 0xe3, 0xa3, 0xd2, 0x6c, 0xc5, 0x46, 0x40, 0x9a, 0x8e,
	0x7e, 0x91, 0x9c, 0xab, 0x45, 0x5e, 0x3d, 0x31, 0x25, 0xaf, 0x63, 0x49, 0x7a, 0x7c, 0x54, 0x3a,
	0xb7, 0x92, 0xc2, 0x40, 0x86, 0x92, 0x37, 0x64, 0x97, 0x1d, 0x16, 0x5f, 0x31, 0x0d, 0x79, 0xc0,
	0x0e, 0x81, 0xc3, 0xf8, 0x50, 0xa9, 0x73, 0x66, 0x9f, 0x36, 0x6b, 0xcc, 0x1a, 0x67, 0x81, 0x50,
	0xae, 0xd0, 0xf6, 0x99, 0xd7, 0x68, 0x26, 0xc5, 0x1b, 0x46, 0xa1, 0xbd, 0x8b, 0x10, 0x90, 0x18,
	0x31, 0xe6, 0x63, 0x16, 0xed, 0xb1, 0x5a, 0xf1, 0x55, 0x7b, 0xcc, 0x0b, 0x18, 0x68, 0x2c, 0x4d,
	0x08, 0xf1, 0x5a, 0xed, 0x4e, 0xe2, 0xa2, 0xd2, 0xfd, 0x8c, 0x58, 0x53, 0xb8, 0x82, 0x5a, 0xd7,
	0xd0, 0x61, 0xf4, 0xbc, 0xe1, 0x02, 0x96, 0x1c, 0xda, 0x24, 0x93, 0x71, 0xd5, 0xf5, 0xbd, 0xa0,
	0x51, 0xfc, 0x2c, 0x8a, 0x7c, 0xc8, 0x67, 0x5a, 0x45, 0x80, 0x9e, 0x1e, 0x95, 0xbe, 0x32, 0xa8,
	0x3c, 0xc9, 0x02, 0x14, 0x7b, 0x3e, 0x36, 0xb5, 0xf5, 0x5a, 0x7c, 0xcd, 0x8c, 0xcd, 0x7b, 0x0a,
	0x08, 0x06, 0xcf, 0x15, 0x00, 0x5f, 0x8c, 0x3a, 0xbe, 0x5b, 0xfc, 0x9c, 0x51, 0x00, 0x6b, 0x02,
	0x04, 0x0a, 0xc7, 0x07, 0x9a, 0x57, 0x2b, 0x2e, 0x18, 0x65, 0xbf, 0xbe, 0x02, 0x39, 0x4f, 0xd8,
	0x06, 0x09, 0x6b, 0x17, 0x6f, 0xe2, 0x20, 0x10, 0xb6, 0x41, 0xc2, 0xda, 0x80, 0x50, 0xfa, 0x49,
	0x3e, 0x72, 0xab, 0xc5, 0xcf, 0xe3, 0x9c, 0x9d, 0x96, 0xcb, 0xf6, 0xd8, 0x46, 0x58, 0xe5, 0xa3,
	0xb7, 0x8a, 0x63, 0xc9, 0x4d, 0x18, 0x37, 0xbb, 0xc5, 0xf2, 0x5a, 0x7c, 0x1d, 0xab, 0x20, 0xc6,
	0x92, 0x9b, 0xb0, 0x6d, 0x8d, 0x81, 0x0c, 0x25, 0x5f, 0x65, 0xf8, 0xbf, 0x98, 0x45, 0x1e, 0x8b,
	0x8b, 0xb7, 0xb0, 0x62, 0xb8, 0xca, 0xf0, 0x32, 0x15, 0x84, 0x82, 0x45, 0xc1, 0x3b, 0x25, 0x62,
	0x8d, 0x88, 0xc5, 0x71, 0x18, 0x15, 0xff, 0xb2, 0xe9, 0x14, 0x50, 0x40, 0x30, 0x78, 0x3e, 0x61,
	0x7d, 0xb7, 0xd1, 0x60, 0x35, 0x8d, 0x2d, 0xbe, 0x81, 0x45, 0x70, 0xc2, 0x6e, 0xa4, 0x51, 0x90,
	0xa5, 0xe5, 0xb2, 0xb8, 0xe4, 0xf5, 0xa0, 0xc6, 0x0e, 0x8a, 0xb7, 0x8d, 0xac, 0x6d, 0x05, 0x04,
	0x83, 0xa7, 0x2e, 0x19, 0x77, 0x1b, 0x8d, 0xa8, 0xf8, 0x05, 0x6c, 0xfa, 0x26, 0xef, 0xc1, 0xc5,
	0x46, 0x23, 0x7a, 0x7a, 0x54, 0x5a, 0x1c, 0x74, 0x44, 0xf0, 0xf2, 0xac, 0xe1, 0x26, 0x0c, 0x90,
	0x35, 0x4e, 0x1f, 0x2f, 0xa8, 0x85, 0xfb, 0xc5, 0x37, 0xf1, 0x4b, 0x88, 0xe9, 0x83, 0x10, 0x90,
	0x98, 0xf2, 0xbf, 0xca, 0x91, 0x39, 0x61, 0xc6, 0xdd, 0xf7, 0xe2, 0x24, 0x6c, 0x44, 0x6e, 0xeb,
	0x04, 0xf6, 0xdc, 0x3e, 0x99, 0x6a, 0x2a, 0x72, 0xb4, 0xe6, 0xa6, 0x6f, 0xad, 0x9d, 0xd4, 0x4a,
	0x96, 0xd5, 0x36, 0x86, 0xb2, 0x16, 0xcc, 0x2d, 0xa5, 0xa5, 0x79, 0x29, 0x6e, 0x4a, 0x83, 0xc1,
	0xc8, 0xa2, 0x21, 0x77, 0x08, 0x92, 0xc8, 0xab, 0x0a, 0x87, 0x60, 0xfa, 0xd6, 0xca, 0xc0, 0x62,
	0x37, 0x99, 0x1b, 0x77, 0x22, 0xd6, 0x62, 0x41, 0x62, 0xcc, 0xf2, 0x4d, 0xc1, 0x1c, 0x94, 0x14,
	0xae, 0x51, 0x51, 0x9b, 0x49, 0x3b, 0x19, 0x35, 0x2a, 0xaa, 0x3b, 0x10, 0xf0, 0xf2, 0xbf, 0x76,
	0x08, 0x11, 0x1d, 0x88, 0x56, 0x7b, 0x99, 0x4c, 0xc4, 0x6d, 0xb7, 0x2a, 0x9d, 0x42, 0xa9, 0xb2,
	0x2a, 0x08, 0x01, 0x89, 0xe1, 0x3c, 0xf7, 0xbd, 0x5a, 0xd2, 0xc4, 0x9e, 0xcb, 0x0b, 0x9e, 0xef,
	0x72, 0x00, 0x08, 0x38, 0x0d, 0xc8, 0x64, 0x35, 0x0c, 0x12, 0x16, 0x28, 0x97, 0x6f, 0x79, 0x30,
	0x17, 0x64, 0x39, 0x6c, 0xb5, 0xc3, 0x80, 0x05, 0xe8, 0x50, 0x98, 0x46, 0x2e, 0x0b, 0xde, 0xa0,
	0x84, 0x94, 0xff, 0xaf, 0x43, 0x66, 0x53, 0xb4, 0xbc, 0x8a, 0x89, 0x97, 0xf8, 0x6a, 0x0c, 0x60,
	0x15, 0xb7, 0x39, 0x00, 0x04, 0x9c, 0xab, 0xdd, 0xb8, 0xb3, 0x23, 0x68, 0x84, 0x39, 0x8f, 0x6a,
	0xb7, 0xd2, 0xd9, 0x11, 0x64, 0x1a, 0xcb, 0x7b, 0xa4, 0x1e, 0x86, 0x09, 0x8b, 0xa4, 0x19, 0x4f,
	0x84, 0x59, 0xcd, 0x21, 0x20, 0x31, 0x34, 0x31, 0x0d, 0x1e, 0x1f, 0x49, 0x83, 0xdf, 0xf1, 0xd8,
	0xfe, 0xd2, 0x0b, 0xb2, 0xc1, 0xb3, 0x29, 0xb0, 0x69, 0xf6, 0x6f, 0x4c, 0x90, 0x34, 0x8a, 0xd6,
	0xc8, 0x84, 0xf8, 0xf0, 0xd8, 0xee, 0xe9, 0x5b, 0x77, 0x07, 0xab, 0x86, 0x18, 0x45, 0xd8, 0xe9,
	0xd8, 0x5a, 0xf1, 0x1f, 0x24, 0x6f, 0xfa, 0x3e, 0xc9, 0x37, 0xdc, 0x4e, 0x83, 0xc9, 0x99, 0xf3,
	0x95, 0xc1, 0x84, 0xdc, 0xe3, 0x2c, 0x50, 0x06, 0x7e, 0x1d, 0xfc, 0x0b, 0x82, 0x31, 0x6d, 0xdb,
	0xf3, 0x73, 0xa8, 0x21, 0xa4, 0x67, 0x21, 0x4a, 0x9a, 0xed, 0x3b, 0x31, 0xdf, 0x27, 0xf9, 0x04,
	0x9d, 0x8a, 0xf1, 0x61, 0xda, 0xb4, 0xcd, 0x59, 0x98, 0x36, 0xe1, 0x5f, 0x10, 0x8c, 0x79, 0x9b,
	0x7c, 0x2f, 0x60, 0xe8, 0x20, 0xa3, 0xcb, 0x34, 0x70, 0x9b, 0x36, 0x14, 0x1b, 0xd3, 0x26, 0x0d,
	0x02, 0x23, 0x84, 0xfa, 0xa4, 0xb0, 0x23, 0x3d, 0x72, 0xf4, 0xba, 0xa6, 0x6f, 0x2d, 0x0d, 0x26,
	0xd0, 0xf6, 0xeb, 0xc5, 0x3c, 0x51, 0x10, 0xd0, 0x12, 0xe8, 0x21, 0x99, 0x8e, 0xab, 0x68, 0xc8,
	0x6f, 0xf9, 0xa1, 0x70, 0xe1, 0xa6, 0x6f, 0xad, 0x0e, 0x26, 0xb0, 0x62, 0x18, 0xa1, 0x4c, 0xb4,
	0xd8, 0x25, 0x50, 0xc8, 0xb5, 0x65, 0x95, 0xbf, 0xe7, 0x90, 0xe9, 0xe5, 0x30, 0x8a, 0x98, 0x2f,
	0x6c, 0x96, 0x17, 0x89, 0x73, 0xa0, 0x66, 0xbe, 0x9c, 0x43, 0x22, 0x96, 0xf0, 0x22, 0x71, 0x0e,
	0xe5, 0x74, 0xd7, 0x08, 0x8c, 0x27, 0xbc, 0x4c, 0xf2, 0x7b, 0xdc, 0x6e, 0xc5, 0xc1, 0xe6, 0x98,
	0x58, 0x12, 0x1a, 0xb3, 0x20, 0x70, 0xf4, 0x15, 0x9c, 0x5d, 0xcd, 0xb0, 0x26, 0x1d, 0xec, 0x73,
	0x2a, 0x22, 0xb3, 0x89, 0x50, 0x90, 0xd8, 0x72, 0xc2, 0x97, 0x24, 0x5d, 0x1b, 0xa5, 0x56, 0xab,
	0x9d, 0x24, 0xac, 0xd7, 0xb1, 0x5a, 0x8e, 0x98, 0x56, 0xcb, 0x08, 0x01, 0x89, 0xe1, 0x34, 0x92,
	0x7d, 0xce, 0x28, 0x9a, 0x34, 0x6b, 0x6e, 0x8a, 0x26, 0x61, 0x1b, 0x6b, 0x99, 0x17, 0xa6, 0xe8,
	0x76, 0xd8, 0x06, 0x0e, 0x2b, 0xff, 0x66, 0x9e, 0x4c, 0x2f, 0xc7, 0x7b, 0x6b, 0x9e, 0x18, 0x81,
	0xf4, 0x0e, 0x99, 0xaa, 0x31, 0xdf, 0x6b, 0x79, 0x89, 0x8e, 0xf0, 0x5d, 0xe6, 0x43, 0x65, 0x45,
	0x01, 0x9f, 0xda, 0x7f, 0xc0, 0x10, 0xd3, 0x37, 0x48, 0xfe, 0x49, 0x27, 0x4c, 0x54, 0xdc, 0x42,
	0x05, 0x9e, 0xa6, 0x7e, 0x8e, 0x03, 0x79, 0xf7, 0x3f, 0xb5, 0xff, 0x80, 0x20, 0xa6, 0x77, 0x09,
	0x61, 0x71, 0xd5, 0x6d, 0x23, 0x50, 0xf6, 0xd0, 0x35, 0x59, 0x94, 0xac, 0x6a, 0xcc, 0xd3, 0xd4,
	0x3f, 0xb0, 0xca, 0x70, 0x6f, 0xad, 0x1a, 0xb6, 0xf8, 0x82, 0xc6, 0xff, 0xc6, 0x32, 0xae, 0x80,
	0xdf, 0x7e, 0xd9, 0x82, 0x43, 0x8a, 0x8a, 0x77, 0x5b, 0x93, 0xb9, 0x35, 0x16, 0xd9, 0x91, 0x85,
	0xfb, 0x08, 0x01, 0x89, 0x41, 0x6d, 0xbf, 0xeb, 0xb5, 0x21, 0xdc, 0x8f, 0x71, 0x60, 0x4a, 0x4f,
	0xac, 0x22, 0x61, 0xa0, 0xb1, 0xdc, 0x3e, 0x0b, 0x3a, 0xbe, 0x8f, 0xdf, 0x3d, 0xc6, 0x08, 0xc3,
	0x94, 0xb0, 0xcf, 0x1e, 0x6a, 0x28, 0x58, 0x14, 0xb4, 0x4d, 0x0a, 0x2c, 0xa8, 0x86, 0x35, 0x6e,
	0x1f, 0x4f, 0x69, 0x93, 0xbc, 0xb0, 0x2a, 0x61, 0x4f, 0x8f, 0x4a, 0x2b, 0x83, 0x9a, 0x43, 0xfc,
	0x4b, 0x2a, 0x3e, 0xa0, 0xa5, 0xc8, 0xb8, 0x03, 0x36, 0x85, 0x08, 0x03, 0x55, 0xc6, 0x1d, 0xb0,
	0x25, 0x0a, 0x87, 0x0b, 0x39, 0xd7, 0xd6, 0x09, 0x86, 0x32, 0xd4, 0x42, 0x8e, 0x10, 0x90, 0x18,
	0xee, 0x76, 0x56, 0xc3, 0x56, 0x9b, 0x9b, 0x7f, 0xdc, 0xa5, 0x98, 0x31, 0x71, 0x9c, 0x65, 0x03,
	0x06, 0x9b, 0x86, 0xdb, 0xbe, 0x4d, 0x37, 0x46, 0x13, 0x50, 0x58, 0x0d, 0x32, 0x98, 0x81, 0xb6,
	0xef, 0xfd, 0x14, 0x06, 0x32, 0x94, 0xe5, 0xff, 0xe3, 0x90, 0x59, 0x6e, 0x23, 0xad, 0x07, 0xed,
	0x8e, 0x58, 0xa6, 0x43, 0x52, 0xf0, 0xc3, 0xaa, 0x70, 0x68, 0x72, 0xcf, 0xa7, 0x30, 0xba, 0xec,
	0x21, 0xce, 0x79, 0x43, 0x32, 0x13, 0x9f, 0x57, 0xfd, 0x03, 0x2d, 0x84, 0xb6, 0x75, 0x8c, 0x4c,
	0xac, 0x2a, 0xf7, 0x07, 0xd3, 0x4f, 0x6b, 0xbe, 0x9b, 0xf0, 0xcf, 0x23, 0x8c, 0x7a, 0x54, 0x51,
	0x5a, 0x19, 0x48, 0xc3, 0x5f, 0xca, 0x29, 0xff, 0xf7, 0x71, 0xc2, 0x7d, 0x02, 0xf7, 0x51, 0x27,
	0x51, 0xad, 0x1e, 0x20, 0x32, 0x7a, 0xe6, 0x1d, 0x75, 0x2b, 0xd5, 0x51, 0x42, 0x75, 0x98, 0x60,
	0xe2, 0x8c, 0xea, 0x00, 0x11, 0x79, 0x96, 0x61, 0x41, 0x9f, 0x4c, 0xb8, 0x55, 0xac, 0xe2, 0xb8,
	0x9e, 0x09, 0x13, 0x8b, 0x55, 0xe9, 0x98, 0xae, 0x0d, 0x3a, 0x0f, 0x1e, 0xb7, 0xb9, 0x0f, 0x55,
	0x49, 0xb8, 0xe3, 0xd7, 0x38, 0x04, 0x29, 0x83, 0x3e, 0x22, 0x2f, 0x54, 0x23, 0xc6, 0xbd, 0x2d,
	0xbe, 0xbc, 0xae, 0xd7, 0x1f, 0x86, 0xc9, 0xea, 0x81, 0x17, 0xab, 0x78, 0xef, 0x4b, 0xc7, 0x47,
	0xa5, 0x17, 0x96, 0x7b, 0x11, 0x40, 0xef, 0x72, 0xdc, 0x7b, 0xf2, 0x82, 0xaa, 0xdf, 0xa9, 0xb1,
	0x35, 0xe6, 0x26, 0x9d, 0x88, 0xc5, 0x52, 0xa3, 0xa0, 0xf7, 0xb4, 0x9e, 0x46, 0x41, 0x96, 0x96,
	0x2e, 0x93, 0x79, 0x09, 0xaa, 0x34, 0xdd, 0xb6, 0x54, 0x20, 0x22, 0x90, 0xf9, 0xc2, 0xf1, 0x51,
	0x69, 0x7e, 0x3d, 0x8b, 0x84, 0x6e, 0x7a, 0x74, 0x2d, 0x59, 0xc2, 0xaa, 0xc9, 0xa3, 0x4e, 0xe2,
	0x7b, 0x2c, 0x8a, 0x65, 0x90, 0x53, 0xb8, 0x96, 0x29, 0x0c, 0x64, 0x28, 0xcb, 0x7f, 0x98, 0x23,
	0x33, 0xfc, 0xdb, 0x6e, 0x79, 0x6d, 0xc6, 0x8d, 0x00, 0xfa, 0x3e, 0x29, 0xf0, 0x8e, 0xe6, 0xe3,
	0x48, 0xda, 0x83, 0x9f, 0x3f, 0xd9, 0xd6, 0xcb, 0xa3, 0x9d, 0x0f, 0x58, 0x35, 0xd9, 0x64, 0x89,
	0xbb, 0x44, 0x95, 0x06, 0x37, 0x30, 0xd0, 0x5c, 0x69, 0x93, 0x8c, 0xc7, 0x6d, 0x56, 0x7d, 0x5e,
	0x17, 0x2a, 0x3d, 0x99, 0xec, 0x3a, 0x0b, 0x0b, 0x43, 0x79, 0x6c, 0xfc, 0x1f, 0xa0, 0x04, 0x3e,
	0x71, 0xe5, 0x6e, 0xc8, 0x50, 0x13, 0x37, 0x25, 0x4b, 0x6c, 0x69, 0x9c, 0x4b, 0xef, 0xab, 0xa8,
	0x7d, 0x94, 0xf2, 0x1f, 0x3b, 0xe4, 0xbc, 0x4d, 0xbe, 0xc1, 0xc7, 0xc8, 0xd7, 0xba, 0xba, 0x74,
	0xe1, 0x64, 0x5d, 0xca, 0x4b, 0x63, 0x87, 0xea, 0x5d, 0x36, 0x05, 0xb1, 0xba, 0xb3, 0x41, 0xf2,
	0x1e, 0x06, 0x00, 0xc5, 0xc6, 0xcd, 0xd2, 0xf0, 0x6d, 0x34, 0x96, 0x8c, 0x08, 0x21, 0x0a, 0xfe,
	0xe5, 0x3f, 0xca, 0x91, 0x39, 0x9b, 0x0c, 0x3a, 0xc1, 0x19, 0x8c, 0x96, 0xdd, 0xd4, 0x68, 0x59,
	0x1f, 0xbe, 0x75, 0xd0, 0x09, 0xfa, 0x0e, 0x98, 0x38, 0x33, 0x60, 0x1e, 0x8c, 0x46, 0xdc, 0xb3,
	0xc7, 0xcc, 0xff, 0xce, 0x91, 0x62, 0xa6, 0xc4, 0x72, 0x18, 0xd4, 0x3c, 0x54, 0x58, 0x77, 0xc9,
	0x38, 0xee, 0x06, 0x09, 0x7d, 0xff, 0x9a, 0xaa, 0xb3, 0xdc, 0x09, 0xba, 0xd2, 0xaf, 0x1c, 0xaa,
	0x58, 0x2c, 0x49, 0x37, 0x74, 0x9b, 0x84, 0x85, 0xf8, 0x46, 0xd7, 0x96, 0x60, 0x8f, 0x1d, 0xeb,
	0x05, 0xcd, 0x29, 0x5d, 0x59, 0x1a, 0x11, 0xea, 0xbb, 0x71, 0xb2, 0x1d, 0xb9, 0x41, 0x2c, 0x24,
	0x79, 0x2d, 0xe5, 0xff, 0x3c, 0xcf, 0x1e, 0xed, 0xa5, 0xe3, 0xa3, 0x12, 0xdd, 0xe8, 0xe2, 0x04,
	0x3d, 0xb8, 0x73, 0x13, 0x3a, 0x62, 0x6e, 0xac, 0x37, 0x8d, 0xce, 0x99, 0x7d, 0x64, 0x0e, 0x05,
	0x89, 0xa5, 0xaf, 0x92, 0xc9, 0x16, 0x8b, 0x63, 0xb7, 0x21, 0xf6, 0x8b, 0xa6, 0xec, 0x08, 0x07,
	0x82, 0x41, 0xe1, 0xcb, 0x7f, 0xe2, 0x90, 0x0b, 0x99, 0xbe, 0x3b, 0x83, 0xa9, 0xfa, 0x41, 0x7a,
	0xaa, 0xae, 0x8e, 0x64, 0x74, 0xf5, 0x99, 0xad, 0xff, 0x24, 0xdf, 0xd5, 0x42, 0x65, 0x47, 0xec,
	0xb1, 0x88, 0x9b, 0x65, 0x59, 0x3b, 0xe2, 0x1d, 0x03, 0x06, 0x9b, 0x86, 0xde, 0x25, 0xe7, 0x79,
	0x0d, 0xda, 0x92, 0x93, 0xb5, 0x9b, 0x89, 0x9b, 0x44, 0xb6, 0x14, 0x2c, 0xdc, 0x45, 0x4d, 0x4b,
	0x24, 0x1f, 0xee, 0x07, 0x4c, 0x59, 0xf8, 0xe8, 0xe7, 0x3e, 0xe2, 0x00, 0x10, 0x70, 0xba, 0x47,
	0xa6, 0x22, 0x16, 0x87, 0x9d, 0xa8, 0xca, 0x62, 0xe9, 0xe7, 0x0e, 0x6e, 0xab, 0x80, 0xe4, 0x84,
	0xd3, 0x5c, 0x87, 0xd6, 0x14, 0x34, 0x06, 0x23, 0x8a, 0x3e, 0x21, 0x85, 0x76, 0xe4, 0x85, 0x91,
	0x97, 0x1c, 0xca, 0x31, 0xf3, 0x98, 0x7f, 0xbb, 0x2d, 0x09, 0x7b, 0x7a, 0x54, 0x5a, 0x1d, 0xd4,
	0x02, 0x51, 0x3c, 0x36, 0xd8, 0x1e, 0xf3, 0x41, 0x8b, 0xe1, 0x36, 0x76, 0xdb, 0xed, 0xc4, 0xac,
	0x66, 0x6f, 0x58, 0x6e, 0x21, 0x04, 0x24, 0x86, 0x9b, 0xeb, 0xee, 0x4e, 0x18, 0x25, 0xac, 0x26,
	0x97, 0x72, 0x34, 0xd7, 0x17, 0x05, 0x08, 0x14, 0x8e, 0x3e, 0x20, 0x13, 0xbe, 0xbb, 0x03, 0xac,
	0x8e, 0x5e, 0xc4, 0xf4, 0xad, 0x97, 0xad, 0xb1, 0xba, 0xc0, 0x67, 0xb2, 0xd1, 0xb4, 0xc0, 0xea,
	0x2c, 0x62, 0x41, 0x95, 0x99, 0xd9, 0xb3, 0x81, 0x45, 0x41, 0xb2, 0xe0, 0x56, 0x04, 0x36, 0x6b,
	0xd9, 0x77, 0xe3, 0x18, 0xbf, 0x31, 0x31, 0x01, 0xea, 0xcd, 0x14, 0x06, 0x32, 0x94, 0xdc, 0x8c,
	0x31, 0x10, 0xe8, 0x88, 0xa1, 0x35, 0x8d, 0xc5, 0xd1, 0x8c, 0xd9, 0xcc, 0x22, 0xa1, 0x9b, 0xbe,
	0xfc, 0x8f, 0x26, 0xc9, 0x0b, 0x3d, 0x35, 0x27, 0xf7, 0xaf, 0x22, 0x56, 0xf5, 0xda, 0x1c, 0x14,
	0x17, 0x1d, 0xdc, 0x61, 0x43, 0xff, 0x0a, 0x34, 0x14, 0x2c, 0x0a, 0xda, 0x22, 0x13, 0x21, 0x5a,
	0xce, 0xa3, 0x35, 0x7b, 0x75, 0xcf, 0x09, 0xb3, 0x1c, 0xa4, 0x10, 0xfa, 0xb3, 0x24, 0xdf, 0x6e,
	0xba, 0xb1, 0x72, 0x7d, 0xaf, 0xab, 0xf9, 0xb8, 0xc5, 0x81, 0x4f, 0x8f, 0x4a, 0x17, 0x33, 0xad,
	0x42, 0x38, 0x88, 0x32, 0xf4, 0x17, 0x84, 0x3b, 0xe5, 0xb3, 0x04, 0xb3, 0x5d, 0xf2, 0xcf, 0xad,
	0x49, 0xb5, 0xeb, 0x25, 0x59, 0x80, 0xcd, 0x8f, 0xbe, 0x4d, 0x68, 0xb8, 0x23, 0xf6, 0x82, 0xe4,
	0x96, 0x08, 0x37, 0xb5, 0xf9, 0x50, 0x1f, 0x5b, 0xba, 0x2c, 0x2b, 0x4a, 0x1f, 0x75, 0x51, 0x40,
	0x8f, 0x52, 0xf4, 0x57, 0xc8, 0x6c, 0xdd, 0xf5, 0xfc, 0x4e, 0xc4, 0x84, 0xe2, 0xc5, 0x01, 0x3c,
	0xb5, 0xf4, 0xd5, 0xe3, 0xa3, 0xd2, 0xec, 0x9a, 0x8d, 0x78, 0x7a, 0x54, 0x5a, 0x1e, 0x78, 0x87,
	0x07, 0x3f, 0xf9, 0x6a, 0x14, 0x85, 0x11, 0xa4, 0xc5, 0xf1, 0x11, 0x2a, 0x01, 0x52, 0x9f, 0x4b,
	0x57, 0x1b, 0x47, 0xe8, 0x5a, 0x0a, 0x03, 0x19, 0x4a, 0xee, 0xcc, 0xb7, 0xa3, 0x10, 0x37, 0x2d,
	0x70, 0xb2, 0x48, 0x67, 0x7e, 0x4b, 0xc2, 0x40, 0x63, 0xe9, 0xd7, 0xc9, 0xb8, 0x1f, 0x36, 0x84,
	0x9f, 0x3c, 0x7d, 0xeb, 0xad, 0x81, 0x87, 0xce, 0x46, 0xd8, 0x88, 0x8d, 0x91, 0xc1, 0xff, 0x01,
	0x32, 0xa6, 0xef, 0x92, 0xa9, 0x0e, 0x7a, 0x27, 0xfc, 0x7b, 0x4f, 0x3f, 0xf7, 0xf7, 0xc6, 0xd0,
	0xdd, 0x63, 0xc5, 0x00, 0x0c, 0x2f, 0x5a, 0x25, 0xa4, 0xaa, 0x96, 0xed, 0xb8, 0x38, 0x83, 0x6b,
	0xcc, 0xcd, 0x93, 0x71, 0xd6, 0xcb, 0xbd, 0xb1, 0xc6, 0x34, 0x28, 0x06, 0x8b, 0x6d, 0xf9, 0x5f,
	0x4e, 0xa5, 0x2d, 0xdc, 0x41, 0x17, 0x95, 0x6e, 0x75, 0x93, 0x3b, 0xb1, 0xba, 0xc9, 0xa4, 0x92,
	0x8c, 0x9d, 0x20, 0x95, 0xe4, 0x1f, 0x38, 0x64, 0x4e, 0xfa, 0xc6, 0x15, 0xe6, 0xb3, 0x6a, 0x12,
	0xf2, 0xc5, 0x88, 0xf7, 0xd0, 0x5f, 0x19, 0x8d, 0x03, 0xb2, 0xb0, 0x92, 0xe6, 0xbe, 0x1a, 0x24,
	0xd1, 0xe1, 0xd2, 0x8b, 0xb2, 0x37, 0xe7, 0x32, 0x58, 0xc8, 0x56, 0x86, 0x86, 0x64, 0x52, 0x68,
	0x30, 0xbe, 0xfe, 0x3d, 0xd7, 0x26, 0x4f, 0xba, 0x5e, 0x42, 0x25, 0x6e, 0xa9, 0xc0, 0xab, 0x95,
	0x7b, 0x85, 0xcc, 0x41, 0x49, 0xe1, 0x8e, 0xb7, 0x54, 0x92, 0x22, 0xcc, 0xbb, 0x32, 0x78, 0x3f,
	0x98, 0x30, 0x45, 0x5f, 0x1d, 0x19, 0x91, 0x42, 0x5c, 0x6d, 0xb2, 0x5a, 0xc7, 0x67, 0x32, 0xca,
	0x3b, 0xf8, 0x26, 0x16, 0x5f, 0x18, 0x24, 0x2f, 0x63, 0x6e, 0x29, 0x08, 0x68, 0x39, 0xf4, 0x57,
	0x1d, 0x32, 0x13, 0x84, 0x89, 0x57, 0xf7, 0x64, 0x10, 0xa4, 0xf0, 0x7c, 0x3e, 0x44, 0x97, 0xe0,
	0x87, 0x16, 0x33, 0x6c, 0xed, 0x45, 0x29, 0x7d, 0xc6, 0xc6, 0x40, 0x4a, 0xa8, 0xb1, 0x7d, 0xa6,
	0x4e, 0x62, 0xfb, 0x90, 0x8f, 0xc6, 0xf6, 0x99, 0x3e, 0x6b, 0xdb, 0x67, 0xa6, 0xaf, 0xed, 0xf3,
	0x12, 0x19, 0x4b, 0x12, 0x1f, 0x23, 0x84, 0x2a, 0x5a, 0xbd, 0xbd, 0x01, 0x1c, 0x76, 0x79, 0x89,
	0x5c, 0xec, 0x35, 0xcb, 0xe8, 0x79, 0x91, 0x6b, 0x81, 0x6a, 0x47, 0xa4, 0x58, 0x5c, 0x54, 0xa1,
	0x79, 0x54, 0x2a, 0x32, 0x16, 0xff, 0xc5, 0xdc, 0x1d, 0xa7, 0xfc, 0xad, 0x71, 0x42, 0xbb, 0x1d,
	0xfa, 0x3e, 0xeb, 0xa4, 0x33, 0xd0, 0x3a, 0x99, 0x52, 0xf0, 0xb9, 0x11, 0x2a, 0xf8, 0x03, 0x6b,
	0x12, 0x09, 0x07, 0xf5, 0xed, 0x51, 0x4c, 0x22, 0xe9, 0x9f, 0x3e, 0x6b, 0x2a, 0xdd, 0x26, 0xd3,
	0xdc, 0x31, 0x53, 0xa6, 0x9d, 0x30, 0xe3, 0x2f, 0xc8, 0x02, 0xd3, 0x1b, 0x06, 0x05, 0x36, 0x1d,
	0xbd, 0x49, 0xa6, 0xa2, 0x4e, 0x10, 0x2f, 0x87, 0x9d, 0x40, 0x98, 0x36, 0x79, 0x6b, 0x4c, 0x2a,
	0x04, 0x18, 0x9a, 0xcc, 0x12, 0x36, 0x71, 0x3a, 0x4b, 0xd8, 0xbf, 0xcf, 0x11, 0x0c, 0x9a, 0x6e,
	0x45, 0x61, 0xad, 0x53, 0x4d, 0xce, 0x20, 0x88, 0xd1, 0x48, 0x05, 0x31, 0x86, 0xf1, 0xfb, 0x44,
	0x95, 0xfb, 0x06, 0x30, 0xc2, 0x4c, 0x00, 0xe3, 0xde, 0xf0, 0xa2, 0x9e, 0x1d, 0xbc, 0xf8, 0x4f,
	0x8e, 0x0c, 0x0a, 0x09, 0xea, 0x33, 0x70, 0xa2, 0xeb, 0x69, 0x27, 0x7a, 0x71, 0xe8, 0x16, 0xf6,
	0x71, 0xa0, 0x7f, 0x38, 0x9b, 0x6a, 0x99, 0xca, 0x10, 0x10, 0xba, 0xdc, 0xe9, 0xa3, 0xcb, 0xb9,
	0x82, 0xeb, 0xec, 0xf8, 0x9e, 0xf8, 0xd4, 0x4a, 0xc1, 0x21, 0x04, 0x24, 0x86, 0x6e, 0x91, 0xa9,
	0x84, 0x05, 0x6e, 0xc0, 0x7d, 0x32, 0xf9, 0x99, 0x4e, 0xe4, 0xb8, 0x89, 0xb4, 0x1a, 0x55, 0x12,
	0x0c, 0x13, 0x7a, 0x40, 0xa6, 0x1b, 0x5e, 0xa2, 0xfc, 0x14, 0x19, 0x8d, 0x19, 0xb0, 0x63, 0xee,
	0x19, 0x46, 0x66, 0x82, 0x5b, 0x40, 0xb0, 0x45, 0xd1, 0x45, 0x32, 0x57, 0x75, 0xab, 0x4d, 0xb6,
	0xd4, 0xa9, 0xee, 0xca, 0x9d, 0x09, 0xe1, 0x46, 0x6b, 0xc3, 0x67, 0x39, 0x8d, 0x86, 0x2c, 0xbd,
	0x88, 0x5e, 0x63, 0x12, 0xe0, 0x86, 0xbb, 0x83, 0x1c, 0x26, 0xad, 0xc4, 0xa8, 0x14, 0x06, 0x32,
	0x94, 0x14, 0xc8, 0x25, 0x09, 0xa9, 0xb0, 0x68, 0xcf, 0x0b, 0x1a, 0x15, 0x2f, 0x11, 0xf1, 0x89,
	0x82, 0xde, 0x80, 0xb8, 0xb4, 0xd2, 0x93, 0x02, 0xfa, 0x94, 0xe4, 0xbe, 0xac, 0xc4, 0x58, 0x8d,
	0x9a, 0x32, 0xbe, 0xec, 0x4a, 0x16, 0x09, 0xdd, 0xf4, 0xf4, 0x17, 0xc9, 0x78, 0xe2, 0xc6, 0xbb,
	0xd2, 0x85, 0x7e, 0x1b, 0x43, 0x76, 0x6e, 0xbc, 0xfb, 0xf4, 0xa8, 0xf4, 0xe5, 0x41, 0xd7, 0xd4,
	0xcd, 0x0d, 0xce, 0x01, 0x90, 0x2f, 0xfd, 0x80, 0x4c, 0xc6, 0x9d, 0x1d, 0x14, 0x31, 0xad, 0xf3,
	0xb6, 0x27, 0x2b, 0x9d, 0x1d, 0x29, 0x65, 0x71, 0x70, 0x29, 0x15, 0xc1, 0x17, 0x94, 0x80, 0xac,
	0xb5, 0x3d, 0x73, 0x02, 0x6b, 0xfb, 0x9b, 0x19, 0xc3, 0x6b, 0x76, 0xd4, 0x86, 0xd7, 0xf9, 0x0f,
	0x31, 0xba, 0xfe, 0xb6, 0x43, 0xe6, 0x93, 0xc8, 0xf5, 0x02, 0x2f, 0x68, 0x68, 0xe3, 0x07, 0x33,
	0xa1, 0x47, 0x66, 0x5c, 0xa9, 0x6d, 0xea, 0xa2, 0x1c, 0x10, 0xdb, 0x59, 0x71, 0xd0, 0x5d, 0x03,
	0xfa, 0xb7, 0x1c, 0x72, 0x3e, 0x16, 0x03, 0xce, 0x54, 0x6b, 0x6e, 0x94, 0xd5, 0x2a, 0xc9, 0x6a,
	0xbd, 0x98, 0x1e, 0xf6, 0xa6, 0x56, 0x5d, 0xf2, 0xb9, 0x59, 0xa1, 0x0d, 0xc1, 0xf3, 0xf8, 0x75,
	0xbf, 0x66, 0xe5, 0xea, 0x9e, 0xa6, 0x3d, 0xf8, 0x3e, 0xc9, 0x57, 0x43, 0x3f, 0x8c, 0x30, 0x17,
	0x5c, 0xcc, 0x93, 0xfc, 0x32, 0x07, 0x3c, 0x3d, 0x2a, 0xbd, 0x35, 0xa8, 0x30, 0x64, 0x00, 0x82,
	0x31, 0xf5, 0x49, 0xc1, 0x95, 0x67, 0x52, 0x30, 0x8b, 0x7c, 0xe0, 0x0d, 0x12, 0xfb, 0x3c, 0x90,
	0x88, 0x1d, 0xe8, 0xb3, 0x2e, 0x5a, 0x02, 0xfd, 0x26, 0x99, 0x6e, 0xb3, 0xa8, 0xe5, 0xe1, 0xb6,
	0x77, 0x8c, 0xe9, 0xe8, 0xcf, 0xb1, 0xeb, 0xd4, 0xf5, 0x61, 0xb7, 0x0c, 0x2f, 0x14, 0xab, 0xf5,
	0xb1, 0x85, 0x00, 0x5b, 0x22, 0xbd, 0xc2, 0xf5, 0x4e, 0x23, 0x2e, 0x5e, 0x34, 0x59, 0xe8, 0xdb,
	0x6e, 0x23, 0x06, 0x84, 0x96, 0xff, 0x80, 0x90, 0xf9, 0xae, 0xa5, 0xfd, 0xe3, 0x61, 0xfa, 0xae,
	0x88, 0x18, 0xb4, 0x1c, 0xb2, 0xc2, 0xa0, 0x14, 0x09, 0x2d, 0x45, 0x59, 0x45, 0x8c, 0x4a, 0xd8,
	0x78, 0xe8, 0x2a, 0x41, 0x7f, 0x96, 0xcc, 0x4a, 0xbf, 0x5b, 0xb2, 0x18, 0x47, 0x16, 0x3a, 0x67,
	0x6e, 0xc5, 0x46, 0x42, 0x9a, 0x96, 0xde, 0x27, 0xf3, 0x35, 0xcb, 0x71, 0xb0, 0x8d, 0x5a, 0xdd,
	0x4d, 0xb6, 0x67, 0x21, 0xb9, 0x74, 0x17, 0xa2, 0x15, 0xf2, 0x42, 0x12, 0x26, 0xae, 0x9f, 0x89,
	0x0b, 0x8a, 0xad, 0xe3, 0xfc, 0xd2, 0x27, 0x25, 0xb7, 0x6c, 0x34, 0x54, 0x32, 0xec, 0x5d, 0x96,
	0xde, 0x21, 0x33, 0x71, 0xd2, 0xa9, 0x79, 0xaa, 0x77, 0x44, 0xca, 0x8a, 0xf6, 0x50, 0x2b, 0x16,
	0x0e, 0x52, 0x94, 0xdc, 0xb8, 0xc7, 0xd1, 0x28, 0x0b, 0x16, 0xb0, 0xa0, 0x1e, 0x6b, 0x9b, 0x06,
	0x05, 0x36, 0x1d, 0x5f, 0xfb, 0xdb, 0x11, 0xab, 0x79, 0xdc, 0x0f, 0x93, 0x45, 0xc5, 0x01, 0x18,
	0xbd, 0xf6, 0x6f, 0xa5, 0xd1, 0x90, 0xa5, 0x57, 0xdf, 0x63, 0xb1, 0xdd, 0x96, 0x0c, 0x66, 0xbb,
	0xbf, 0x87, 0x46, 0x42, 0x9a, 0x96, 0x0f, 0x09, 0xc9, 0x8f, 0x0f, 0x7d, 0x51, 0xfe, 0x5c, 0x7a,
	0x48, 0x6c, 0x65, 0xf0, 0xd0, 0x55, 0x82, 0xb7, 0xc2, 0x0b, 0xea, 0xe1, 0xa2, 0xcf, 0x22, 0x35,
	0x28, 0xe6, 0xd2, 0xad, 0x58, 0x4f, 0xa3, 0x21, 0x4b, 0x4f, 0x57, 0xc9, 0x79, 0x16, 0x45, 0x61,
	0x64, 0xf3, 0x10, 0x27, 0x61, 0x5e, 0x92, 0x3c, 0xe6, 0x31, 0x9e, 0x19, 0xdb, 0x5c, 0xba, 0x8a,
	0xd0, 0x7b, 0x76, 0x10, 0x5d, 0x7d, 0xc5, 0xf9, 0x34, 0x9f, 0xcd, 0x2c, 0x01, 0x74, 0x97, 0xe9,
	0x8e, 0xd3, 0xd2, 0x8f, 0x3a, 0x4e, 0x7b, 0xe1, 0xc4, 0x71, 0xda, 0xb7, 0xc8, 0xdc, 0x8e, 0x1b,
	0xe3, 0xa8, 0x96, 0xa1, 0x43, 0x79, 0x56, 0x07, 0xf3, 0x29, 0x96, 0xd2, 0x28, 0xc8, 0xd2, 0x66,
	0xfc, 0xc7, 0x17, 0x4e, 0xc7, 0x7f, 0x3c, 0xca, 0xc9, 0x10, 0x82, 0x50, 0xa3, 0x4a, 0xf6, 0xe9,
	0xbb, 0x91, 0x41, 0xca, 0x8d, 0xdc, 0x18, 0xda, 0xf3, 0x91, 0x35, 0xef, 0xeb, 0x4d, 0xee, 0x65,
	0xbc, 0xc9, 0x87, 0x23, 0x93, 0xf8, 0x6c, 0xa7, 0xf2, 0xa7, 0x0e, 0xb9, 0xd4, 0x5d, 0xe8, 0x0c,
	0x7c, 0xcb, 0x56, 0xda, 0xb7, 0xbc, 0x3f, 0xaa, 0xf6, 0xf6, 0x71, 0x31, 0xff, 0x71, 0xae, 0x57,
	0x3b, 0xd1, 0xd3, 0x7c, 0x97, 0x90, 0xb6, 0x80, 0x72, 0x2f, 0xd1, 0x39, 0xb9, 0x97, 0xa8, 0x47,
	0xd0, 0x96, 0x2e, 0x0e, 0x16, 0xab, 0xac, 0x35, 0x9f, 0x3b, 0x81, 0x35, 0xff, 0x16, 0x2a, 0xfa,
	0x3d, 0x2b, 0x94, 0x2f, 0x43, 0xee, 0x17, 0xa4, 0x92, 0xb7, 0x51, 0x90, 0xa5, 0xa5, 0x37, 0x48,
	0x41, 0x4d, 0x53, 0x79, 0xa0, 0x40, 0x66, 0x03, 0x0b, 0x18, 0x68, 0xac, 0x71, 0xaf, 0xf3, 0xbd,
	0xdd, 0xeb, 0xf2, 0x9f, 0x8e, 0xc9, 0x54, 0x89, 0x1e, 0xa3, 0xe9, 0xe3, 0x61, 0xc7, 0x74, 0xe9,
	0xe6, 0xb1, 0x8f, 0x5a, 0x37, 0x8f, 0x9f, 0x58, 0x37, 0xa7, 0x95, 0x6b, 0xfe, 0x74, 0x94, 0xeb,
	0xbf, 0xcd, 0x11, 0xc2, 0x3f, 0x71, 0x05, 0xed, 0xb6, 0x33, 0x50, 0xaa, 0xf5, 0x94, 0x52, 0x1d,
	0x62, 0x17, 0xa4, 0x62, 0x9c, 0xb0, 0x5e, 0xca, 0x34, 0xc8, 0x28, 0xd3, 0xb5, 0xa1, 0x25, 0x3d,
	0x5b, 0x89, 0xfe, 0x91, 0x23, 0x72, 0x48, 0x05, 0xf1, 0x19, 0x28, 0x4f, 0x96, 0x56, 0x9e, 0x77,
	0x87, 0x6d, 0x5f, 0x1f, 0xa5, 0xf9, 0x5f, 0xa7, 0xed, 0x76, 0x9d, 0x2c, 0x2c, 0x77, 0x3b, 0xbd,
	0x3f, 0x99, 0x4b, 0x87, 0xaf, 0xfb, 0xee, 0x51, 0x0e, 0xb0, 0xcf, 0x78, 0xa0, 0xd3, 0x74, 0xf1,
	0x06, 0x08, 0x31, 0xb9, 0xde, 0xb1, 0xd2, 0x74, 0x65, 0xe6, 0xd6, 0xf2, 0x30, 0x27, 0xeb, 0x25,
	0x1b, 0xb0, 0x45, 0xd1, 0x1a, 0x99, 0x10, 0xd7, 0x79, 0xc8, 0x1c, 0x82, 0x2f, 0x0d, 0x7a, 0x8a,
	0x82, 0xf3, 0xb0, 0x46, 0x15, 0xfe, 0x07, 0xc9, 0x9b, 0x46, 0xa4, 0x50, 0xf7, 0xdd, 0xa4, 0xee,
	0xf9, 0x4c, 0xee, 0x1b, 0x8e, 0x2e, 0x1b, 0x1a, 0x97, 0x05, 0x05, 0x07, 0x2d, 0x87, 0x5e, 0x27,
	0x93, 0xbe, 0xbb, 0xc3, 0x7c, 0x9d, 0x32, 0x83, 0xd9, 0x30, 0x1b, 0x02, 0x04, 0x0a, 0x47, 0x9b,
	0x64, 0x22, 0x16, 0xa7, 0xbb, 0xa7, 0x86, 0x39, 0xc7, 0x54, 0x41, 0x1e, 0xe9, 0xcd, 0x4c, 0x01,
	0x03, 0xc9, 0x9f, 0xee, 0xa4, 0xa2, 0x7b, 0x0f, 0x75, 0x52, 0xde, 0xc7, 0x35, 0xc2, 0xf7, 0xab,
	0x0e, 0x99, 0x55, 0x27, 0x4f, 0xe2, 0xa6, 0xd7, 0x56, 0xc9, 0x03, 0x6b, 0x83, 0x6e, 0x41, 0x1b,
	0x56, 0xd8, 0x8f, 0xda, 0x9f, 0xb3, 0x31, 0x31, 0xa4, 0x65, 0xd2, 0x36, 0x29, 0xe0, 0xa7, 0xf4,
	0x82, 0x86, 0x0c, 0x18, 0x0e, 0x18, 0xaa, 0xd9, 0x90, 0x5c, 0x44, 0xa4, 0x50, 0x6b, 0x2c, 0x09,
	0x05, 0x2d, 0x85, 0xfe, 0x12, 0x99, 0xf1, 0x82, 0x3a, 0x8b, 0x22, 0x56, 0x5b, 0x8b, 0xc2, 0xd6,
	0xd0, 0xf1, 0xc1, 0x54, 0xb6, 0x10, 0x86, 0x28, 0xd7, 0x2d, 0xf6, 0x90, 0x12, 0x46, 0xbf, 0xeb,
	0x90, 0xf9, 0x4e, 0xe0, 0x25, 0xdb, 0x2c, 0x4e, 0xe2, 0x6d, 0xd6, 0x6a, 0xfb, 0x6e, 0xc2, 0x64,
	0x2c, 0x70, 0x69, 0xe0, 0x2a, 0x70, 0x6e, 0x95, 0x8e, 0x97, 0x30, 0xe3, 0x33, 0x3e, 0xce, 0x0a,
	0x81, 0x6e, 0xb9, 0xf4, 0x37, 0x1c, 0xde, 0x17, 0x0d, 0x86, 0x5a, 0xbd, 0x19, 0xd6, 0x64, 0x20,
	0x70, 0x47, 0x34, 0xc2, 0xc0, 0x9f, 0x1e, 0x95, 0x1e, 0x0e, 0x7c, 0x36, 0x45, 0x64, 0xbd, 0x57,
	0x92, 0x30, 0x62, 0x82, 0xa7, 0xb8, 0xfd, 0xc6, 0x96, 0x5b, 0xfe, 0x17, 0x79, 0x91, 0x5f, 0x62,
	0xaf, 0x71, 0xf4, 0x1a, 0x19, 0xaf, 0x86, 0xbe, 0xb8, 0xd4, 0x26, 0x6f, 0x56, 0xd7, 0xe5, 0xd0,
	0x8f, 0x01, 0x31, 0x7d, 0x8c, 0xbf, 0xdc, 0x40, 0xc6, 0xdf, 0x01, 0xb9, 0xe8, 0xbb, 0x71, 0x22,
	0x35, 0xad, 0x38, 0x0e, 0x30, 0xd8, 0x4d, 0x44, 0xc5, 0xe3, 0xa3, 0xd2, 0xc5, 0x8d, 0x1e, 0xbc,
	0xa0, 0xa7, 0x04, 0xba, 0x48, 0xe6, 0x2c, 0xb8, 0xb5, 0xd5, 0xaa, 0x83, 0x11, 0x1b, 0x69, 0x34,
	0x64, 0xe9, 0xd3, 0x96, 0x6b, 0xfe, 0x34, 0x2d, 0xd7, 0x89, 0x8f, 0xda, 0x72, 0x9d, 0x1c, 0xd0,
	0x72, 0x2d, 0x9c, 0x52, 0x66, 0x54, 0x8e, 0x4c, 0xca, 0x2f, 0x71, 0x06, 0x66, 0x6b, 0x35, 0x65,
	0xb6, 0x0e, 0xb1, 0x0b, 0x1a, 0xb3, 0xfe, 0xdb, 0xc9, 0xbb, 0x19, 0x9b, 0x75, 0x79, 0x38, 0x31,
	0xcf, 0x36, 0x58, 0x9f, 0xe6, 0x74, 0x7a, 0xc7, 0xbd, 0x28, 0xec, 0xb4, 0x97, 0x0e, 0xe5, 0xec,
	0xbf, 0xad, 0x6d, 0xaa, 0xf8, 0x31, 0xac, 0x4b, 0x23, 0x4f, 0x5b, 0x6f, 0x2b, 0x06, 0x05, 0x36,
	0x1d, 0x2f, 0xd6, 0x8e, 0x42, 0x6e, 0x41, 0x60, 0xb1, 0x8c, 0xd1, 0xb7, 0x65, 0x50, 0x60, 0xd3,
	0xd1, 0x5b, 0x84, 0x44, 0xac, 0x1d, 0x46, 0x42, 0x98, 0xb0, 0xf9, 0xf4, 0xa7, 0x00, 0x8d, 0x01,
	0x8b, 0x8a, 0xde, 0x21, 0x33, 0x5a, 0xa5, 0xf2, 0x52, 0x62, 0xd2, 0xea, 0xd8, 0xeb, 0x63, 0x0b,
	0x07, 0x29, 0x4a, 0xfa, 0xeb, 0x0e, 0x99, 0xdd, 0x0f, 0xa3, 0x5d, 0x16, 0x89, 0x4b, 0xd1, 0x54,
	0xd2, 0xc3, 0xe0, 0x9b, 0x06, 0xef, 0x0a, 0x6e, 0x9d, 0x40, 0x30, 0x34, 0x8b, 0xef, 0xbb, 0xb6,
	0x18, 0x48, 0x4b, 0x2d, 0xff, 0x47, 0x87, 0xa8, 0x9e, 0x3c, 0x03, 0x57, 0x61, 0x27, 0xed, 0x2a,
	0xbc, 0x35, 0xd4, 0xb0, 0xfa, 0x90, 0xe3, 0x2a, 0x7c, 0xe0, 0x05, 0x6e, 0x3b, 0x6e, 0x86, 0xc9,
	0xc7, 0xe9, 0xb8, 0x8a, 0x55, 0xed, 0xb3, 0x38, 0xae, 0x62, 0x8b, 0x7b, 0xf6, 0x34, 0x55, 0x47,
	0x27, 0xac, 0x12, 0x1f, 0xab, 0xa3, 0x13, 0x56, 0xbd, 0xfb, 0x8c, 0x9c, 0xbf, 0x97, 0xeb, 0x6a,
	0xe1, 0x89, 0xdd, 0x4c, 0xfb, 0x8c, 0x66, 0xae, 0xa7, 0xa2, 0xea, 0x3e, 0xa7, 0x79, 0x9d, 0x4c,
	0x26, 0x5e, 0x8b, 0x85, 0x1d, 0x61, 0x62, 0x8c, 0x09, 0xff, 0x66, 0x5b, 0x80, 0x40, 0xe1, 0xb8,
	0x78, 0x4c, 0x91, 0xb3, 0x6f, 0xe5, 0xc0, 0xdc, 0x39, 0x10, 0x70, 0x4e, 0x80, 0x27, 0x03, 0xe4,
	0x61, 0x46, 0x24, 0xc0, 0x33, 0x03, 0x20, 0xe0, 0xbd, 0xd3, 0xf4, 0x27, 0x9e, 0x33, 0x4d, 0xff,
	0xbf, 0x5c, 0x14, 0x69, 0xfa, 0x5d, 0x23, 0x66, 0xa4, 0x01, 0xb8, 0xdf, 0x76, 0xc8, 0x8b, 0xb2,
	0x8f, 0x36, 0xdd, 0xc0, 0xab, 0xb3, 0xd8, 0xe4, 0xb7, 0xe4, 0x86, 0xcc, 0x26, 0xc8, 0x32, 0xb4,
	0xf6, 0xcc, 0x7b, 0x4b, 0x84, 0x7e, 0x55, 0xa1, 0xbf, 0xe3, 0x90, 0xcb, 0x35, 0x6d, 0xad, 0x76,
	0xd5, 0x74, 0x6c, 0xd4, 0x35, 0x2d, 0xcb, 0x9a, 0x5e, 0x5e, 0xe9, 0x2b, 0x14, 0x9e, 0x51, 0x21,
	0xfa, 0x6b, 0x0e, 0x99, 0x8b, 0xe5, 0x57, 0x53, 0xfb, 0x2b, 0x7c, 0x38, 0xcd, 0x2e, 0xbd, 0xa7,
	0x2c, 0xcc, 0x4a, 0x1a, 0x3d, 0xcc, 0x6d, 0x4d, 0x7a, 0x9b, 0x26, 0x23, 0x92, 0xfe, 0x12, 0x21,
	0x5c, 0x9b, 0x78, 0x71, 0xe2, 0x55, 0xd5, 0x79, 0x9f, 0x7b, 0x43, 0xdb, 0x16, 0x82, 0x9d, 0x51,
	0xd0, 0x06, 0x06, 0x96, 0x38, 0x73, 0x5c, 0x63, 0xe2, 0x19, 0xc7, 0x35, 0xac, 0xd1, 0x9d, 0x3a,
	0xae, 0xa1, 0xad, 0x03, 0x3b, 0x53, 0x29, 0x6d, 0x1d, 0xe0, 0xc4, 0xb1, 0xa8, 0xe8, 0x37, 0xc9,
	0x4c, 0xcd, 0xf2, 0x0c, 0x65, 0x1a, 0xf2, 0xe0, 0x6e, 0xe6, 0x9a, 0xe7, 0x33, 0x3d, 0x22, 0xb4,
	0x91, 0x61, 0x3b, 0x9f, 0x90, 0x12, 0xc8, 0x8d, 0x8c, 0x73, 0xa2, 0x3e, 0xba, 0x0e, 0x53, 0xa3,
	0xac, 0xc3, 0x25, 0x59, 0x87, 0x73, 0x90, 0x12, 0x02, 0x19, 0xa1, 0xf4, 0x3b, 0x0e, 0x99, 0x93,
	0xa6, 0x96, 0xae, 0x08, 0x19, 0x65, 0x45, 0xac, 0x9d, 0xe7, 0x94, 0x14, 0xc8, 0x8a, 0xa5, 0x7f,
	0xc3, 0x21, 0xf3, 0x6e, 0x10, 0xb6, 0x5c, 0xdf, 0x63, 0xb1, 0xae, 0xcc, 0xf4, 0x28, 0x2b, 0xa3,
	0x1d, 0xf0, 0xc5, 0xac, 0x1c, 0xe8, 0x16, 0x8d, 0xdf, 0x48, 0x84, 0x97, 0x74, 0x6d, 0x66, 0x4e,
	0xe5, 0x1b, 0x55, 0x52, 0x42, 0x20, 0x23, 0x94, 0x0f, 0x70, 0xaf, 0xb5, 0xe3, 0xfa, 0x6e, 0x50,
	0x65, 0x35, 0x75, 0x4f, 0x83, 0x1a, 0xe0, 0xeb, 0x1a, 0x03, 0x16, 0x15, 0xfd, 0xae, 0x43, 0xe6,
	0x94, 0x55, 0xab, 0xcc, 0xd8, 0x73, 0x43, 0xe6, 0xbe, 0xe8, 0x40, 0x86, 0x34, 0x63, 0xf5, 0xa7,
	0x7d, 0x9c, 0x16, 0x04, 0x59, 0xc9, 0x3d, 0x1c, 0xc5, 0xb9, 0x13, 0x3b, 0x8a, 0xaf, 0x59, 0xc7,
	0x84, 0xc4, 0x16, 0xbe, 0x36, 0x4a, 0x9e, 0x71, 0x54, 0x68, 0xfe, 0xb4, 0x8e, 0x0a, 0x5d, 0x23,
	0xe3, 0x4d, 0x37, 0x6e, 0xca, 0x0d, 0x7c, 0x4d, 0x71, 0xdf, 0x8d, 0x9b, 0x80, 0x98, 0xb4, 0xbb,
	0x7f, 0x61, 0x84, 0xee, 0x7e, 0xe6, 0x5c, 0xda, 0xc5, 0x11, 0x9f, 0x4b, 0xfb, 0x05, 0x91, 0x50,
	0x5e, 0x49, 0x3a, 0xb5, 0xc3, 0xc5, 0x04, 0xef, 0xd8, 0x1c, 0x80, 0xfd, 0x86, 0x61, 0x01, 0x36,
	0x3f, 0xda, 0x20, 0x13, 0x5e, 0xcb, 0x6d, 0xb0, 0xb8, 0x78, 0xe9, 0xf9, 0xae, 0x66, 0xea, 0xfa,
	0x36, 0xeb, 0xc8, 0xc6, 0x58, 0xc3, 0xe2, 0x3f, 0x48, 0xf6, 0x34, 0x22, 0x17, 0xea, 0x22, 0xac,
	0x65, 0x6e, 0x88, 0x62, 0xf5, 0xe2, 0x8b, 0x27, 0xdf, 0xb0, 0xfd, 0x19, 0xc9, 0xf9, 0xc2, 0x5a,
	0x37, 0x1f, 0xe8, 0xc5, 0x9c, 0x76, 0xc8, 0x64, 0x43, 0x38, 0xc8, 0x78, 0x97, 0xe8, 0xc0, 0x97,
	0x35, 0xf7, 0x72, 0xb6, 0xcd, 0x81, 0x21, 0x09, 0x06, 0x25, 0x2b, 0x13, 0x44, 0x79, 0xe9, 0x74,
	0x82, 0x28, 0x3f, 0x3d, 0xaf, 0xfd, 0xd0, 0x93, 0xd9, 0xdc, 0x5f, 0xc6, 0x7b, 0x15, 0xa5, 0xbd,
	0x63, 0x99, 0xdd, 0x5a, 0xdf, 0xad, 0xa4, 0xb0, 0x90, 0xa1, 0x1e, 0x64, 0x8f, 0xe7, 0xeb, 0x64,
	0x2c, 0xea, 0xa8, 0x34, 0xeb, 0xbb, 0x43, 0x9d, 0xc0, 0xe0, 0x9e, 0x9d, 0xbe, 0x2b, 0x92, 0xfb,
	0xec, 0x9c, 0x73, 0xea, 0xb0, 0x54, 0xfe, 0x8c, 0x0e, 0x4b, 0xdd, 0x24, 0xe3, 0x51, 0xe8, 0x2b,
	0xa3, 0x48, 0x0d, 0xca, 0x71, 0x08, 0x7d, 0x6e, 0x13, 0xa9, 0x6f, 0xc2, 0xff, 0x02, 0x12, 0xea,
	0x4d, 0x90, 0xc9, 0xb3, 0xd9, 0x04, 0x29, 0x9c, 0xf6, 0x26, 0x48, 0x55, 0xde, 0xb4, 0x20, 0x52,
	0xbd, 0x1f, 0x59, 0xb7, 0x2c, 0x8c, 0x64, 0xaf, 0x4e, 0x5c, 0xc6, 0xd0, 0x22, 0x13, 0x61, 0xe4,
	0x35, 0xbc, 0xe1, 0xed, 0x9e, 0x3e, 0x27, 0x93, 0x91, 0x39, 0x48, 0x21, 0xe9, 0xa3, 0x65, 0xd3,
	0x67, 0x77, 0xb4, 0x2c, 0x26, 0x53, 0x3a, 0xca, 0x25, 0xcd, 0x98, 0x51, 0x6c, 0x69, 0x68, 0xa1,
	0x3a, 0xa0, 0x06, 0x46, 0x0e, 0x2d, 0x93, 0x09, 0x61, 0x6f, 0x4a, 0xab, 0x85, 0x88, 0x2b, 0x22,
	0x38, 0x04, 0x24, 0x86, 0xde, 0x20, 0x05, 0x55, 0x00, 0x2d, 0x14, 0x99, 0x8b, 0xa2, 0x6d, 0x0a,
	0x8d, 0xa5, 0x5f, 0x25, 0x45, 0x75, 0x71, 0x6c, 0x56, 0x31, 0xcb, 0x1b, 0xb2, 0xaf, 0x1c, 0x1f,
	0x95, 0x8a, 0xf7, 0xfa, 0xd0, 0x40, 0xdf, 0xd2, 0x78, 0xfd, 0xaf, 0x1b, 0x8b, 0x14, 0x41, 0x75,
	0xfd, 0xaf, 0x1b, 0x27, 0x80, 0x50, 0xba, 0x46, 0xa8, 0x1b, 0x25, 0x5e, 0xdd, 0xad, 0xda, 0xe7,
	0x0f, 0x44, 0x7e, 0x34, 0x5e, 0x9a, 0xb1, 0xd8, 0x85, 0x85, 0x1e, 0x25, 0x70, 0x3b, 0x58, 0xec,
	0x86, 0xd2, 0x11, 0xed, 0x86, 0x92, 0x1e, 0x3b, 0xa1, 0x6d, 0x32, 0x15, 0x1f, 0x06, 0x49, 0x93,
	0x25, 0x5e, 0x55, 0x9a, 0x1f, 0x03, 0xc6, 0x88, 0x2b, 0x8a, 0x8d, 0xb9, 0x9f, 0x50, 0x83, 0xc0,
	0x08, 0xa1, 0x07, 0xdc, 0x2e, 0xd1, 0xf7, 0xe4, 0x49, 0xbb, 0x64, 0x75, 0xd0, 0x9b, 0x33, 0x53,
	0x17, 0xee, 0x29, 0x93, 0x45, 0x03, 0xc1, 0x16, 0x45, 0xef, 0xe9, 0xdb, 0x16, 0x5e, 0x38, 0xf9,
	0xea, 0x4e, 0x7a, 0xdc, 0xb4, 0xd0, 0xcc, 0xae, 0xdf, 0x83, 0x1e, 0xd5, 0x91, 0x0b, 0x37, 0x2e,
	0x22, 0x3d, 0x97, 0x6c, 0x79, 0x09, 0xf5, 0x65, 0xcc, 0x06, 0x4f, 0x5f, 0x42, 0xdd, 0x7d, 0xfe,
	0xfa, 0x67, 0x4e, 0x7c, 0xfe, 0xfa, 0x2e, 0x39, 0x2f, 0xed, 0x12, 0x94, 0x88, 0xa5, 0xaf, 0x9a,
	0x0b, 0x41, 0xd6, 0x32, 0x38, 0xe8, 0xa2, 0xee, 0x3a, 0x20, 0x52, 0x3a, 0xe3, 0x03, 0x22, 0xe5,
	0x7f, 0x3a, 0x2e, 0x52, 0xe1, 0x53, 0xa1, 0x03, 0xda, 0x21, 0x85, 0xba, 0xba, 0xc6, 0xcb, 0x41,
	0x03, 0x67, 0xc0, 0xa8, 0x84, 0xde, 0xea, 0xd4, 0x51, 0x09, 0xbd, 0xf6, 0xea, 0xcb, 0xc0, 0xb4,
	0x28, 0x6e, 0xe6, 0x47, 0xe1, 0x7e, 0x2c, 0x13, 0xda, 0x67, 0xcc, 0xda, 0xbb, 0x1f, 0x03, 0x62,
	0xe8, 0xab, 0x64, 0xb2, 0x8a, 0xf7, 0xe1, 0xc5, 0x32, 0x65, 0xdd, 0xba, 0xd7, 0x16, 0xc1, 0xa0,
	0xf0, 0xf4, 0x36, 0x99, 0x8e, 0xbd, 0x6f, 0xb0, 0xf5, 0x60, 0xe9, 0x30, 0x91, 0x97, 0xa9, 0x58,
	0xd9, 0xdc, 0x15, 0x83, 0x02, 0x9b, 0x8e, 0xfe, 0x5d, 0x87, 0x5c, 0xb2, 0x46, 0x7b, 0xfc, 0xae,
	0x97, 0x34, 0xc5, 0x33, 0x0a, 0x72, 0x47, 0x62, 0x71, 0xe8, 0x39, 0xa6, 0x2f, 0x85, 0xbc, 0xb4,
	0xdc, 0x53, 0x10, 0xf4, 0xa9, 0x00, 0x46, 0xad, 0x92, 0xb0, 0x6d, 0x97, 0x2a, 0x4e, 0x8e, 0xaa,
	0x52, 0xda, 0xb1, 0xdc, 0x4e, 0x4b, 0x80, 0xac, 0xc8, 0xf2, 0x1f, 0x4f, 0x92, 0xd9, 0xd4, 0x56,
	0xd6, 0x48, 0x23, 0x9e, 0x2d, 0x71, 0x11, 0xde, 0x1e, 0x7b, 0xde, 0x10, 0x77, 0x2f, 0x93, 0xaf,
	0xc7, 0x75, 0x2f, 0x8b, 0xc8, 0x1c, 0xa4, 0x10, 0xfa, 0x7d, 0x87, 0x5c, 0x40, 0x8f, 0xa9, 0x67,
	0x34, 0xf0, 0x17, 0x95, 0x53, 0xb2, 0xd1, 0x4d, 0x32, 0x8a, 0x88, 0x60, 0x2f, 0xd1, 0xf4, 0x6f,
	0x3a, 0x84, 0xba, 0x7b, 0xae, 0x87, 0x4f, 0x71, 0x28, 0xa4, 0x4a, 0x34, 0x1c, 0x51, 0x77, 0xe8,
	0xaf, 0xb2, 0xd8, 0x25, 0x08, 0x7a, 0x08, 0xa7, 0x75, 0x72, 0xce, 0xae, 0xea, 0xa2, 0xba, 0x2d,
	0xe1, 0x79, 0x5c, 0x55, 0x54, 0xa9, 0x1b, 0x29, 0x2e, 0x90, 0xe1, 0xca, 0x97, 0x7d, 0x0e, 0x59,
	0xeb, 0xb5, 0xc3, 0xad, 0xef, 0xca, 0xca, 0x04, 0x2f, 0x7a, 0x94, 0x48, 0xc7, 0x03, 0x0a, 0xa7,
	0x74, 0xf6, 0x7c, 0xea, 0x4c, 0xcf, 0x9e, 0xa7, 0xfd, 0x4e, 0x72, 0x3a, 0x7e, 0xe7, 0x6f, 0x3a,
	0x24, 0xf3, 0xa2, 0x03, 0x6d, 0xa6, 0xee, 0xc5, 0x9e, 0x5a, 0xda, 0xb2, 0x6e, 0xee, 0x8d, 0xbc,
	0xea, 0x50, 0x4e, 0x4e, 0xfa, 0x6e, 0xec, 0x97, 0xed, 0xdb, 0x0a, 0xfa, 0x5c, 0x24, 0x5c, 0xfe,
	0xbd, 0x1c, 0x99, 0x58, 0x0d, 0x12, 0x71, 0x6c, 0xee, 0xb4, 0xb7, 0x31, 0x77, 0x52, 0xdb, 0x98,
	0x03, 0xda, 0x8e, 0xa2, 0xb6, 0x7d, 0x77, 0x2f, 0x3f, 0xc8, 0xec, 0x5e, 0x2e, 0x0d, 0x25, 0xe5,
	0xd9, 0x9b, 0x96, 0xff, 0xc1, 0x21, 0x44, 0x10, 0x9e, 0xc1, 0x5e, 0xa5, 0x9b, 0xde, 0xab, 0xfc,
	0xd2, 0x30, 0xed, 0xea, 0xb3, 0x45, 0xf9, 0x67, 0xba, 0x3d, 0x18, 0x25, 0x49, 0x1d, 0x29, 0x77,
	0x46, 0x71, 0xa4, 0x7c, 0x80, 0xb0, 0xc8, 0xab, 0x64, 0xf2, 0x83, 0xd0, 0x0b, 0x1e, 0xb0, 0x43,
	0x99, 0xff, 0xa0, 0x6d, 0x94, 0xb7, 0x05, 0x18, 0x14, 0xfe, 0x43, 0x13, 0xfd, 0xf5, 0x39, 0xc6,
	0x89, 0x9e, 0xe7, 0x18, 0xff, 0x4e, 0x8e, 0xcc, 0xd8, 0x9f, 0xfd, 0xe3, 0x91, 0xfa, 0x9f, 0xd6,
	0x63, 0x63, 0xa7, 0xa3, 0xc7, 0xfe, 0x73, 0x8e, 0xcc, 0xaf, 0x1e, 0x54, 0x99, 0xff, 0x30, 0x4c,
	0xd8, 0x4e, 0x18, 0xee, 0xe2, 0xf8, 0x58, 0x23, 0xb4, 0xee, 0x45, 0x71, 0x52, 0x69, 0x32, 0x96,
	0x70, 0xc3, 0x6a, 0x45, 0x8d, 0xfc, 0x82, 0x58, 0x5d, 0xd6, 0xba, 0xb0, 0xd0, 0xa3, 0x04, 0xfd,
	0x2c, 0x99, 0x8a, 0x39, 0xc0, 0x8a, 0xb3, 0x09, 0x4f, 0x4d, 0x01, 0xc1, 0xe0, 0xe9, 0x02, 0x21,
	0xf8, 0x47, 0x3c, 0x0d, 0x32, 0x66, 0xde, 0xc6, 0xaa, 0x68, 0x28, 0x58, 0x14, 0xf4, 0x0e, 0x99,
	0x15, 0x36, 0x2c, 0x32, 0x0a, 0xf7, 0xa5, 0xa5, 0x8b, 0xab, 0xe7, 0xb2, 0x46, 0xc4, 0x10, 0xee,
	0x43, 0x9a, 0x90, 0xd6, 0xc9, 0x38, 0x4e, 0xe5, 0xfc, 0x30, 0x29, 0xfc, 0xd8, 0x6b, 0x58, 0xb5,
	0xc5, 0x88, 0xb9, 0x46, 0x63, 0x61, 0x67, 0x20, 0xff, 0xf2, 0x4f, 0x1d, 0x72, 0x2e, 0x4d, 0xc6,
	0xe7, 0x09, 0x0b, 0x12, 0x2f, 0x62, 0x08, 0x92, 0x5d, 0x8a, 0xf3, 0x64, 0xd5, 0x80, 0xc1, 0xa6,
	0xe1, 0xfd, 0x52, 0x8f, 0xc2, 0x96, 0xbc, 0x09, 0x3b, 0x67, 0xfa, 0x65, 0x4d, 0x43, 0xc1, 0xa2,
	0xa0, 0x37, 0x48, 0x21, 0x09, 0x25, 0xf5, 0x98, 0xb9, 0xba, 0x6c, 0x5b, 0xc2, 0x40, 0x63, 0xf1,
	0x7d, 0x9b, 0x28, 0x6c, 0x99, 0xbe, 0x13, 0xef, 0xdb, 0x08, 0x10, 0x28, 0x1c, 0xbe, 0x73, 0x11,
	0x72, 0xa2, 0xbc, 0x79, 0x8a, 0x63, 0x9b, 0x03, 0x40, 0xc0, 0xf1, 0x52, 0x60, 0xdb, 0x89, 0xfb,
	0xb8, 0x5c, 0x0a, 0x6c, 0xd7, 0xf9, 0xb4, 0x2f, 0x05, 0x4e, 0xc9, 0xfa, 0xf0, 0x4b, 0x81, 0x6d,
	0xf2, 0x8f, 0xcd, 0xa5, 0xc0, 0x76, 0xa5, 0xfb, 0x2c, 0x44, 0xdf, 0x9e, 0x4d, 0xb7, 0xed, 0x94,
	0x96, 0x23, 0xbd, 0x60, 0xe4, 0x9e, 0x91, 0x7a, 0xd3, 0xb5, 0x5e, 0x99, 0xd4, 0x9b, 0x7e, 0x6b,
	0x56, 0xef, 0x68, 0xdb, 0xf8, 0x73, 0x47, 0xdb, 0xbe, 0xe5, 0x10, 0xe2, 0xe9, 0x94, 0x66, 0xb9,
	0xac, 0xbd, 0x8f, 0x5b, 0xa6, 0x1a, 0x7a, 0x0a, 0xa9, 0xd3, 0x96, 0x4c, 0x7a, 0x8b, 0x10, 0x86,
	0x6b, 0xa2, 0x95, 0xd5, 0xa3, 0xe7, 0xdc, 0xaa, 0xc6, 0x80, 0x45, 0xa5, 0x97, 0xd9, 0xc9, 0x5e,
	0xcb, 0x2c, 0x77, 0xbb, 0xcf, 0x09, 0x01, 0xca, 0x2a, 0x97, 0x1e, 0xc5, 0x68, 0x76, 0x23, 0xf4,
	0x0e, 0xcd, 0x7a, 0x4a, 0x06, 0x64, 0x64, 0xd2, 0x5f, 0x21, 0x33, 0xf1, 0x61, 0x50, 0xad, 0xa4,
	0xbd, 0x8f, 0xd1, 0xd4, 0xc1, 0x1c, 0x8f, 0xb7, 0x24, 0x40, 0x4a, 0x5e, 0xea, 0xc8, 0x0b, 0x39,
	0xa3, 0x23, 0x2f, 0xe6, 0x30, 0xcf, 0xf4, 0x29, 0x1e, 0xe6, 0x69, 0x90, 0x7c, 0x32, 0xe2, 0x10,
	0xbd, 0xd6, 0x12, 0x22, 0x3c, 0x2f, 0xf8, 0xd3, 0xd8, 0x7a, 0x89, 0x60, 0x76, 0xa4, 0x87, 0x2c,
	0xb4, 0x0e, 0xec, 0x7e, 0x8d, 0x40, 0xbe, 0x9a, 0x26, 0x57, 0xce, 0x73, 0xe6, 0x55, 0x8e, 0x6d,
	0x0d, 0x05, 0x8b, 0x82, 0xde, 0x25, 0xe7, 0xcd, 0x3f, 0xf9, 0x46, 0xdb, 0x9c, 0x89, 0x6a, 0x6e,
	0x67, 0x70, 0xd0, 0x45, 0xcd, 0xcd, 0xa3, 0x5d, 0x76, 0x28, 0x05, 0x9e, 0x37, 0xe6, 0xd1, 0x03,
	0x05, 0x04, 0x83, 0xa7, 0xdf, 0x73, 0xc8, 0x5c, 0xcb, 0x4d, 0x58, 0xe4, 0xb9, 0xbe, 0xf7, 0x0d,
	0xd1, 0x37, 0xf3, 0xc3, 0x64, 0x8d, 0x6e, 0xa6, 0x99, 0xe1, 0xf8, 0xd2, 0xc1, 0xad, 0x0c, 0x12,
	0xb2, 0xa2, 0xd3, 0x5b, 0x45, 0xf4, 0xec, 0xb6, 0x8a, 0x4c, 0x54, 0xfd, 0xc2, 0x50, 0x51, 0xf5,
	0xf2, 0xaf, 0x4f, 0x11, 0xda, 0xbd, 0x28, 0xd3, 0x3b, 0x2a, 0xdb, 0x4b, 0xac, 0x1c, 0xe5, 0x6c,
	0xb6, 0xd7, 0xbc, 0x5d, 0x26, 0x95, 0xea, 0xd5, 0xdb, 0xa9, 0x18, 0x1b, 0xde, 0xa9, 0x18, 0x1f,
	0xa1, 0x53, 0xa1, 0x42, 0xc7, 0xf9, 0xbe, 0xa1, 0xe3, 0xbf, 0xde, 0xad, 0xc5, 0x27, 0x47, 0x1e,
	0xbf, 0x39, 0xa9, 0x2e, 0xff, 0x35, 0x27, 0xa3, 0xcc, 0x0b, 0x23, 0xaf, 0xca, 0x49, 0x54, 0xfa,
	0x2f, 0x93, 0xe9, 0x30, 0xf0, 0xbd, 0x40, 0x3c, 0xe7, 0x31, 0x74, 0x32, 0x5c, 0x4a, 0x25, 0x69,
	0xa3, 0xe3, 0x91, 0x91, 0x00, 0xb6, 0x38, 0x1a, 0x11, 0x6a, 0xfd, 0x95, 0xa7, 0x7f, 0xe4, 0xd2,
	0xf2, 0xdc, 0x77, 0xe8, 0x3f, 0xea, 0xe2, 0x04, 0x3d, 0xb8, 0xd3, 0x7b, 0x64, 0x5e, 0x7c, 0x0a,
	0xfb, 0x6c, 0x91, 0x38, 0x58, 0xa8, 0xf3, 0xd4, 0xd6, 0xb3, 0x04, 0xd0, 0x5d, 0xa6, 0xfb, 0x18,
	0xd0, 0xcc, 0x47, 0x7d, 0x0c, 0x68, 0x76, 0xc0, 0x63, 0x40, 0xe7, 0x4e, 0xc7, 0x03, 0xff, 0x71,
	0x4e, 0x5b, 0xc4, 0xf7, 0xad, 0x97, 0xe2, 0x4e, 0xdb, 0x81, 0xf2, 0x53, 0x0e, 0xd4, 0xdb, 0x43,
	0x19, 0xfc, 0xe9, 0xf7, 0xef, 0x7a, 0x39, 0x51, 0x49, 0xc6, 0x89, 0xda, 0x18, 0x91, 0xbc, 0x67,
	0x3b, 0x52, 0x3f, 0x71, 0xc8, 0xc5, 0x6c, 0x91, 0x33, 0x70, 0xa6, 0x76, 0xd3, 0xce, 0xd4, 0xda,
	0x68, 0xda, 0xda, 0xef, 0xda, 0xc9, 0xa9, 0xee, 0x36, 0xfe, 0x45, 0x3b, 0xe4, 0x7e, 0xdd, 0xec,
	0x46, 0xe6, 0xd1, 0x73, 0x98, 0xee, 0xb9, 0x13, 0xb9, 0x45, 0xa6, 0xc4, 0x2a, 0xcf, 0x57, 0xf7,
	0x89, 0xe7, 0x74, 0x03, 0x2b, 0xaa, 0x24, 0x18, 0x26, 0x18, 0x0a, 0x91, 0x77, 0xea, 0xc9, 0xa3,
	0xe0, 0x22, 0x14, 0xa2, 0xee, 0xd9, 0xd3, 0x58, 0xee, 0xd9, 0xf8, 0xde, 0x1e, 0x93, 0x4f, 0xb9,
	0xa3, 0x67, 0xb3, 0xe1, 0xed, 0x31, 0x40, 0x28, 0x7d, 0x40, 0xf2, 0x71, 0xe2, 0x46, 0xc9, 0x00,
	0x4a, 0x57, 0x3c, 0x2f, 0xcd, 0x0b, 0x83, 0xe0, 0x41, 0x57, 0xc9, 0x18, 0x0b, 0x6a, 0x03, 0xdc,
	0xe4, 0x8e, 0x1b, 0xf2, 0xab, 0x41, 0x0d, 0x78, 0x79, 0xfa, 0x90, 0x4c, 0xee, 0x70, 0xeb, 0x83,
	0xd5, 0xa5, 0x39, 0x7e, 0xa2, 0xbe, 0xd2, 0x31, 0xd6, 0x25, 0x51, 0x16, 0x14, 0x13, 0xfa, 0x6d,
	0x87, 0xcc, 0xa5, 0xdf, 0xa4, 0x8e, 0x8b, 0xb3, 0xc3, 0xdc, 0x2c, 0x9e, 0xde, 0x1e, 0xb1, 0xae,
	0x36, 0x4f, 0x0b, 0x81, 0xac, 0x54, 0xfa, 0x16, 0x99, 0xe3, 0xab, 0xef, 0x7a, 0x90, 0xb0, 0x68,
	0xcf, 0xf5, 0x2b, 0xac, 0x2a, 0xef, 0xe9, 0xc2, 0xfb, 0x63, 0x2a, 0x69, 0x14, 0x64, 0x69, 0xd3,
	0xc9, 0x44, 0x73, 0x67, 0x94, 0x4c, 0xf4, 0x06, 0x99, 0x69, 0xb0, 0x40, 0xa3, 0x64, 0xb2, 0x0e,
	0x66, 0x15, 0xdc, 0xb3, 0xe0, 0x90, 0xa2, 0xa2, 0xdf, 0x71, 0xc8, 0xac, 0xdc, 0xd5, 0x5f, 0xf3,
	0xfc, 0x84, 0xa9, 0x8b, 0x0d, 0x77, 0xd4, 0x19, 0xbc, 0x35, 0x1b, 0xf9, 0xf4, 0xa8, 0xb4, 0x3e,
	0x64, 0x40, 0x40, 0x30, 0xc2, 0x58, 0x40, 0x5a, 0x30, 0x56, 0x25, 0x52, 0xc3, 0x04, 0x83, 0x12,
	0x34, 0x5d, 0x15, 0xb0, 0x91, 0xc3, 0x54, 0x45, 0x33, 0xe2, 0x66, 0x82, 0xa8, 0x4a, 0x4a, 0x70,
	0xf9, 0x47, 0x93, 0xe4, 0x52, 0x6f, 0x4d, 0x3f, 0xd2, 0xc0, 0x7d, 0xdb, 0x68, 0xa5, 0xa1, 0x0e,
	0x89, 0x65, 0x5e, 0x86, 0x7e, 0x46, 0xaa, 0x45, 0xca, 0xaa, 0x1f, 0x1b, 0xa1, 0x55, 0xaf, 0x12,
	0xcb, 0xf3, 0xa7, 0x95, 0x58, 0xfe, 0xa5, 0xf4, 0x19, 0x98, 0x57, 0xb2, 0x5e, 0xd1, 0x0b, 0xd9,
	0xef, 0x95, 0xf2, 0x8c, 0xfe, 0x9a, 0xd3, 0xfb, 0x25, 0x90, 0xaf, 0xe9, 0x61, 0x7e, 0x06, 0x86,
	0xe0, 0x97, 0xfb, 0xbc, 0x06, 0xa2, 0x5d, 0x91, 0x0f, 0x31, 0x06, 0xed, 0x43, 0x0b, 0xb1, 0x38,
	0x3b, 0x20, 0x1d, 0x81, 0x53, 0x3c, 0xb4, 0x20, 0x05, 0x41, 0x56, 0x32, 0x7d, 0x99, 0xe4, 0xf1,
	0x5a, 0x47, 0xf9, 0x3c, 0xa7, 0x09, 0xa3, 0x70, 0x20, 0x08, 0x1c, 0x7d, 0x85, 0x4c, 0xe0, 0xad,
	0x81, 0xb1, 0xbc, 0x68, 0x51, 0xdb, 0x49, 0xe2, 0x7a, 0x41, 0x90, 0xd8, 0xb3, 0x79, 0x08, 0xe4,
	0xff, 0x9f, 0x27, 0xf3, 0x5d, 0x69, 0x4e, 0x27, 0x78, 0x46, 0xbd, 0x4d, 0x0a, 0x7c, 0xbe, 0x61,
	0xae, 0xad, 0xb0, 0x51, 0xb6, 0x95, 0xed, 0xa5, 0x14, 0xc8, 0xd3, 0xa3, 0xd2, 0xdd, 0x61, 0x72,
	0x6e, 0x51, 0x09, 0x69, 0x29, 0xbc, 0x6f, 0xab, 0xfa, 0xc2, 0x50, 0x6b, 0x7b, 0x5d, 0x5c, 0xa0,
	0x28, 0x70, 0xf4, 0x35, 0x52, 0xa8, 0xf1, 0x36, 0x04, 0x55, 0x75, 0x2b, 0xa8, 0x36, 0x09, 0x57,
	0x24, 0x1c, 0x34, 0x05, 0x3e, 0x35, 0xe6, 0xc5, 0x31, 0xb7, 0x43, 0xf2, 0xe9, 0x7c, 0xac, 0x4d,
	0x01, 0x06, 0x85, 0xe7, 0xe3, 0xb4, 0xcd, 0xa2, 0x2a, 0x0b, 0x12, 0x89, 0xc2, 0x39, 0xe7, 0x98,
	0x71, 0xba, 0x95, 0xc2, 0x42, 0x86, 0x9a, 0xf7, 0x68, 0x8b, 0xb9, 0x62, 0x8a, 0x39, 0xa6, 0x47,
	0x37, 0x99, 0x1b, 0x00, 0x62, 0xf8, 0xb0, 0x88, 0x93, 0x5a, 0x8d, 0xed, 0xe1, 0x0c, 0x70, 0x6c,
	0xf3, 0xb9, 0xb6, 0xc2, 0xf6, 0x40, 0x62, 0x79, 0x13, 0xf7, 0xdc, 0xc8, 0x73, 0x83, 0xaa, 0xb0,
	0x8b, 0x1c, 0xd3, 0xc4, 0x77, 0x24, 0x1c, 0x34, 0x05, 0xfd, 0x24, 0x19, 0x6b, 0xc9, 0x3c, 0x65,
	0xc7, 0xe4, 0xa8, 0x6f, 0x7a, 0x01, 0x70, 0x38, 0xa2, 0xdd, 0x03, 0x1c, 0x88, 0x36, 0xda, 0x3d,
	0x00, 0x0e, 0xe7, 0xb2, 0x76, 0x3b, 0x51, 0x12, 0xc6, 0x9e, 0x88, 0x2e, 0x5a, 0xb2, 0x1e, 0x48,
	0x38, 0x68, 0x0a, 0x4e, 0x1d, 0xef, 0xb2, 0xfd, 0x80, 0xc5, 0x31, 0xba, 0x73, 0x16, 0x75, 0x45,
	0xc2, 0x41, 0x53, 0x70, 0xd1, 0x71, 0x47, 0xdc, 0xd6, 0x32, 0x66, 0x44, 0x57, 0x3a, 0x2d, 0xe0,
	0x70, 0x51, 0xb3, 0x1a, 0x5a, 0x0a, 0xa9, 0x9a, 0xd5, 0x78, 0xcd, 0x6a, 0x1c, 0xdd, 0xbe, 0x75,
	0x1b, 0x17, 0x74, 0x0b, 0xbd, 0x75, 0xeb, 0x36, 0x70, 0x38, 0xa2, 0x6f, 0x7f, 0x1e, 0xd7, 0x6d,
	0x1b, 0x7d, 0xfb, 0xf3, 0xc0, 0xe1, 0x88, 0x7e, 0xf3, 0x36, 0xae, 0xa5, 0x36, 0xfa, 0x4d, 0x5e,
	0xfa, 0x4d, 0x2c, 0xed, 0x3d, 0x89, 0x30, 0x94, 0x65, 0xa1, 0xd7, 0x7f, 0x0e, 0x80, 0xc3, 0xf1,
	0x5b, 0x86, 0x35, 0x26, 0xaf, 0xb4, 0x34, 0xdf, 0x32, 0xac, 0x31, 0x40, 0x0c, 0x1f, 0xab, 0xdf,
	0x60, 0x51, 0x18, 0x63, 0x8e, 0xa9, 0x35, 0x56, 0xdf, 0xe3, 0x40, 0x10, 0x38, 0x3e, 0xfa, 0xbc,
	0x60, 0xcf, 0xf5, 0xbd, 0x1a, 0x1e, 0x6f, 0xb1, 0x46, 0xdf, 0xba, 0x00, 0x83, 0xc2, 0x8b, 0xe3,
	0x5c, 0xed, 0x30, 0x4a, 0xf0, 0xab, 0xbf, 0x88, 0x4c, 0xad, 0xe3, 0x5c, 0x0a, 0x03, 0x16, 0x15,
	0x1f, 0x4f, 0x89, 0xc8, 0xfc, 0x2b, 0xa2, 0xd5, 0xa3, 0xc7, 0x93, 0x4c, 0xd3, 0x93, 0x58, 0x4e,
	0xe7, 0x35, 0x82, 0x30, 0x62, 0xc5, 0x97, 0xd2, 0x74, 0xeb, 0x08, 0x05, 0x89, 0xe5, 0x5f, 0x37,
	0xe8, 0xf8, 0x98, 0x58, 0x55, 0xbc, 0x2c, 0xec, 0x28, 0xf5, 0x75, 0x1f, 0x4a, 0x38, 0x68, 0x0a,
	0xba, 0x48, 0xe6, 0x9a, 0x5e, 0xa3, 0xb9, 0xec, 0x46, 0x35, 0x2f, 0x70, 0x7d, 0x2f, 0x39, 0xc4,
	0xcc, 0xd4, 0x82, 0x51, 0xa6, 0xf7, 0xd3, 0x68, 0xc8, 0xd2, 0xd3, 0xaf, 0x93, 0x97, 0x10, 0x14,
	0x46, 0xd1, 0xbb, 0x5e, 0xd2, 0x7c, 0x94, 0x34, 0x59, 0xa4, 0x9f, 0x67, 0xbd, 0x82, 0xcc, 0x3e,
	0x25, 0x99, 0xbd, 0x74, 0xbf, 0x1f, 0x21, 0xf4, 0xe7, 0x41, 0xef, 0x91, 0x79, 0x3f, 0xdc, 0x57,
	0x38, 0x99, 0x26, 0xf9, 0x49, 0xf1, 0x84, 0xac, 0x8a, 0xa6, 0x6c, 0x64, 0x09, 0xa0, 0xbb, 0x0c,
	0x57, 0x0e, 0x5c, 0x8a, 0x9c, 0xeb, 0x5b, 0xd5, 0x04, 0xf3, 0x68, 0x0b, 0x46, 0x39, 0xdc, 0x4f,
	0x61, 0x21, 0x43, 0x8d, 0x53, 0x7f, 0x97, 0xed, 0xb3, 0x1a, 0x66, 0xd0, 0x5a, 0x9f, 0xa0, 0x82,
	0x50, 0x90, 0x58, 0xfe, 0x09, 0xaa, 0x61, 0x10, 0x27, 0x6e, 0x90, 0x14, 0x3f, 0x95, 0xfe, 0x04,
	0xcb, 0x12, 0x0e, 0x9a, 0x82, 0xde, 0x24, 0x53, 0xb5, 0x4e, 0xdb, 0xf7, 0xaa, 0x6e, 0xc2, 0x8a,
	0x65, 0x24, 0xd7, 0xd6, 0xf2, 0x8a, 0x42, 0x80, 0xa1, 0xe1, 0xec, 0x23, 0x26, 0x0c, 0xb2, 0xe2,
	0xcb, 0x69, 0xf6, 0x20, 0xe1, 0xa0, 0x29, 0xe8, 0x1d, 0x7c, 0xb2, 0x1b, 0x8f, 0x82, 0xe1, 0x8c,
	0xbf, 0x8e, 0xa3, 0x52, 0xc7, 0xed, 0x96, 0x2d, 0x1c, 0xa4, 0x28, 0xb9, 0xb9, 0xa8, 0x54, 0x30,
	0xe6, 0x46, 0x89, 0x3b, 0x72, 0x5f, 0xc1, 0xf2, 0xe6, 0x0e, 0xe6, 0x2e, 0x0a, 0xe8, 0x51, 0x8a,
	0x6e, 0x92, 0x0b, 0xad, 0x30, 0x4e, 0xd6, 0x22, 0xf6, 0x44, 0x3e, 0xad, 0xcb, 0xcd, 0xc8, 0xe2,
	0xa7, 0x91, 0x99, 0x3e, 0x94, 0xb5, 0xd9, 0x4d, 0x02, 0xbd, 0xca, 0xd1, 0x7d, 0x32, 0xd5, 0xd4,
	0x07, 0x04, 0x5e, 0x7d, 0xbe, 0x5d, 0xec, 0x2e, 0x3b, 0x42, 0x9b, 0x5d, 0x7c, 0x35, 0x33, 0x7d,
	0x6f, 0x4e, 0x17, 0x18, 0x59, 0xa2, 0x37, 0xa3, 0x68, 0x3b, 0x94, 0xc3, 0xf0, 0x33, 0xd9, 0xde,
	0x34, 0x38, 0x48, 0x51, 0x72, 0x5d, 0xe3, 0x61, 0x6e, 0xc6, 0x67, 0xd3, 0x36, 0x87, 0x48, 0xcd,
	0x10, 0x38, 0xda, 0x21, 0x85, 0x50, 0x3d, 0x2b, 0xfc, 0xda, 0x30, 0x07, 0xb5, 0xe5, 0x93, 0xc3,
	0xbd, 0x52, 0xa2, 0xf5, 0xeb, 0xc4, 0x5a, 0x14, 0x2d, 0x93, 0x89, 0x3d, 0xf1, 0x1a, 0xf2, 0xe7,
	0x30, 0xc2, 0x80, 0x11, 0x7f, 0xd9, 0xdf, 0x12, 0x53, 0xfe, 0xfe, 0x18, 0xa1, 0xdd, 0x7b, 0x6a,
	0xf4, 0x0e, 0x29, 0xd4, 0xe5, 0x2b, 0xd3, 0xd2, 0x0c, 0xb9, 0x82, 0xbb, 0x6c, 0x12, 0xd6, 0xf5,
	0x12, 0xb5, 0xa6, 0xa6, 0xef, 0x93, 0xb1, 0x6a, 0xbc, 0x37, 0xdc, 0x95, 0x3a, 0xd6, 0x6b, 0xfa,
	0x66, 0x01, 0x58, 0x8e, 0xf7, 0x80, 0xb3, 0xa6, 0x3e, 0xc9, 0xb3, 0x83, 0x2a, 0xf3, 0x87, 0x7b,
	0x9e, 0xa5, 0x2b, 0xc1, 0xc7, 0x7c, 0x3b, 0x44, 0x81, 0x10, 0xc2, 0x3d, 0xa2, 0xb6, 0x1b, 0x3d,
	0xe9, 0x30, 0xb5, 0xe7, 0x30, 0xa0, 0x47, 0xb4, 0x25, 0x98, 0xe8, 0x76, 0xe9, 0xe5, 0x46, 0x22,
	0x40, 0x89, 0x29, 0xff, 0x43, 0x87, 0x4c, 0xdd, 0x73, 0x3b, 0x0d, 0x36, 0xe8, 0x9b, 0xe5, 0x65,
	0x32, 0x51, 0x35, 0x89, 0x31, 0xf2, 0xbb, 0xcb, 0xcd, 0x33, 0x89, 0xa1, 0x2f, 0x91, 0xb1, 0x28,
	0xdc, 0x97, 0xb9, 0x30, 0x18, 0x44, 0x81, 0x70, 0x1f, 0x38, 0x0c, 0x1f, 0xb0, 0xaf, 0xba, 0xbe,
	0xab, 0x5e, 0x1a, 0x15, 0x67, 0x56, 0x10, 0x02, 0x12, 0x53, 0xfe, 0x5d, 0x87, 0xd8, 0x0f, 0x9a,
	0xd0, 0x65, 0x32, 0xdf, 0xf0, 0x92, 0xe5, 0x30, 0x08, 0x18, 0x5e, 0x0c, 0x6e, 0xd5, 0x15, 0x6f,
	0xc5, 0xb8, 0x97, 0x45, 0x42, 0x37, 0x3d, 0xaf, 0x53, 0x27, 0xf2, 0x65, 0xa5, 0xb1, 0x4e, 0x8f,
	0x61, 0x03, 0x38, 0x8c, 0xd7, 0x69, 0x27, 0x72, 0x83, 0x6a, 0x53, 0xc6, 0xd6, 0xb0, 0x4e, 0x4b,
	0x08, 0x01, 0x89, 0xa1, 0xd7, 0xc9, 0x64, 0x3b, 0xf2, 0xf6, 0xb8, 0xbe, 0x1d, 0x37, 0x57, 0x1c,
	0x6e, 0x09, 0x10, 0x28, 0x5c, 0xf9, 0x7f, 0xe6, 0xc8, 0xb4, 0x75, 0xea, 0x83, 0x17, 0x63, 0x01,
	0x5f, 0x35, 0x6b, 0x32, 0xf3, 0x08, 0x8b, 0xad, 0x0a, 0x10, 0x28, 0x1c, 0x27, 0x53, 0x07, 0x4e,
	0x72, 0x26, 0x5e, 0xd7, 0x75, 0x5a, 0xa4, 0x4d, 0xa6, 0xea, 0x11, 0x7b, 0xd2, 0x61, 0x41, 0xf5,
	0x50, 0xd6, 0x15, 0xb8, 0xda, 0x59, 0x53, 0xc0, 0x61, 0x4e, 0xdc, 0x69, 0x26, 0x60, 0x84, 0xd0,
	0x1b, 0xa4, 0xe0, 0xc9, 0x48, 0x8f, 0x34, 0xba, 0x31, 0x9e, 0xa7, 0xa2, 0x3f, 0xa0, 0xb1, 0x34,
	0x21, 0x53, 0x6e, 0xa3, 0x11, 0xb1, 0x06, 0xef, 0x22, 0x91, 0x5e, 0xf1, 0x8e, 0x52, 0x8b, 0x8b,
	0x0a, 0x31, 0x4c, 0xfd, 0x34, 0x13, 0x30, 0x82, 0xca, 0xbf, 0x3f, 0x46, 0x2e, 0x63, 0x37, 0xa9,
	0xab, 0x91, 0xe4, 0x98, 0x31, 0xef, 0x92, 0x62, 0xdf, 0xc5, 0x10, 0x86, 0x89, 0x1c, 0x32, 0xb8,
	0xc3, 0x7c, 0x4f, 0x43, 0xc1, 0xa2, 0xa0, 0x9f, 0x25, 0x53, 0xf8, 0x0f, 0xc9, 0xad, 0xf4, 0xb9,
	0x7b, 0x0a, 0x08, 0x06, 0x4f, 0xdf, 0x22, 0x73, 0x0d, 0x25, 0x7a, 0x2d, 0xf4, 0x6b, 0x2c, 0xb2,
	0x6f, 0x5d, 0xbe, 0x97, 0x46, 0x41, 0x96, 0x96, 0xde, 0x21, 0xb3, 0x06, 0xe4, 0xf9, 0xa9, 0x7b,
	0x7e, 0x75, 0x61, 0xa1, 0xe9, 0xd3, 0x84, 0x74, 0x8d, 0x50, 0x04, 0xc8, 0x3b, 0x14, 0xa4, 0xec,
	0xbc, 0xc9, 0x89, 0xb9, 0xd7, 0x85, 0x85, 0x1e, 0x25, 0xe8, 0x97, 0x65, 0x03, 0xc4, 0x11, 0xbc,
	0x35, 0x4f, 0x1f, 0x2e, 0xc5, 0xed, 0xf4, 0x7b, 0x06, 0x25, 0x6a, 0x91, 0x25, 0xc6, 0x79, 0xc9,
	0x41, 0xca, 0xea, 0x42, 0x0e, 0x93, 0xd6, 0xbc, 0xcc, 0x22, 0xa1, 0x9b, 0xbe, 0xdc, 0x21, 0xb3,
	0xe9, 0x30, 0xfa, 0x00, 0x3a, 0xe9, 0x02, 0x71, 0x0e, 0xe4, 0xe7, 0xca, 0x1f, 0x1f, 0x95, 0x9c,
	0xaf, 0x82, 0x73, 0x40, 0xaf, 0x90, 0xf1, 0x1d, 0x2f, 0x50, 0x67, 0x76, 0x30, 0xc0, 0xbc, 0xe4,
	0x05, 0x31, 0x20, 0xb4, 0xfc, 0x57, 0x1d, 0x32, 0x8b, 0x27, 0xc5, 0xb5, 0x96, 0xb9, 0x92, 0x72,
	0x8c, 0x0b, 0x19, 0xa7, 0x18, 0xc8, 0xa5, 0x88, 0x35, 0xbc, 0x38, 0x89, 0x0e, 0x33, 0x8a, 0x28,
	0x67, 0x1e, 0x32, 0x82, 0x9e, 0x14, 0xd0, 0xa7, 0x64, 0x79, 0x85, 0x8c, 0x3d, 0xd8, 0x5a, 0xff,
	0x10, 0xc1, 0xa5, 0x74, 0xea, 0xf9, 0x54, 0x57, 0xda, 0xf9, 0xbf, 0x73, 0xc8, 0x8c, 0xbe, 0x3a,
	0xb3, 0xe3, 0xa3, 0x77, 0x20, 0x35, 0xb4, 0x93, 0x7e, 0x8d, 0x3b, 0xa3, 0xa5, 0x3f, 0x20, 0x85,
	0xb0, 0xcd, 0x22, 0x37, 0x09, 0x55, 0xd6, 0xd6, 0x43, 0xbd, 0xde, 0x4b, 0xf8, 0xd3, 0xa3, 0xd2,
	0x17, 0x07, 0x9d, 0xaf, 0x8f, 0xda, 0xa0, 0xf9, 0x9b, 0x04, 0x7a, 0x31, 0x43, 0x7a, 0x27, 0xd0,
	0xff, 0x28, 0x67, 0x5a, 0xf2, 0x3c, 0xda, 0xf3, 0x0e, 0x99, 0x89, 0x30, 0x48, 0xb3, 0x6c, 0x2f,
	0x4c, 0xda, 0xc0, 0x02, 0x0b, 0x07, 0x29, 0x4a, 0xda, 0x26, 0x85, 0x76, 0x18, 0x7b, 0x78, 0xa8,
	0x67, 0x6c, 0x98, 0x44, 0x3c, 0xfb, 0x03, 0x58, 0x37, 0x52, 0x48, 0xde, 0xa0, 0xa5, 0x70, 0x89,
	0x01, 0x57, 0x5d, 0x5c, 0xe2, 0xf8, 0xe8, 0x25, 0x3e, 0x94, 0xbc, 0x41, 0x4b, 0x29, 0x7f, 0xdf,
	0x21, 0xb3, 0x1b, 0x5e, 0xc0, 0x96, 0x9b, 0xf2, 0xc9, 0xd1, 0x91, 0xcd, 0xb0, 0x0b, 0xc4, 0x51,
	0xcb, 0x10, 0x02, 0x7f, 0x1e, 0x1c, 0x7c, 0x41, 0xd2, 0x67, 0x0d, 0x16, 0xd4, 0xe4, 0x3a, 0x29,
	0x32, 0x41, 0x10, 0x02, 0x12, 0x53, 0xfe, 0x67, 0x63, 0xe4, 0x42, 0x8f, 0x64, 0x18, 0x5e, 0x56,
	0xec, 0x8c, 0xcb, 0xcf, 0x8d, 0x65, 0xc5, 0xfe, 0x39, 0x48, 0x0c, 0x1f, 0x13, 0x61, 0xbd, 0x8e,
	0x44, 0x39, 0x33, 0x26, 0x1e, 0x09, 0x10, 0x28, 0x1c, 0x7d, 0x97, 0x4c, 0xe1, 0xe6, 0xcf, 0x0a,
	0x5f, 0x8e, 0x06, 0x8c, 0xfc, 0x56, 0x14, 0x03, 0x30, 0xbc, 0xf8, 0x92, 0x22, 0x65, 0x6c, 0x6f,
	0x6f, 0xc8, 0x35, 0x11, 0x97, 0x94, 0x47, 0x1a, 0x0a, 0x16, 0x05, 0x5f, 0x52, 0xe4, 0x6e, 0xff,
	0xf6, 0x86, 0x0c, 0x45, 0x21, 0xf3, 0x47, 0x0a, 0x08, 0x06, 0x2f, 0x6e, 0xe2, 0xaf, 0xee, 0xd6,
	0x3d, 0xdf, 0x97, 0x4f, 0xcd, 0xc8, 0x9b, 0xf8, 0x05, 0x0c, 0x34, 0xf6, 0xa3, 0x78, 0xae, 0xb5,
	0xfc, 0x5b, 0x0e, 0x21, 0xe2, 0x60, 0xcc, 0x5f, 0x60, 0xe3, 0xf1, 0x3b, 0x0e, 0x99, 0xef, 0xf2,
	0x64, 0xb8, 0xfe, 0xf1, 0xc3, 0x7d, 0xb9, 0x37, 0x6b, 0x79, 0x52, 0x1b, 0x1c, 0x08, 0x02, 0xc7,
	0x89, 0x3a, 0xed, 0xb6, 0xcc, 0x61, 0xb5, 0x88, 0x1e, 0x73, 0x20, 0x08, 0x1c, 0x7d, 0x95, 0x4c,
	0xca, 0xf8, 0x1f, 0x56, 0x31, 0x67, 0xd9, 0xda, 0x02, 0x0c, 0x0a, 0x5f, 0xde, 0x25, 0x85, 0x2d,
	0x57, 0x5a, 0xda, 0x5f, 0x97, 0x69, 0x40, 0xce, 0x30, 0xf7, 0x29, 0x42, 0xb8, 0x9f, 0xde, 0xf0,
	0x37, 0x59, 0x44, 0xe5, 0xdb, 0x64, 0x2e, 0xe3, 0x05, 0xf0, 0xee, 0x62, 0x41, 0x43, 0x4d, 0x27,
	0xd9, 0x5d, 0xab, 0x08, 0x01, 0x89, 0xc1, 0x43, 0x4b, 0xe2, 0xe5, 0xe1, 0x8f, 0xcb, 0xa1, 0x25,
	0x51, 0xdb, 0xd3, 0x3e, 0xb4, 0x24, 0xa5, 0x3c, 0x3b, 0xdd, 0xe1, 0x7f, 0x38, 0x64, 0x4e, 0x10,
	0xae, 0x07, 0xf2, 0x7d, 0xe5, 0x41, 0x66, 0x45, 0x68, 0x25, 0x5f, 0x8e, 0xf4, 0x3d, 0xfc, 0x99,
	0x3e, 0x89, 0x97, 0xb7, 0xc8, 0x44, 0x5d, 0xa4, 0x4f, 0x8e, 0x69, 0xe3, 0x65, 0x42, 0x38, 0xe8,
	0x5d, 0xce, 0xb7, 0xa4, 0xc4, 0x03, 0x5a, 0xa2, 0xad, 0x1f, 0x9b, 0x03, 0x5a, 0xa2, 0xba, 0x7d,
	0xd2, 0x38, 0xfe, 0x97, 0x43, 0xce, 0x0b, 0x02, 0xf3, 0x38, 0x36, 0x7d, 0x93, 0xcc, 0x56, 0x31,
	0x1f, 0x4b, 0x7e, 0x2b, 0xb9, 0x0e, 0xcd, 0x1f, 0x1f, 0x95, 0x66, 0x97, 0x6d, 0x04, 0xa4, 0xe9,
	0xb2, 0x5f, 0x3d, 0xf7, 0x9c, 0x5f, 0x7d, 0xec, 0x0c, 0xbe, 0x7a, 0xb9, 0x4d, 0xce, 0xa5, 0xdf,
	0x1e, 0xe7, 0x6b, 0x99, 0x78, 0x6c, 0xdc, 0x1a, 0xaa, 0xe7, 0xc4, 0x3d, 0x79, 0x0a, 0x0a, 0x16,
	0x05, 0xa7, 0xaf, 0xb1, 0x36, 0x0b, 0x6a, 0x2c, 0x48, 0x62, 0xe9, 0xa9, 0x22, 0xfd, 0x8a, 0x86,
	0x82, 0x45, 0x51, 0xfe, 0x37, 0x39, 0x32, 0x25, 0x58, 0x41, 0xe7, 0x2c, 0x9e, 0x5f, 0x62, 0x29,
	0xfd, 0xb2, 0x3c, 0xcc, 0xa8, 0x51, 0x77, 0xff, 0xf4, 0x52, 0x31, 0xad, 0x8c, 0x8a, 0x59, 0x1d,
	0x56, 0xd0, 0xb3, 0xb5, 0xcc, 0x8f, 0x1c, 0x32, 0xab, 0x69, 0xcf, 0x60, 0xf2, 0xd5, 0xd2, 0x93,
	0xef, 0x2b, 0x43, 0xb6, 0xae, 0xcf, 0xfc, 0xfb, 0xc1, 0xb8, 0xd5, 0x2a, 0xa5, 0x39, 0xed, 0xf4,
	0x28, 0x4b, 0x73, 0xf6, 0x4d, 0x8d, 0x4a, 0x0f, 0xe0, 0xdc, 0x87, 0x0e, 0xe0, 0x07, 0x3a, 0x97,
	0xf9, 0x39, 0x9e, 0xf5, 0xd5, 0xdf, 0x25, 0x73, 0x4b, 0x88, 0x9d, 0x33, 0x3f, 0x7e, 0x56, 0x39,
	0xf3, 0xa9, 0x2c, 0xf0, 0xfc, 0xd9, 0x65, 0x81, 0xcb, 0x47, 0xdf, 0x27, 0xba, 0x1f, 0x7d, 0xef,
	0x71, 0x51, 0xc9, 0xe4, 0x89, 0x2f, 0x2a, 0xe9, 0x79, 0xe1, 0x6d, 0xe1, 0x39, 0x2f, 0xbc, 0xfd,
	0xc3, 0x09, 0xb5, 0x0c, 0xeb, 0xc9, 0x94, 0xbd, 0x1d, 0xcf, 0x19, 0xf1, 0xed, 0x78, 0xb7, 0xd3,
	0x49, 0xeb, 0xa5, 0x6c, 0x7a, 0xc6, 0x39, 0x5d, 0x9f, 0x53, 0xcb, 0x58, 0xef, 0xca, 0xf3, 0x1d,
	0xff, 0xa8, 0xf3, 0x7c, 0xf3, 0x27, 0xce, 0xf3, 0xfd, 0x65, 0x32, 0x9d, 0x44, 0x5e, 0xa3, 0xc1,
	0x22, 0x56, 0x5b, 0x3a, 0x94, 0x51, 0x27, 0x75, 0xc1, 0xed, 0xf4, 0xb6, 0x41, 0x0d, 0x53, 0x77,
	0xc9, 0x46, 0x3c, 0xc4, 0x63, 0x89, 0xd3, 0xc9, 0x3b, 0x93, 0xa7, 0x95, 0xbc, 0x93, 0x4a, 0x3b,
	0x9a, 0x3a, 0xb5, 0x13, 0xca, 0xd3, 0xa7, 0x93, 0x37, 0xf2, 0x9d, 0x49, 0x65, 0xe9, 0x9d, 0x2c,
	0xad, 0xf5, 0xf5, 0x5e, 0x69, 0xad, 0x73, 0xa3, 0x4e, 0x69, 0xfd, 0x80, 0xe4, 0x3d, 0x6e, 0x64,
	0x0f, 0xb7, 0x51, 0x92, 0xb1, 0xd6, 0xed, 0x2d, 0xb5, 0x76, 0x27, 0x01, 0x21, 0x82, 0x32, 0x92,
	0x8f, 0x13, 0xd6, 0x56, 0x37, 0x9b, 0x0c, 0xe7, 0xa8, 0x24, 0xcc, 0x3a, 0x9a, 0xc9, 0xff, 0xc5,
	0x20, 0xb8, 0xd3, 0x80, 0x4c, 0x84, 0x68, 0x7b, 0xca, 0xdc, 0xdb, 0xb5, 0x61, 0xe4, 0x18, 0x2b,
	0xd6, 0xba, 0x6c, 0x0e, 0x61, 0x20, 0xa5, 0x58, 0xef, 0x2f, 0x4d, 0x9e, 0xf2, 0xfb, 0x4b, 0xa9,
	0x55, 0xaa, 0x70, 0x76, 0xab, 0x94, 0x75, 0x51, 0x3b, 0x79, 0xc6, 0x45, 0xed, 0x72, 0x31, 0x9b,
	0xee, 0xb1, 0x98, 0xf5, 0x7e, 0xf4, 0x67, 0xe6, 0xa3, 0x79, 0xf4, 0xa7, 0xfc, 0xdd, 0x31, 0x32,
	0x63, 0x7b, 0xa2, 0x23, 0x4d, 0xc7, 0x7c, 0x42, 0x26, 0x7d, 0x37, 0x4e, 0xa0, 0x13, 0x3c, 0xef,
	0xa1, 0xee, 0x6e, 0x4d, 0x28, 0xf8, 0x64, 0x6f, 0x28, 0x95, 0x60, 0x50, 0x72, 0x4e, 0xef, 0x94,
	0x55, 0x5a, 0x31, 0x4e, 0x9e, 0x8e, 0x62, 0xfc, 0xe7, 0xda, 0x05, 0xe6, 0xd3, 0x98, 0xbe, 0x4e,
	0x72, 0x61, 0x5b, 0x6a, 0x45, 0x95, 0xad, 0x92, 0x7b, 0xd4, 0x7e, 0x7a, 0x54, 0xba, 0x60, 0xa8,
	0x44, 0x24, 0x9d, 0x7f, 0x82, 0x5c, 0xd8, 0xa6, 0x1d, 0x42, 0xda, 0x6e, 0xe4, 0xb6, 0x58, 0xc2,
	0xa2, 0x21, 0x93, 0x60, 0x8d, 0x88, 0x2d, 0xce, 0x51, 0x98, 0xbd, 0x5b, 0x9a, 0x39, 0x58, 0x82,
	0xca, 0x5f, 0x55, 0xf6, 0x91, 0x26, 0x3f, 0x41, 0x1a, 0x60, 0xea, 0xce, 0x9b, 0x7e, 0x21, 0xfb,
	0xdf, 0x75, 0xc8, 0x45, 0x60, 0xd5, 0xb0, 0xd5, 0x62, 0x41, 0x4d, 0x04, 0x72, 0xc5, 0xc9, 0xd5,
	0x37, 0xc8, 0x4c, 0x27, 0x66, 0xd1, 0xfa, 0xca, 0xb2, 0xbd, 0x15, 0x81, 0xe9, 0xd9, 0x8f, 0x2d,
	0x38, 0xa4, 0xa8, 0x78, 0x29, 0xee, 0x1d, 0xe8, 0x52, 0x39, 0x53, 0x6a, 0xdd, 0x82, 0x43, 0x8a,
	0x8a, 0x97, 0xe2, 0x7d, 0x1c, 0x34, 0xac, 0x3b, 0x18, 0x64, 0x29, 0xb0, 0xe0, 0x90, 0xa2, 0x2a,
	0xff, 0x19, 0x06, 0x00, 0xd2, 0x0f, 0xa1, 0xf1, 0x6e, 0x49, 0x4c, 0x5a, 0x42, 0xa6, 0x5b, 0x30,
	0x57, 0xf1, 0x95, 0x4c, 0x08, 0xb3, 0xdf, 0xee, 0x8a, 0x4f, 0xf2, 0x2e, 0x3e, 0xd8, 0x3f, 0xa6,
	0x5f, 0x18, 0xcc, 0x2f, 0xca, 0x67, 0xfa, 0x87, 0xc8, 0xe4, 0x36, 0xf5, 0x45, 0x66, 0x20, 0x84,
	0xd0, 0x9b, 0x5c, 0xe1, 0x72, 0x95, 0x11, 0x6f, 0x87, 0xd2, 0x10, 0xb4, 0x34, 0xa5, 0x44, 0x80,
	0xa1, 0x29, 0xb7, 0xc8, 0xa4, 0x8c, 0x26, 0xd2, 0x1d, 0xfd, 0x76, 0xd7, 0x10, 0x8b, 0x9d, 0x68,
	0x7d, 0xda, 0x65, 0x36, 0xaf, 0x7f, 0x95, 0xff, 0xc4, 0x21, 0xc4, 0xac, 0x1b, 0xb4, 0x29, 0xbb,
	0x39, 0x9d, 0x5e, 0xaa, 0xae, 0x73, 0x5d, 0x19, 0xd8, 0x5a, 0xe5, 0x12, 0xbc, 0xa0, 0x61, 0xdd,
	0xe7, 0x7a, 0x25, 0x75, 0x73, 0x5f, 0x21, 0x73, 0xf4, 0xf2, 0xba, 0x09, 0xe6, 0x5a, 0xf7, 0x71,
	0x64, 0x03, 0xb9, 0xb4, 0x4c, 0x26, 0xea, 0xe2, 0xb4, 0x40, 0xde, 0x04, 0x52, 0x45, 0x1a, 0x3f,
	0x48, 0x4c, 0x39, 0x20, 0x73, 0x95, 0xaa, 0x9b, 0x24, 0x2c, 0xda, 0xf2, 0xc3, 0xd3, 0xdf, 0x67,
	0x29, 0xff, 0xde, 0x18, 0x91, 0xa7, 0xc5, 0xe9, 0xf7, 0x1c, 0x71, 0x30, 0xba, 0xc2, 0x22, 0x8f,
	0xc5, 0x02, 0x28, 0x3d, 0x9e, 0x01, 0x4d, 0x8a, 0xed, 0x0c, 0x37, 0xf3, 0x60, 0x7b, 0x16, 0x03,
	0x5d, 0x92, 0xe9, 0xdf, 0x77, 0xc8, 0xc5, 0xa8, 0x87, 0x4e, 0x18, 0xee, 0xe4, 0x5b, 0x2f, 0x2d,
	0xb3, 0x74, 0x45, 0x56, 0xab, 0xa7, 0x0e, 0x82, 0x9e, 0xb5, 0xa0, 0x0d, 0x73, 0x0a, 0x61, 0x6c,
	0x98, 0xe8, 0xa2, 0x18, 0xf1, 0xcf, 0x38, 0x7c, 0x20, 0xef, 0xf6, 0x1c, 0xef, 0xbe, 0xdb, 0xb3,
	0xbc, 0x4d, 0x66, 0x53, 0xd7, 0xa9, 0x9e, 0x74, 0xa7, 0x53, 0x8d, 0xe6, 0x5c, 0xaf, 0xd1, 0x5c,
	0xfe, 0xad, 0x1c, 0x99, 0xc2, 0x33, 0xa5, 0x83, 0x8e, 0xbe, 0xeb, 0xe9, 0x03, 0x1a, 0xfd, 0x8e,
	0x8d, 0x5d, 0x27, 0x93, 0x62, 0xd0, 0x8b, 0x1e, 0x94, 0x64, 0x62, 0x3e, 0xc4, 0xa0, 0x70, 0x3a,
	0xa9, 0x65, 0x47, 0xf5, 0x41, 0x8f, 0xa4, 0x96, 0x9d, 0x43, 0xdd, 0xa6, 0x7c, 0xcf, 0x19, 0x8a,
	0x17, 0x1a, 0x85, 0xfb, 0xe2, 0x8a, 0xa2, 0x09, 0xec, 0x1a, 0x79, 0xa1, 0x91, 0x04, 0x82, 0xc1,
	0x63, 0x22, 0x4f, 0x18, 0xd5, 0x58, 0x24, 0xcf, 0x9e, 0x89, 0x44, 0x1e, 0x84, 0x80, 0xc4, 0x94,
	0xbf, 0x9d, 0x23, 0x5d, 0x83, 0x98, 0xd6, 0x53, 0x6a, 0x1f, 0x2c, 0x5d, 0xb4, 0x36, 0xb0, 0xf7,
	0xa9, 0x65, 0x58, 0xda, 0xc8, 0x25, 0xe3, 0xf5, 0x88, 0x3d, 0x91, 0x33, 0x7c, 0x13, 0x6f, 0x16,
	0x8e, 0xd8, 0x93, 0xd1, 0xa4, 0xed, 0x20, 0xeb, 0x54, 0xc6, 0xce, 0xd8, 0xb3, 0x32, 0x76, 0x96,
	0xde, 0xfb, 0xc1, 0x4f, 0xae, 0x7e, 0xe2, 0x87, 0x3f, 0xb9, 0xfa, 0x89, 0x1f, 0xff, 0xe4, 0xea,
	0x27, 0xbe, 0x75, 0x7c, 0xd5, 0xf9, 0xc1, 0xf1, 0x55, 0xe7, 0x87, 0xc7, 0x57, 0x9d, 0x1f, 0x1f,
	0x5f, 0x75, 0xfe, 0xf4, 0xf8, 0xaa, 0xf3, 0xfd, 0xff, 0x76, 0xf5, 0x13, 0xef, 0xbd, 0x71, 0xc2,
	0x8a, 0xf1, 0x71, 0xa4, 0x6b, 0xf5, 0xe7, 0x01, 0x00, 0x00, 0xff, 0xff, 0xb5, 0x68, 0x65, 0xea,
	0x58, 0xbc, 0x00, 0x00,
}

func (m *ApprovalReviewStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalReviewStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalReviewStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Notes)
	copy(dAtA[i:], m.Notes)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Notes)))
	i--
	dAtA[i] = 0x22
	if m.ApprovedAt != nil {
		{
			size, err := m.ApprovedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.Result)
	copy(dAtA[i:], m.Result)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Result)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Reviewer)
	copy(dAtA[i:], m.Reviewer)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reviewer)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ApprovalSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reviewers) > 0 {
		for iNdEx := len(m.Reviewers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Reviewers[iNdEx])
			copy(dAtA[i:], m.Reviewers[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reviewers[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.DecisionType != nil {
		i -= len(*m.DecisionType)
		copy(dAtA[i:], *m.DecisionType)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DecisionType)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ApprovalStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reviews) > 0 {
		for iNdEx := len(m.Reviews) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reviews[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BarChartSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BarChartSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BarChartSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sort != nil {
		i--
		if *m.Sort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Legend != nil {
		i--
		if *m.Legend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Y != nil {
		i -= len(*m.Y)
		copy(dAtA[i:], *m.Y)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Y)))
		i--
		dAtA[i] = 0x1a
	}
	if m.X != nil {
		i -= len(*m.X)
		copy(dAtA[i:], *m.X)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.X)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Window != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Window))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.Aggr != nil {
		i -= len(*m.Aggr)
		copy(dAtA[i:], *m.Aggr)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Aggr)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	if m.TimeIndex != nil {
		i--
		if *m.TimeIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.LaggedRegressor != nil {
		i--
		if *m.LaggedRegressor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.Regressor != nil {
		i--
		if *m.Regressor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.TimeSeries != nil {
		i--
		if *m.TimeSeries {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.DateTimeFormat != nil {
		i -= len(*m.DateTimeFormat)
		copy(dAtA[i:], *m.DateTimeFormat)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DateTimeFormat)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.Loc))
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0x80
	if m.Step != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Step))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf9
	}
	if m.ID != nil {
		i--
		if *m.ID {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.Formula != nil {
		i -= len(*m.Formula)
		copy(dAtA[i:], *m.Formula)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Formula)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.Generated != nil {
		i--
		if *m.Generated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.Scaling != nil {
		i -= len(*m.Scaling)
		copy(dAtA[i:], *m.Scaling)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Scaling)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if m.Imputation != nil {
		i -= len(*m.Imputation)
		copy(dAtA[i:], *m.Imputation)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Imputation)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if m.Reserved != nil {
		i--
		if *m.Reserved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.Weight != nil {
		i--
		if *m.Weight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.Fold != nil {
		i--
		if *m.Fold {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.Key != nil {
		i--
		if *m.Key {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.DriftThreshold != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DriftThreshold))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa9
	}
	if m.SkewThreshold != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.SkewThreshold))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa1
	}
	if m.Sigma != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Sigma))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x99
	}
	if m.Mu != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Mu))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x91
	}
	if m.Log != nil {
		i--
		if *m.Log {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.DefaultValueNum != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DefaultValueNum))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x81
	}
	if m.Protected != nil {
		i--
		if *m.Protected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.PHI != nil {
		i--
		if *m.PHI {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.PII != nil {
		i--
		if *m.PII {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.UniqueItems != nil {
		i--
		if *m.UniqueItems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.MinItems != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MinItems))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.MaxItems != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxItems))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if len(m.Enum) > 0 {
		for iNdEx := len(m.Enum) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Enum[iNdEx])
			copy(dAtA[i:], m.Enum[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Enum[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.ExternalDocs != nil {
		i -= len(*m.ExternalDocs)
		copy(dAtA[i:], *m.ExternalDocs)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ExternalDocs)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Example != nil {
		i -= len(*m.Example)
		copy(dAtA[i:], *m.Example)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Example)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Required != nil {
		i--
		if *m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Pattern != nil {
		i -= len(*m.Pattern)
		copy(dAtA[i:], *m.Pattern)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Pattern)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.MinLength != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MinLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.MaxLength != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ExclusiveMinimum != nil {
		i--
		if *m.ExclusiveMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.Minimum != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Minimum))))
		i--
		dAtA[i] = 0x71
	}
	if m.ExclusiveMaximum != nil {
		i--
		if *m.ExclusiveMaximum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Maximum != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Maximum))))
		i--
		dAtA[i] = 0x61
	}
	if m.MultipleOf != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MultipleOf))
		i--
		dAtA[i] = 0x58
	}
	if m.FK != nil {
		i--
		if *m.FK {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.PK != nil {
		i--
		if *m.PK {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Nullable != nil {
		i--
		if *m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Target != nil {
		i--
		if *m.Target {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Ignore != nil {
		i--
		if *m.Ignore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Format != nil {
		i -= len(*m.Format)
		copy(dAtA[i:], *m.Format)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Format)))
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.DataType)
	copy(dAtA[i:], m.DataType)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DataType)))
	i--
	dAtA[i] = 0x1a
	if m.DisplayName != nil {
		i -= len(*m.DisplayName)
		copy(dAtA[i:], *m.DisplayName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DisplayName)))
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ColumnHistogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnHistogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnHistogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Drift != nil {
		i--
		if *m.Drift {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Histogram.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ColumnSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Content.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Width != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Width))
		i--
		dAtA[i] = 0x10
	}
	if m.Spacer != nil {
		i--
		if *m.Spacer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComponentSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ComponentView.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Footer != nil {
		i -= len(*m.Footer)
		copy(dAtA[i:], *m.Footer)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Footer)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SubTitle != nil {
		i -= len(*m.SubTitle)
		copy(dAtA[i:], *m.SubTitle)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SubTitle)))
		i--
		dAtA[i] = 0x12
	}
	if m.Title != nil {
		i -= len(*m.Title)
		copy(dAtA[i:], *m.Title)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComponentView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComponentView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComponentView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ScatterChart != nil {
		{
			size, err := m.ScatterChart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BarChart != nil {
		{
			size, err := m.BarChart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.LineChart != nil {
		{
			size, err := m.LineChart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Table != nil {
		{
			size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Histogram != nil {
		{
			size, err := m.Histogram.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Gauge != nil {
		{
			size, err := m.Gauge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Metric != nil {
		{
			size, err := m.Metric.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Correlation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Correlation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Correlation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Method)
	copy(dAtA[i:], m.Method)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Method)))
	i--
	dAtA[i] = 0x22
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
	i--
	dAtA[i] = 0x19
	i -= len(m.Y)
	copy(dAtA[i:], m.Y)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Y)))
	i--
	dAtA[i] = 0x12
	i -= len(m.X)
	copy(dAtA[i:], m.X)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.X)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CorrelationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorrelationSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CorrelationSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Top != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Top))
		i--
		dAtA[i] = 0x18
	}
	if m.Method != nil {
		i -= len(*m.Method)
		copy(dAtA[i:], *m.Method)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Method)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cutoff != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Cutoff))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *CsvFileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CsvFileSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CsvFileSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HasIndexColumn != nil {
		i--
		if *m.HasIndexColumn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Compression != nil {
		i -= len(*m.Compression)
		copy(dAtA[i:], *m.Compression)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Compression)))
		i--
		dAtA[i] = 0x62
	}
	if m.Strict != nil {
		i--
		if *m.Strict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.MaxRows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxRows))
		i--
		dAtA[i] = 0x50
	}
	if m.Encoding != nil {
		i -= len(*m.Encoding)
		copy(dAtA[i:], *m.Encoding)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Encoding)))
		i--
		dAtA[i] = 0x4a
	}
	if m.NullValues != nil {
		i -= len(*m.NullValues)
		copy(dAtA[i:], *m.NullValues)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.NullValues)))
		i--
		dAtA[i] = 0x42
	}
	if m.SkipRows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.SkipRows))
		i--
		dAtA[i] = 0x38
	}
	if m.Header != nil {
		i--
		if *m.Header {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.CommentChars != nil {
		i -= len(*m.CommentChars)
		copy(dAtA[i:], *m.CommentChars)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.CommentChars)))
		i--
		dAtA[i] = 0x2a
	}
	i -= len(m.EscapeChar)
	copy(dAtA[i:], m.EscapeChar)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.EscapeChar)))
	i--
	dAtA[i] = 0x22
	i -= len(m.QuoteChar)
	copy(dAtA[i:], m.QuoteChar)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.QuoteChar)))
	i--
	dAtA[i] = 0x1a
	if m.Delimiter != nil {
		i -= len(*m.Delimiter)
		copy(dAtA[i:], *m.Delimiter)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Delimiter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataInputSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataInputSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataInputSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Format.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DataOutputSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataOutputSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataOutputSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DetectOutliers != nil {
		i--
		if *m.DetectOutliers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.IncludeShapValues != nil {
		i--
		if *m.IncludeShapValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.IncludeFeatures != nil {
		i--
		if *m.IncludeFeatures {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.CreateTableIfNotExist != nil {
		i--
		if *m.CreateTableIfNotExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Action != nil {
		i -= len(*m.Action)
		copy(dAtA[i:], *m.Action)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Action)))
		i--
		dAtA[i] = 0x22
	}
	if m.Format != nil {
		i -= len(*m.Format)
		copy(dAtA[i:], *m.Format)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Format)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataPipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataPipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataPipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataPipelineList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataPipelineList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataPipelineList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataPipelineRun) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataPipelineRun) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataPipelineRun) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataPipelineRunCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataPipelineRunCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataPipelineRunCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x2a
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataPipelineRunList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataPipelineRunList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataPipelineRunList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataPipelineRunSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataPipelineRunSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataPipelineRunSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModelClassRunName != nil {
		i -= len(*m.ModelClassRunName)
		copy(dAtA[i:], *m.ModelClassRunName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ModelClassRunName)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ModelClassName != nil {
		i -= len(*m.ModelClassName)
		copy(dAtA[i:], *m.ModelClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ModelClassName)))
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.LabRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.Aborted != nil {
		i--
		if *m.Aborted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Paused != nil {
		i--
		if *m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Priority != nil {
		i -= len(*m.Priority)
		copy(dAtA[i:], *m.Priority)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Priority)))
		i--
		dAtA[i] = 0x32
	}
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if m.DataPipelineName != nil {
		i -= len(*m.DataPipelineName)
		copy(dAtA[i:], *m.DataPipelineName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DataPipelineName)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataPipelineRunStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataPipelineRunStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataPipelineRunStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	{
		size, err := m.Logs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.Progress != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Progress))
		i--
		dAtA[i] = 0x48
	}
	if m.FailureMessage != nil {
		i -= len(*m.FailureMessage)
		copy(dAtA[i:], *m.FailureMessage)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureMessage)))
		i--
		dAtA[i] = 0x42
	}
	if m.FailureReason != nil {
		i -= len(*m.FailureReason)
		copy(dAtA[i:], *m.FailureReason)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureReason)))
		i--
		dAtA[i] = 0x3a
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x30
	if m.CompletedAt != nil {
		{
			size, err := m.CompletedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.RecipeRuns) > 0 {
		for iNdEx := len(m.RecipeRuns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RecipeRuns[iNdEx])
			copy(dAtA[i:], m.RecipeRuns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.RecipeRuns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TTL))
		i--
		dAtA[i] = 0x68
	}
	if m.Paused != nil {
		i--
		if *m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Priority != nil {
		i -= len(*m.Priority)
		copy(dAtA[i:], *m.Priority)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Priority)))
		i--
		dAtA[i] = 0x5a
	}
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x4a
	}
	{
		size, err := m.Notification.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Recipes) > 0 {
		for iNdEx := len(m.Recipes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Recipes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.DatasetSelector) > 0 {
		keysForDatasetSelector := make([]string, 0, len(m.DatasetSelector))
		for k := range m.DatasetSelector {
			keysForDatasetSelector = append(keysForDatasetSelector, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForDatasetSelector)
		for iNdEx := len(keysForDatasetSelector) - 1; iNdEx >= 0; iNdEx-- {
			v := m.DatasetSelector[string(keysForDatasetSelector[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForDatasetSelector[iNdEx])
			copy(dAtA[i:], keysForDatasetSelector[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForDatasetSelector[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ModelClassName != nil {
		i -= len(*m.ModelClassName)
		copy(dAtA[i:], *m.ModelClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ModelClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataPipelineStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataPipelineStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataPipelineStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.RunsCount))
	i--
	dAtA[i] = 0x28
	i -= len(m.LastRunName)
	copy(dAtA[i:], m.LastRunName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LastRunName)))
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DataProduct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProduct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProduct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataProductList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProductList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProductList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataProductSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProductSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProductSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	{
		size, err := m.Permissions.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	if m.Approval != nil {
		{
			size, err := m.Approval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Color != nil {
		i -= len(*m.Color)
		copy(dAtA[i:], *m.Color)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Color)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.DefaultPriority != nil {
		i -= len(*m.DefaultPriority)
		copy(dAtA[i:], *m.DefaultPriority)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DefaultPriority)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	{
		size, err := m.DefaultServingResources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size, err := m.DefaultTrainingResources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	if m.Notification != nil {
		{
			size, err := m.Notification.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x62
	}
	if m.SubTask != nil {
		i -= len(*m.SubTask)
		copy(dAtA[i:], *m.SubTask)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SubTask)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Task != nil {
		i -= len(*m.Task)
		copy(dAtA[i:], *m.Task)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Task)))
		i--
		dAtA[i] = 0x52
	}
	if m.DefaultBucketName != nil {
		i -= len(*m.DefaultBucketName)
		copy(dAtA[i:], *m.DefaultBucketName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DefaultBucketName)))
		i--
		dAtA[i] = 0x4a
	}
	if m.DefaultServingSiteName != nil {
		i -= len(*m.DefaultServingSiteName)
		copy(dAtA[i:], *m.DefaultServingSiteName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DefaultServingSiteName)))
		i--
		dAtA[i] = 0x42
	}
	if m.DefaultLabName != nil {
		i -= len(*m.DefaultLabName)
		copy(dAtA[i:], *m.DefaultLabName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DefaultLabName)))
		i--
		dAtA[i] = 0x3a
	}
	i -= len(m.CacheBucketName)
	copy(dAtA[i:], m.CacheBucketName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.CacheBucketName)))
	i--
	dAtA[i] = 0x32
	{
		size, err := m.GitLocation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.TenantRef != nil {
		{
			size, err := m.TenantRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Public != nil {
		i--
		if *m.Public {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataProductStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProductStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProductStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.BaselineVersion != nil {
		i -= len(*m.BaselineVersion)
		copy(dAtA[i:], *m.BaselineVersion)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.BaselineVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.FailureMessage != nil {
		i -= len(*m.FailureMessage)
		copy(dAtA[i:], *m.FailureMessage)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureMessage)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.FailureReason != nil {
		i -= len(*m.FailureReason)
		copy(dAtA[i:], *m.FailureReason)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureReason)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ModelClassesCount))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	i = encodeVarintGenerated(dAtA, i, uint64(m.ErrorsAlertsCount))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i = encodeVarintGenerated(dAtA, i, uint64(m.InfoAlertsCount))
	i--
	dAtA[i] = 0x78
	i = encodeVarintGenerated(dAtA, i, uint64(m.PredictionsCount))
	i--
	dAtA[i] = 0x70
	i = encodeVarintGenerated(dAtA, i, uint64(m.DataAppsCount))
	i--
	dAtA[i] = 0x68
	i = encodeVarintGenerated(dAtA, i, uint64(m.PredictorsCount))
	i--
	dAtA[i] = 0x58
	i = encodeVarintGenerated(dAtA, i, uint64(m.ModelsCount))
	i--
	dAtA[i] = 0x40
	i = encodeVarintGenerated(dAtA, i, uint64(m.StudiesCount))
	i--
	dAtA[i] = 0x38
	i = encodeVarintGenerated(dAtA, i, uint64(m.DataPipelineRunsCount))
	i--
	dAtA[i] = 0x30
	i = encodeVarintGenerated(dAtA, i, uint64(m.DataPipelinesCount))
	i--
	dAtA[i] = 0x28
	i = encodeVarintGenerated(dAtA, i, uint64(m.DatasetsCount))
	i--
	dAtA[i] = 0x20
	i = encodeVarintGenerated(dAtA, i, uint64(m.DatasourcesCount))
	i--
	dAtA[i] = 0x18
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DataProductVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProductVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProductVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataProductVersionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProductVersionList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProductVersionList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataProductVersionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProductVersionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProductVersionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Baseline != nil {
		i--
		if *m.Baseline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PrevVersionName != nil {
		i -= len(*m.PrevVersionName)
		copy(dAtA[i:], *m.PrevVersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.PrevVersionName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.ProductRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataProductVersionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProductVersionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProductVersionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.FailureMessage != nil {
		i -= len(*m.FailureMessage)
		copy(dAtA[i:], *m.FailureMessage)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureMessage)))
		i--
		dAtA[i] = 0x22
	}
	if m.FailureReason != nil {
		i -= len(*m.FailureReason)
		copy(dAtA[i:], *m.FailureReason)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureReason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DataSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataSourceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSourceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSourceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataSourceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSourceSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSourceSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IngestMethod != nil {
		i -= len(*m.IngestMethod)
		copy(dAtA[i:], *m.IngestMethod)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.IngestMethod)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	{
		size, err := m.UnitTestsTemplate.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	if m.InferredFrom != nil {
		{
			size, err := m.InferredFrom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	{
		size, err := m.Labeling.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if len(m.Relationships) > 0 {
		for iNdEx := len(m.Relationships) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Relationships[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.SubTask != nil {
		i -= len(*m.SubTask)
		copy(dAtA[i:], *m.SubTask)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SubTask)))
		i--
		dAtA[i] = 0x5a
	}
	i -= len(m.Task)
	copy(dAtA[i:], m.Task)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Task)))
	i--
	dAtA[i] = 0x52
	{
		size, err := m.Sample.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.Labeled != nil {
		i--
		if *m.Labeled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.FlatFile != nil {
		{
			size, err := m.FlatFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	{
		size, err := m.Schema.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.DatasetType != nil {
		i -= len(*m.DatasetType)
		copy(dAtA[i:], *m.DatasetType)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetType)))
		i--
		dAtA[i] = 0x22
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.VersionName)
	copy(dAtA[i:], m.VersionName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.VersionName)))
	i--
	dAtA[i] = 0x12
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataSourceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSourceStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSourceStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.FailureMessage != nil {
		i -= len(*m.FailureMessage)
		copy(dAtA[i:], *m.FailureMessage)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureMessage)))
		i--
		dAtA[i] = 0x3a
	}
	if m.FailureReason != nil {
		i -= len(*m.FailureReason)
		copy(dAtA[i:], *m.FailureReason)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureReason)))
		i--
		dAtA[i] = 0x32
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	i -= len(m.LastDatasetName)
	copy(dAtA[i:], m.LastDatasetName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.LastDatasetName)))
	i--
	dAtA[i] = 0x22
	if m.LastDatasetCreatedAt != nil {
		{
			size, err := m.LastDatasetCreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x10
	i = encodeVarintGenerated(dAtA, i, uint64(m.Cols))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Dataset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dataset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dataset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DatasetGroupByStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetGroupByStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatasetGroupByStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WorkerResults) > 0 {
		for iNdEx := len(m.WorkerResults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WorkerResults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i -= len(m.UnitTestsURI)
	copy(dAtA[i:], m.UnitTestsURI)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.UnitTestsURI)))
	i--
	dAtA[i] = 0x22
	i -= len(m.ReportsURI)
	copy(dAtA[i:], m.ReportsURI)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ReportsURI)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.ProfilesURI)
	copy(dAtA[i:], m.ProfilesURI)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ProfilesURI)))
	i--
	dAtA[i] = 0x12
	i -= len(m.DatasetsURI)
	copy(dAtA[i:], m.DatasetsURI)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DatasetsURI)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DatasetList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatasetList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DatasetSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatasetSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DatasetSnapshotList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetSnapshotList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatasetSnapshotList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DatasetSnapshotSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetSnapshotSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatasetSnapshotSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModelClassRunName != nil {
		i -= len(*m.ModelClassRunName)
		copy(dAtA[i:], *m.ModelClassRunName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ModelClassRunName)))
		i--
		dAtA[i] = 0x32
	}
	if m.Abort != nil {
		i--
		if *m.Abort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Pause != nil {
		i--
		if *m.Pause {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Timeout != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Timeout))
		i--
		dAtA[i] = 0x18
	}
	i -= len(m.DatasetName)
	copy(dAtA[i:], m.DatasetName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DatasetName)))
	i--
	dAtA[i] = 0x12
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatasetSnapshotStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetSnapshotStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatasetSnapshotStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	{
		size, err := m.GroupBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc2
	{
		size, err := m.FeatureHistogramRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	{
		size, err := m.Images.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	if m.LastStudyAt != nil {
		{
			size, err := m.LastStudyAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.CompletedAt != nil {
		{
			size, err := m.CompletedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	i -= len(m.Hash)
	copy(dAtA[i:], m.Hash)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Hash)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	{
		size, err := m.Logs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	i = encodeVarintGenerated(dAtA, i, uint64(m.Progress))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	if m.FailureMessage != nil {
		i -= len(*m.FailureMessage)
		copy(dAtA[i:], *m.FailureMessage)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureMessage)))
		i--
		dAtA[i] = 0x7a
	}
	{
		size, err := m.UnitTestResults.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	i--
	if m.Imbalanced {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x68
	{
		size, err := m.SampleLocation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.AnomaliesLocation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.ProfileLocation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.ReportLocation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.DataLocation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	i -= len(m.ReportName)
	copy(dAtA[i:], m.ReportName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ReportName)))
	i--
	dAtA[i] = 0x3a
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Statistics.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	i = encodeVarintGenerated(dAtA, i, uint64(m.SnapshotVersion))
	i--
	dAtA[i] = 0x20
	{
		size, err := m.DataSourceManifestLocation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.DatasetManifestLocation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DatasetSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatasetSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Notification != nil {
		{
			size, err := m.Notification.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.FeatureGroupName != nil {
		i -= len(*m.FeatureGroupName)
		copy(dAtA[i:], *m.FeatureGroupName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FeatureGroupName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.ModelClassName != nil {
		i -= len(*m.ModelClassName)
		copy(dAtA[i:], *m.ModelClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ModelClassName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.Key) > 0 {
		for iNdEx := len(m.Key) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Key[iNdEx])
			copy(dAtA[i:], m.Key[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Key[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.GroupBy != nil {
		{
			size, err := m.GroupBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.LabRef != nil {
		{
			size, err := m.LabRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Correlation != nil {
		{
			size, err := m.Correlation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Synthetic != nil {
		{
			size, err := m.Synthetic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Sample != nil {
		{
			size, err := m.Sample.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.ArtifactBucketName != nil {
		i -= len(*m.ArtifactBucketName)
		copy(dAtA[i:], *m.ArtifactBucketName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ArtifactBucketName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Fast != nil {
		i--
		if *m.Fast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.GenerateFeatureHistogram != nil {
		i--
		if *m.GenerateFeatureHistogram {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.UnitTest != nil {
		i--
		if *m.UnitTest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.Report != nil {
		i--
		if *m.Report {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	{
		size, err := m.UnitTests.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.Origin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.Type != nil {
		i -= len(*m.Type)
		copy(dAtA[i:], *m.Type)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Type)))
		i--
		dAtA[i] = 0x4a
	}
	if m.SubTask != nil {
		i -= len(*m.SubTask)
		copy(dAtA[i:], *m.SubTask)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SubTask)))
		i--
		dAtA[i] = 0x42
	}
	i -= len(m.Task)
	copy(dAtA[i:], m.Task)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Task)))
	i--
	dAtA[i] = 0x3a
	i -= len(m.Role)
	copy(dAtA[i:], m.Role)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Role)))
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Run.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.DataSourceName)
	copy(dAtA[i:], m.DataSourceName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DataSourceName)))
	i--
	dAtA[i] = 0x12
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatasetStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatasetStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TopCorrelations) > 0 {
		for iNdEx := len(m.TopCorrelations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TopCorrelations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CorrelationsWithTarget) > 0 {
		for iNdEx := len(m.CorrelationsWithTarget) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CorrelationsWithTarget[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.SizeInBytes))
	i--
	dAtA[i] = 0x28
	i = encodeVarintGenerated(dAtA, i, uint64(m.Columns))
	i--
	dAtA[i] = 0x20
	i = encodeVarintGenerated(dAtA, i, uint64(m.Rows))
	i--
	dAtA[i] = 0x18
	if len(m.Features) > 0 {
		for iNdEx := len(m.Features) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Features[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DatasetStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatasetStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	{
		size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LastFailureMessage != nil {
		i -= len(*m.LastFailureMessage)
		copy(dAtA[i:], *m.LastFailureMessage)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.LastFailureMessage)))
		i--
		dAtA[i] = 0x3a
	}
	if m.LastSnapshotAt != nil {
		{
			size, err := m.LastSnapshotAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.AvailableSnapshots) > 0 {
		for iNdEx := len(m.AvailableSnapshots) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AvailableSnapshots[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.LastSnapshotVersion))
	i--
	dAtA[i] = 0x20
	if len(m.Active) > 0 {
		for iNdEx := len(m.Active) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Active[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DriftThreshold) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DriftThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DriftThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
	i--
	dAtA[i] = 0x11
	i -= len(m.Metric)
	copy(dAtA[i:], m.Metric)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Metric)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Entity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EntityList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntityList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EntitySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntitySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntitySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x2a
	}
	i -= len(m.JoinKey)
	copy(dAtA[i:], m.JoinKey)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.JoinKey)))
	i--
	dAtA[i] = 0x22
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TenantRef != nil {
		{
			size, err := m.TenantRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EntityStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntityStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ExcelNotebookSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExcelNotebookSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExcelNotebookSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.ColumnNamesRow != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ColumnNamesRow))
		i--
		dAtA[i] = 0x20
	}
	if m.SheetIndex != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.SheetIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.SheetName != nil {
		i -= len(*m.SheetName)
		copy(dAtA[i:], *m.SheetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SheetName)))
		i--
		dAtA[i] = 0x12
	}
	if m.FirstSheetWithData != nil {
		i--
		if *m.FirstSheetWithData {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExcelSheetArea) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExcelSheetArea) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExcelSheetArea) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ToRow != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ToRow))
		i--
		dAtA[i] = 0x28
	}
	if m.FromRow != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.FromRow))
		i--
		dAtA[i] = 0x20
	}
	if m.ToColumn != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ToColumn))
		i--
		dAtA[i] = 0x18
	}
	if m.FromColumn != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.FromColumn))
		i--
		dAtA[i] = 0x10
	}
	if m.EntireSheet != nil {
		i--
		if *m.EntireSheet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeatureGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeatureGroupList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureGroupList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureGroupList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeatureGroupSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureGroupSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureGroupSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LabRef != nil {
		{
			size, err := m.LabRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	{
		size, err := m.Materialization.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.KeyColumn != nil {
		i -= len(*m.KeyColumn)
		copy(dAtA[i:], *m.KeyColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.KeyColumn)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.TimeColumnFormat != nil {
		i -= len(*m.TimeColumnFormat)
		copy(dAtA[i:], *m.TimeColumnFormat)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TimeColumnFormat)))
		i--
		dAtA[i] = 0x7a
	}
	if m.TimeColumn != nil {
		i -= len(*m.TimeColumn)
		copy(dAtA[i:], *m.TimeColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TimeColumn)))
		i--
		dAtA[i] = 0x72
	}
	{
		size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size, err := m.Tests.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.Schema.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.FlatFile != nil {
		{
			size, err := m.FlatFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.SyncSchedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.IngestSchedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	i -= len(m.EntityName)
	copy(dAtA[i:], m.EntityName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.EntityName)))
	i--
	dAtA[i] = 0x32
	if m.IngestType != nil {
		i -= len(*m.IngestType)
		copy(dAtA[i:], *m.IngestType)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.IngestType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ArtifactBucketName != nil {
		i -= len(*m.ArtifactBucketName)
		copy(dAtA[i:], *m.ArtifactBucketName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ArtifactBucketName)))
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Description)
	copy(dAtA[i:], m.Description)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Description)))
	i--
	dAtA[i] = 0x1a
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.TenantRef != nil {
		{
			size, err := m.TenantRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeatureGroupStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureGroupStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureGroupStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.FailureMessage != nil {
		i -= len(*m.FailureMessage)
		copy(dAtA[i:], *m.FailureMessage)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureMessage)))
		i--
		dAtA[i] = 0x6a
	}
	if m.FailureReason != nil {
		i -= len(*m.FailureReason)
		copy(dAtA[i:], *m.FailureReason)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureReason)))
		i--
		dAtA[i] = 0x62
	}
	i -= len(m.IngestDatasetName)
	copy(dAtA[i:], m.IngestDatasetName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.IngestDatasetName)))
	i--
	dAtA[i] = 0x5a
	if m.OnlineTableCreated != nil {
		{
			size, err := m.OnlineTableCreated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.OnlineTable.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.SyncSchedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.IngestSchedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	i = encodeVarintGenerated(dAtA, i, uint64(m.Rows))
	i--
	dAtA[i] = 0x28
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x18
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *FeatureHistogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureHistogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureHistogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeatureHistogramList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureHistogramList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureHistogramList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeatureHistogramSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureHistogramSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureHistogramSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.ReferenceType)
	copy(dAtA[i:], m.ReferenceType)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ReferenceType)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	i -= len(m.FeatureFilter)
	copy(dAtA[i:], m.FeatureFilter)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.FeatureFilter)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.GenUnitTests != nil {
		i--
		if *m.GenUnitTests {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	{
		size, err := m.UnitTests.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	if m.SyncIntervalSec != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.SyncIntervalSec))
		i--
		dAtA[i] = 0x70
	}
	if len(m.DriftThresholds) > 0 {
		for iNdEx := len(m.DriftThresholds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DriftThresholds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	{
		size, err := m.BaseRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Live != nil {
		i--
		if *m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Training != nil {
		i--
		if *m.Training {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.SourceRef != nil {
		{
			size, err := m.SourceRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.VersionName)
	copy(dAtA[i:], m.VersionName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.VersionName)))
	i--
	dAtA[i] = 0x12
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeatureHistogramStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureHistogramStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureHistogramStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.Errors))
	i--
	dAtA[i] = 0x58
	i = encodeVarintGenerated(dAtA, i, uint64(m.Total))
	i--
	dAtA[i] = 0x50
	{
		size, err := m.UnitTestsResult.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	i -= len(m.FailureMessage)
	copy(dAtA[i:], m.FailureMessage)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.FailureMessage)))
	i--
	dAtA[i] = 0x42
	i -= len(m.FailureReason)
	copy(dAtA[i:], m.FailureReason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.FailureReason)))
	i--
	dAtA[i] = 0x3a
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Logs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *FeatureStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	{
		size, err := m.Outliers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xe2
	i = encodeVarintGenerated(dAtA, i, uint64(m.Index))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xd8
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CorrToTarget))))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xd1
	{
		size, err := m.Histogram.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xca
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MostFreqValuesRatio))))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xb9
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DistinctValueCount))))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xb1
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Completeness))))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xa9
	i--
	if m.Reserved {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x98
	i--
	if m.Duplicate {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x90
	i--
	if m.Constant {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x88
	i--
	if m.Skewed {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xf8
	i--
	if m.HighMissingPct {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xf0
	i--
	if m.LowCorrWithTarget {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe8
	i--
	if m.HighCorrWithOtherFeatures {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe0
	i--
	if m.HighCardinality {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd8
	i--
	if m.Nullable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd0
	i--
	if m.Ignore {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc8
	i--
	if m.Target {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc0
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Importance))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb9
	i = encodeVarintGenerated(dAtA, i, uint64(m.Invalid))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Zeros))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa9
	i -= len(m.Mode)
	copy(dAtA[i:], m.Mode)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Mode)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.IQR))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x99
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P75))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x91
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P50))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x89
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P25))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x81
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mad))))
	i--
	dAtA[i] = 0x79
	i = encodeVarintGenerated(dAtA, i, uint64(m.Sum))
	i--
	dAtA[i] = 0x70
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Skewness))))
	i--
	dAtA[i] = 0x69
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Kurtosis))))
	i--
	dAtA[i] = 0x61
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Max))))
	i--
	dAtA[i] = 0x59
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Min))))
	i--
	dAtA[i] = 0x51
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Variance))))
	i--
	dAtA[i] = 0x49
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.StdDev))))
	i--
	dAtA[i] = 0x41
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mean))))
	i--
	dAtA[i] = 0x39
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PercentMissing))))
	i--
	dAtA[i] = 0x31
	i = encodeVarintGenerated(dAtA, i, uint64(m.Missing))
	i--
	dAtA[i] = 0x28
	i = encodeVarintGenerated(dAtA, i, uint64(m.Distinct))
	i--
	dAtA[i] = 0x20
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Count))))
	i--
	dAtA[i] = 0x19
	i -= len(m.DataType)
	copy(dAtA[i:], m.DataType)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DataType)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FlatFileFormatSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlatFileFormatSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlatFileFormatSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Parquet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Excel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Csv.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.FileType != nil {
		i -= len(*m.FileType)
		copy(dAtA[i:], *m.FileType)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FileType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GaugeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GaugeSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GaugeSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Scalar != nil {
		i -= len(*m.Scalar)
		copy(dAtA[i:], *m.Scalar)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Scalar)))
		i--
		dAtA[i] = 0x22
	}
	if m.Row != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Row))
		i--
		dAtA[i] = 0x18
	}
	if m.Column != nil {
		i -= len(*m.Column)
		copy(dAtA[i:], *m.Column)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Column)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GitLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GitLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GitLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Private != nil {
		i--
		if *m.Private {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Branch != nil {
		i -= len(*m.Branch)
		copy(dAtA[i:], *m.Branch)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Branch)))
		i--
		dAtA[i] = 0x1a
	}
	if m.URL != nil {
		i -= len(*m.URL)
		copy(dAtA[i:], *m.URL)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.URL)))
		i--
		dAtA[i] = 0x12
	}
	if m.GitConnectionName != nil {
		i -= len(*m.GitConnectionName)
		copy(dAtA[i:], *m.GitConnectionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GitConnectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupBySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupBySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupBySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Aggregate)
	copy(dAtA[i:], m.Aggregate)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Aggregate)))
	i--
	dAtA[i] = 0x2a
	if m.Interval != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Interval))
		i--
		dAtA[i] = 0x20
	}
	if m.Frequency != nil {
		i -= len(*m.Frequency)
		copy(dAtA[i:], *m.Frequency)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Frequency)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupBy[iNdEx])
			copy(dAtA[i:], m.GroupBy[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.GroupBy[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupDatasetLocationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupDatasetLocationStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupDatasetLocationStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupFeaturesFile != nil {
		i -= len(*m.GroupFeaturesFile)
		copy(dAtA[i:], *m.GroupFeaturesFile)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GroupFeaturesFile)))
		i--
		dAtA[i] = 0x3a
	}
	if m.GroupReportIndex != nil {
		i -= len(*m.GroupReportIndex)
		copy(dAtA[i:], *m.GroupReportIndex)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GroupReportIndex)))
		i--
		dAtA[i] = 0x32
	}
	if m.GroupProfileFolder != nil {
		i -= len(*m.GroupProfileFolder)
		copy(dAtA[i:], *m.GroupProfileFolder)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GroupProfileFolder)))
		i--
		dAtA[i] = 0x2a
	}
	if m.GroupDataIndex != nil {
		i -= len(*m.GroupDataIndex)
		copy(dAtA[i:], *m.GroupDataIndex)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GroupDataIndex)))
		i--
		dAtA[i] = 0x22
	}
	if m.GroupDataFolder != nil {
		i -= len(*m.GroupDataFolder)
		copy(dAtA[i:], *m.GroupDataFolder)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GroupDataFolder)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupRoot != nil {
		i -= len(*m.GroupRoot)
		copy(dAtA[i:], *m.GroupRoot)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GroupRoot)))
		i--
		dAtA[i] = 0x12
	}
	if m.GroupsRoot != nil {
		i -= len(*m.GroupsRoot)
		copy(dAtA[i:], *m.GroupsRoot)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GroupsRoot)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HistogramSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistogramSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistogramSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bins != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Bins))
		i--
		dAtA[i] = 0x18
	}
	if m.X != nil {
		i -= len(*m.X)
		copy(dAtA[i:], *m.X)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.X)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImageLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegistryConnectionName != nil {
		i -= len(*m.RegistryConnectionName)
		copy(dAtA[i:], *m.RegistryConnectionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.RegistryConnectionName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KPI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Value))))
		i--
		dAtA[i] = 0x11
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LabelingRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelingRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabelingRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Value)
	copy(dAtA[i:], m.Value)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Value)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Operator)
	copy(dAtA[i:], m.Operator)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Operator)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Column)
	copy(dAtA[i:], m.Column)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Column)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LabelingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelingSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabelingSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Negative) > 0 {
		for iNdEx := len(m.Negative) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Negative[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Positive) > 0 {
		for iNdEx := len(m.Positive) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positive[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	i -= len(m.ResultColumn)
	copy(dAtA[i:], m.ResultColumn)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ResultColumn)))
	i--
	dAtA[i] = 0x12
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LineChartSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LineChartSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LineChartSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Legend != nil {
		i--
		if *m.Legend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Y != nil {
		i -= len(*m.Y)
		copy(dAtA[i:], *m.Y)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Y)))
		i--
		dAtA[i] = 0x1a
	}
	if m.X != nil {
		i -= len(*m.X)
		copy(dAtA[i:], *m.X)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.X)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaterializationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializationSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaterializationSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.Backfill != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Backfill))
		i--
		dAtA[i] = 0x30
	}
	if m.OnlineTTL != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.OnlineTTL))
		i--
		dAtA[i] = 0x28
	}
	if m.OfflineTTL != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.OfflineTTL))
		i--
		dAtA[i] = 0x20
	}
	if m.StartDate != nil {
		{
			size, err := m.StartDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Offline != nil {
		i--
		if *m.Offline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Online != nil {
		i--
		if *m.Online {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetricSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Scalar != nil {
		i -= len(*m.Scalar)
		copy(dAtA[i:], *m.Scalar)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Scalar)))
		i--
		dAtA[i] = 0x22
	}
	if m.Row != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Row))
		i--
		dAtA[i] = 0x18
	}
	if m.Column != nil {
		i -= len(*m.Column)
		copy(dAtA[i:], *m.Column)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Column)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutlierStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutlierStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutlierStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Percent))))
	i--
	dAtA[i] = 0x1d
	i = encodeVarintGenerated(dAtA, i, uint64(m.Upper))
	i--
	dAtA[i] = 0x10
	i = encodeVarintGenerated(dAtA, i, uint64(m.Lower))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ParquetFileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParquetFileSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParquetFileSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Engine != nil {
		i -= len(*m.Engine)
		copy(dAtA[i:], *m.Engine)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Engine)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Recipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Recipe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Recipe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecipeInputSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecipeInputSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecipeInputSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Format != nil {
		i -= len(*m.Format)
		copy(dAtA[i:], *m.Format)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Format)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecipeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecipeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecipeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecipeOutputSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecipeOutputSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecipeOutputSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0x12
	}
	if m.CreateDataset != nil {
		i--
		if *m.CreateDataset {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecipePartSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecipePartSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecipePartSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dependents) > 0 {
		for iNdEx := len(m.Dependents) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Dependents[iNdEx])
			copy(dAtA[i:], m.Dependents[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Dependents[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.RecipeName != nil {
		i -= len(*m.RecipeName)
		copy(dAtA[i:], *m.RecipeName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.RecipeName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecipeRun) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecipeRun) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecipeRun) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecipeRunList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecipeRunList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecipeRunList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecipeRunSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecipeRunSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecipeRunSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModelClassRunName != nil {
		i -= len(*m.ModelClassRunName)
		copy(dAtA[i:], *m.ModelClassRunName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ModelClassRunName)))
		i--
		dAtA[i] = 0x42
	}
	if m.ModelClassName != nil {
		i -= len(*m.ModelClassName)
		copy(dAtA[i:], *m.ModelClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ModelClassName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TTL != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TTL))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.LabRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RecipeName != nil {
		i -= len(*m.RecipeName)
		copy(dAtA[i:], *m.RecipeName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.RecipeName)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecipeRunStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecipeRunStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecipeRunStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	{
		size, err := m.Logs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	i -= len(m.TriggeredBy)
	copy(dAtA[i:], m.TriggeredBy)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.TriggeredBy)))
	i--
	dAtA[i] = 0x32
	if m.FailureMessage != nil {
		i -= len(*m.FailureMessage)
		copy(dAtA[i:], *m.FailureMessage)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureMessage)))
		i--
		dAtA[i] = 0x2a
	}
	if m.FailureReason != nil {
		i -= len(*m.FailureReason)
		copy(dAtA[i:], *m.FailureReason)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureReason)))
		i--
		dAtA[i] = 0x22
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x18
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x12
	if m.CompletedAt != nil {
		{
			size, err := m.CompletedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecipeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecipeSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecipeSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.UnitTestsTemplate.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.TTL != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TTL))
		i--
		dAtA[i] = 0x58
	}
	if m.Timeout != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Timeout))
		i--
		dAtA[i] = 0x50
	}
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.Sample.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.VersionName != nil {
		i -= len(*m.VersionName)
		copy(dAtA[i:], *m.VersionName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.VersionName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Owner != nil {
		i -= len(*m.Owner)
		copy(dAtA[i:], *m.Owner)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecipeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecipeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecipeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.LastRun.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i = encodeVarintGenerated(dAtA, i, uint64(m.ObservedGeneration))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *RecipeStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecipeStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecipeStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i -= len(m.Op)
	copy(dAtA[i:], m.Op)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Op)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecipeStepParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecipeStepParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecipeStepParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Value)
	copy(dAtA[i:], m.Value)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Value)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecommendationSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendationSchema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecommendationSchema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RatingColumn != nil {
		i -= len(*m.RatingColumn)
		copy(dAtA[i:], *m.RatingColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.RatingColumn)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ItemIDColumn != nil {
		i -= len(*m.ItemIDColumn)
		copy(dAtA[i:], *m.ItemIDColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ItemIDColumn)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserIDColumn != nil {
		i -= len(*m.UserIDColumn)
		copy(dAtA[i:], *m.UserIDColumn)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.UserIDColumn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RelationshipSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationshipSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelationshipSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.RelatesTo)
	copy(dAtA[i:], m.RelatesTo)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.RelatesTo)))
	i--
	dAtA[i] = 0x22
	if m.Arity != nil {
		i -= len(*m.Arity)
		copy(dAtA[i:], *m.Arity)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Arity)))
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.Column)
	copy(dAtA[i:], m.Column)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Column)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RowSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SampleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SampleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Filter != nil {
		i -= len(*m.Filter)
		copy(dAtA[i:], *m.Filter)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Filter)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Percent != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Percent))
		i--
		dAtA[i] = 0x20
	}
	if m.Rows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Rows))
		i--
		dAtA[i] = 0x18
	}
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *ScatterPlotSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScatterPlotSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScatterPlotSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Y != nil {
		i -= len(*m.Y)
		copy(dAtA[i:], *m.Y)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Y)))
		i--
		dAtA[i] = 0x1a
	}
	if m.X != nil {
		i -= len(*m.X)
		copy(dAtA[i:], *m.X)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.X)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Schema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Schema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		for iNdEx := len(m.Key) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Key[iNdEx])
			copy(dAtA[i:], m.Key[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Key[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.RecommendationSchema.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.TimeSeriesSchema.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SyntheticSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyntheticSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyntheticSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Rows))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Border != nil {
		i--
		if *m.Border {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ShowIndex != nil {
		i--
		if *m.ShowIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Rows != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Rows))
		i--
		dAtA[i] = 0x28
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupBy[iNdEx])
			copy(dAtA[i:], m.GroupBy[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.GroupBy[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Filters[iNdEx])
			copy(dAtA[i:], m.Filters[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Filters[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DatasetName != nil {
		i -= len(*m.DatasetName)
		copy(dAtA[i:], *m.DatasetName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DatasetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimeSeriesSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeSeriesSchema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeSeriesSchema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Interval != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Interval))
		i--
		dAtA[i] = 0x18
	}
	if m.Freq != nil {
		i -= len(*m.Freq)
		copy(dAtA[i:], *m.Freq)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Freq)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != nil {
		i -= len(*m.Type)
		copy(dAtA[i:], *m.Type)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenerated(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenerated(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ApprovalReviewStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reviewer)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Result)
	n += 1 + l + sovGenerated(uint64(l))
	if m.ApprovedAt != nil {
		l = m.ApprovedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Notes)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ApprovalSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.DecisionType != nil {
		l = len(*m.DecisionType)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Reviewers) > 0 {
		for _, s := range m.Reviewers {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ApprovalStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Reviews) > 0 {
		for _, e := range m.Reviews {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *BarChartSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.X != nil {
		l = len(*m.X)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Y != nil {
		l = len(*m.Y)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Legend != nil {
		n += 2
	}
	if m.Sort != nil {
		n += 2
	}
	return n
}

func (m *Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	if m.DisplayName != nil {
		l = len(*m.DisplayName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.DataType)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Format != nil {
		l = len(*m.Format)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Ignore != nil {
		n += 2
	}
	if m.Target != nil {
		n += 2
	}
	if m.Nullable != nil {
		n += 2
	}
	if m.PK != nil {
		n += 2
	}
	if m.FK != nil {
		n += 2
	}
	if m.MultipleOf != nil {
		n += 1 + sovGenerated(uint64(*m.MultipleOf))
	}
	if m.Maximum != nil {
		n += 9
	}
	if m.ExclusiveMaximum != nil {
		n += 2
	}
	if m.Minimum != nil {
		n += 9
	}
	if m.ExclusiveMinimum != nil {
		n += 2
	}
	if m.MaxLength != nil {
		n += 2 + sovGenerated(uint64(*m.MaxLength))
	}
	if m.MinLength != nil {
		n += 2 + sovGenerated(uint64(*m.MinLength))
	}
	if m.Pattern != nil {
		l = len(*m.Pattern)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Required != nil {
		n += 3
	}
	if m.Example != nil {
		l = len(*m.Example)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.ExternalDocs != nil {
		l = len(*m.ExternalDocs)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if len(m.Enum) > 0 {
		for _, s := range m.Enum {
			l = len(s)
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	if m.MaxItems != nil {
		n += 2 + sovGenerated(uint64(*m.MaxItems))
	}
	if m.MinItems != nil {
		n += 2 + sovGenerated(uint64(*m.MinItems))
	}
	if m.UniqueItems != nil {
		n += 3
	}
	if m.PII != nil {
		n += 3
	}
	if m.PHI != nil {
		n += 3
	}
	if m.Protected != nil {
		n += 3
	}
	if m.DefaultValueNum != nil {
		n += 10
	}
	if m.Log != nil {
		n += 3
	}
	if m.Mu != nil {
		n += 10
	}
	if m.Sigma != nil {
		n += 10
	}
	if m.SkewThreshold != nil {
		n += 10
	}
	if m.DriftThreshold != nil {
		n += 10
	}
	if m.Key != nil {
		n += 3
	}
	if m.Fold != nil {
		n += 3
	}
	if m.Weight != nil {
		n += 3
	}
	if m.Reserved != nil {
		n += 3
	}
	if m.Imputation != nil {
		l = len(*m.Imputation)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Scaling != nil {
		l = len(*m.Scaling)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Generated != nil {
		n += 3
	}
	if m.Formula != nil {
		l = len(*m.Formula)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.ID != nil {
		n += 3
	}
	if m.Step != nil {
		n += 10
	}
	n += 2 + sovGenerated(uint64(m.Loc))
	if m.DateTimeFormat != nil {
		l = len(*m.DateTimeFormat)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.TimeSeries != nil {
		n += 3
	}
	if m.Regressor != nil {
		n += 3
	}
	if m.LaggedRegressor != nil {
		n += 3
	}
	if m.TimeIndex != nil {
		n += 3
	}
	if m.Aggr != nil {
		l = len(*m.Aggr)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Window != nil {
		n += 2 + sovGenerated(uint64(*m.Window))
	}
	return n
}

func (m *ColumnHistogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Histogram.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Drift != nil {
		n += 2
	}
	return n
}

func (m *ColumnSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spacer != nil {
		n += 2
	}
	if m.Width != nil {
		n += 1 + sovGenerated(uint64(*m.Width))
	}
	l = m.Content.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Title != nil {
		l = len(*m.Title)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SubTitle != nil {
		l = len(*m.SubTitle)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Footer != nil {
		l = len(*m.Footer)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.ComponentView.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ComponentView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metric != nil {
		l = m.Metric.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Gauge != nil {
		l = m.Gauge.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Histogram != nil {
		l = m.Histogram.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.LineChart != nil {
		l = m.LineChart.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.BarChart != nil {
		l = m.BarChart.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ScatterChart != nil {
		l = m.ScatterChart.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *Correlation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.X)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Y)
	n += 1 + l + sovGenerated(uint64(l))
	n += 9
	l = len(m.Method)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *CorrelationSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cutoff != nil {
		n += 9
	}
	if m.Method != nil {
		l = len(*m.Method)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Top != nil {
		n += 1 + sovGenerated(uint64(*m.Top))
	}
	return n
}

func (m *CsvFileSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delimiter != nil {
		l = len(*m.Delimiter)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.QuoteChar)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.EscapeChar)
	n += 1 + l + sovGenerated(uint64(l))
	if m.CommentChars != nil {
		l = len(*m.CommentChars)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Header != nil {
		n += 2
	}
	if m.SkipRows != nil {
		n += 1 + sovGenerated(uint64(*m.SkipRows))
	}
	if m.NullValues != nil {
		l = len(*m.NullValues)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Encoding != nil {
		l = len(*m.Encoding)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.MaxRows != nil {
		n += 1 + sovGenerated(uint64(*m.MaxRows))
	}
	if m.Strict != nil {
		n += 2
	}
	if m.Compression != nil {
		l = len(*m.Compression)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.HasIndexColumn != nil {
		n += 2
	}
	return n
}

func (m *DataInputSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Format.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DataOutputSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Format != nil {
		l = len(*m.Format)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Action != nil {
		l = len(*m.Action)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CreateTableIfNotExist != nil {
		n += 2
	}
	if m.IncludeFeatures != nil {
		n += 2
	}
	if m.IncludeShapValues != nil {
		n += 2
	}
	if m.DetectOutliers != nil {
		n += 2
	}
	return n
}

func (m *DataPipeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DataPipelineList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DataPipelineRun) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DataPipelineRunCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DataPipelineRunList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DataPipelineRunSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DataPipelineName != nil {
		l = len(*m.DataPipelineName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Resources.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Priority != nil {
		l = len(*m.Priority)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Paused != nil {
		n += 2
	}
	if m.Aborted != nil {
		n += 2
	}
	l = m.LabRef.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.ModelClassName != nil {
		l = len(*m.ModelClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ModelClassRunName != nil {
		l = len(*m.ModelClassRunName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *DataPipelineRunStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RecipeRuns) > 0 {
		for _, s := range m.RecipeRuns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = m.Output.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	if m.CompletedAt != nil {
		l = m.CompletedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if m.FailureReason != nil {
		l = len(*m.FailureReason)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FailureMessage != nil {
		l = len(*m.FailureMessage)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Progress != nil {
		n += 1 + sovGenerated(uint64(*m.Progress))
	}
	l = m.Logs.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DataPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ModelClassName != nil {
		l = len(*m.ModelClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.DatasetSelector) > 0 {
		for k, v := range m.DatasetSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	if len(m.Recipes) > 0 {
		for _, e := range m.Recipes {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = m.Output.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Schedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Notification.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Resources.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Priority != nil {
		l = len(*m.Priority)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Paused != nil {
		n += 2
	}
	if m.TTL != nil {
		n += 1 + sovGenerated(uint64(*m.TTL))
	}
	return n
}

func (m *DataPipelineStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Schedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.LastRunName)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.RunsCount))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DataProduct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DataProductList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DataProductSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Public != nil {
		n += 2
	}
	if m.TenantRef != nil {
		l = m.TenantRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.GitLocation.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.CacheBucketName)
	n += 1 + l + sovGenerated(uint64(l))
	if m.DefaultLabName != nil {
		l = len(*m.DefaultLabName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DefaultServingSiteName != nil {
		l = len(*m.DefaultServingSiteName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DefaultBucketName != nil {
		l = len(*m.DefaultBucketName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Task != nil {
		l = len(*m.Task)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SubTask != nil {
		l = len(*m.SubTask)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Notification != nil {
		l = m.Notification.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.DefaultTrainingResources.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.DefaultServingResources.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.DefaultPriority != nil {
		l = len(*m.DefaultPriority)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Color != nil {
		l = len(*m.Color)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Approval != nil {
		l = m.Approval.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	l = m.Permissions.Size()
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DataProductStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	n += 1 + sovGenerated(uint64(m.DatasourcesCount))
	n += 1 + sovGenerated(uint64(m.DatasetsCount))
	n += 1 + sovGenerated(uint64(m.DataPipelinesCount))
	n += 1 + sovGenerated(uint64(m.DataPipelineRunsCount))
	n += 1 + sovGenerated(uint64(m.StudiesCount))
	n += 1 + sovGenerated(uint64(m.ModelsCount))
	n += 1 + sovGenerated(uint64(m.PredictorsCount))
	n += 1 + sovGenerated(uint64(m.DataAppsCount))
	n += 1 + sovGenerated(uint64(m.PredictionsCount))
	n += 1 + sovGenerated(uint64(m.InfoAlertsCount))
	n += 2 + sovGenerated(uint64(m.ErrorsAlertsCount))
	n += 2 + sovGenerated(uint64(m.ModelClassesCount))
	if m.FailureReason != nil {
		l = len(*m.FailureReason)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.FailureMessage != nil {
		l = len(*m.FailureMessage)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.BaselineVersion != nil {
		l = len(*m.BaselineVersion)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DataProductVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DataProductVersionList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DataProductVersionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ProductRef.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.PrevVersionName != nil {
		l = len(*m.PrevVersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Baseline != nil {
		n += 2
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *DataProductVersionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FailureReason != nil {
		l = len(*m.FailureReason)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FailureMessage != nil {
		l = len(*m.FailureMessage)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DataSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DataSourceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DataSourceSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.VersionName)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DatasetType != nil {
		l = len(*m.DatasetType)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Schema.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.FlatFile != nil {
		l = m.FlatFile.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Labeled != nil {
		n += 2
	}
	l = m.Sample.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Task)
	n += 1 + l + sovGenerated(uint64(l))
	if m.SubTask != nil {
		l = len(*m.SubTask)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Relationships) > 0 {
		for _, e := range m.Relationships {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = m.Labeling.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.InferredFrom != nil {
		l = m.InferredFrom.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.UnitTestsTemplate.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.IngestMethod != nil {
		l = len(*m.IngestMethod)
		n += 2 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *DataSourceStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.Cols))
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if m.LastDatasetCreatedAt != nil {
		l = m.LastDatasetCreatedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.LastDatasetName)
	n += 1 + l + sovGenerated(uint64(l))
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FailureReason != nil {
		l = len(*m.FailureReason)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FailureMessage != nil {
		l = len(*m.FailureMessage)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *Dataset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DatasetGroupByStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DatasetsURI)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ProfilesURI)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ReportsURI)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.UnitTestsURI)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.WorkerResults) > 0 {
		for _, e := range m.WorkerResults {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DatasetList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DatasetSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DatasetSnapshotList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DatasetSnapshotSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.DatasetName)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Timeout != nil {
		n += 1 + sovGenerated(uint64(*m.Timeout))
	}
	if m.Pause != nil {
		n += 2
	}
	if m.Abort != nil {
		n += 2
	}
	if m.ModelClassRunName != nil {
		l = len(*m.ModelClassRunName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *DatasetSnapshotStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	l = m.DatasetManifestLocation.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.DataSourceManifestLocation.Size()
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.SnapshotVersion))
	l = m.Statistics.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ReportName)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.DataLocation.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.ReportLocation.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.ProfileLocation.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.AnomaliesLocation.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.SampleLocation.Size()
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	l = m.UnitTestResults.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.FailureMessage != nil {
		l = len(*m.FailureMessage)
		n += 1 + l + sovGenerated(uint64(l))
	}
	n += 2 + sovGenerated(uint64(m.Progress))
	l = m.Logs.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.Hash)
	n += 2 + l + sovGenerated(uint64(l))
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.CompletedAt != nil {
		l = m.CompletedAt.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.LastStudyAt != nil {
		l = m.LastStudyAt.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	l = m.Images.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.FeatureHistogramRef.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.GroupBy.Size()
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DatasetSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.DataSourceName)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Run.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Schedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Role)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Task)
	n += 1 + l + sovGenerated(uint64(l))
	if m.SubTask != nil {
		l = len(*m.SubTask)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Origin.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Resources.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.UnitTests.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Report != nil {
		n += 2
	}
	if m.UnitTest != nil {
		n += 2
	}
	if m.GenerateFeatureHistogram != nil {
		n += 2
	}
	if m.Fast != nil {
		n += 3
	}
	if m.ArtifactBucketName != nil {
		l = len(*m.ArtifactBucketName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Sample != nil {
		l = m.Sample.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Synthetic != nil {
		l = m.Synthetic.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Correlation != nil {
		l = m.Correlation.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.LabRef != nil {
		l = m.LabRef.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.GroupBy != nil {
		l = m.GroupBy.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if len(m.Key) > 0 {
		for _, s := range m.Key {
			l = len(s)
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	if m.ModelClassName != nil {
		l = len(*m.ModelClassName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.FeatureGroupName != nil {
		l = len(*m.FeatureGroupName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Notification != nil {
		l = m.Notification.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *DatasetStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Features) > 0 {
		for _, e := range m.Features {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	n += 1 + sovGenerated(uint64(m.Rows))
	n += 1 + sovGenerated(uint64(m.Columns))
	n += 1 + sovGenerated(uint64(m.SizeInBytes))
	if len(m.CorrelationsWithTarget) > 0 {
		for _, e := range m.CorrelationsWithTarget {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.TopCorrelations) > 0 {
		for _, e := range m.TopCorrelations {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DatasetStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if len(m.Active) > 0 {
		for _, e := range m.Active {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	n += 1 + sovGenerated(uint64(m.LastSnapshotVersion))
	if len(m.AvailableSnapshots) > 0 {
		for _, e := range m.AvailableSnapshots {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.LastSnapshotAt != nil {
		l = m.LastSnapshotAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.LastFailureMessage != nil {
		l = len(*m.LastFailureMessage)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Schedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DriftThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Metric)
	n += 1 + l + sovGenerated(uint64(l))
	n += 9
	return n
}

func (m *Entity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *EntityList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *EntitySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TenantRef != nil {
		l = m.TenantRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.JoinKey)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *EntityStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ExcelNotebookSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FirstSheetWithData != nil {
		n += 2
	}
	if m.SheetName != nil {
		l = len(*m.SheetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SheetIndex != nil {
		n += 1 + sovGenerated(uint64(*m.SheetIndex))
	}
	if m.ColumnNamesRow != nil {
		n += 1 + sovGenerated(uint64(*m.ColumnNamesRow))
	}
	l = m.Data.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ExcelSheetArea) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntireSheet != nil {
		n += 2
	}
	if m.FromColumn != nil {
		n += 1 + sovGenerated(uint64(*m.FromColumn))
	}
	if m.ToColumn != nil {
		n += 1 + sovGenerated(uint64(*m.ToColumn))
	}
	if m.FromRow != nil {
		n += 1 + sovGenerated(uint64(*m.FromRow))
	}
	if m.ToRow != nil {
		n += 1 + sovGenerated(uint64(*m.ToRow))
	}
	return n
}

func (m *FeatureGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *FeatureGroupList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *FeatureGroupSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TenantRef != nil {
		l = m.TenantRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Description)
	n += 1 + l + sovGenerated(uint64(l))
	if m.ArtifactBucketName != nil {
		l = len(*m.ArtifactBucketName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.IngestType != nil {
		l = len(*m.IngestType)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.EntityName)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = m.IngestSchedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.SyncSchedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.FlatFile != nil {
		l = m.FlatFile.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Schema.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Tests.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Location.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.TimeColumn != nil {
		l = len(*m.TimeColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TimeColumnFormat != nil {
		l = len(*m.TimeColumnFormat)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.KeyColumn != nil {
		l = len(*m.KeyColumn)
		n += 2 + l + sovGenerated(uint64(l))
	}
	l = m.Materialization.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.Resources.Size()
	n += 2 + l + sovGenerated(uint64(l))
	if m.LabRef != nil {
		l = m.LabRef.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *FeatureGroupStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	n += 1 + sovGenerated(uint64(m.Rows))
	l = m.IngestSchedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.SyncSchedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.OnlineTable.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.OnlineTableCreated != nil {
		l = m.OnlineTableCreated.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.IngestDatasetName)
	n += 1 + l + sovGenerated(uint64(l))
	if m.FailureReason != nil {
		l = len(*m.FailureReason)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FailureMessage != nil {
		l = len(*m.FailureMessage)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *FeatureHistogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *FeatureHistogramList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *FeatureHistogramSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.VersionName)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.SourceRef != nil {
		l = m.SourceRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Training != nil {
		n += 2
	}
	if m.Live != nil {
		n += 2
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.BaseRef.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.DriftThresholds) > 0 {
		for _, e := range m.DriftThresholds {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.SyncIntervalSec != nil {
		n += 1 + sovGenerated(uint64(*m.SyncIntervalSec))
	}
	l = m.UnitTests.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.GenUnitTests != nil {
		n += 3
	}
	l = len(m.FeatureFilter)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.ReferenceType)
	n += 2 + l + sovGenerated(uint64(l))
	return n
}

func (m *FeatureHistogramStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Logs.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.FailureReason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.FailureMessage)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.UnitTestsResult.Size()
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.Total))
	n += 1 + sovGenerated(uint64(m.Errors))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *FeatureStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DataType)
	n += 1 + l + sovGenerated(uint64(l))
	n += 9
	n += 1 + sovGenerated(uint64(m.Distinct))
	n += 1 + sovGenerated(uint64(m.Missing))
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	n += 1 + sovGenerated(uint64(m.Sum))
	n += 9
	n += 10
	n += 10
	n += 10
	n += 10
	l = len(m.Mode)
	n += 2 + l + sovGenerated(uint64(l))
	n += 10
	n += 2 + sovGenerated(uint64(m.Invalid))
	n += 10
	n += 3
	n += 3
	n += 3
	n += 3
	n += 3
	n += 3
	n += 3
	n += 3
	n += 3
	n += 3
	n += 3
	n += 10
	n += 10
	n += 10
	l = m.Histogram.Size()
	n += 2 + l + sovGenerated(uint64(l))
	n += 10
	n += 2 + sovGenerated(uint64(m.Index))
	l = m.Outliers.Size()
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *FlatFileFormatSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileType != nil {
		l = len(*m.FileType)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Csv.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Excel.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Parquet.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *GaugeSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Column != nil {
		l = len(*m.Column)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Row != nil {
		n += 1 + sovGenerated(uint64(*m.Row))
	}
	if m.Scalar != nil {
		l = len(*m.Scalar)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *GitLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GitConnectionName != nil {
		l = len(*m.GitConnectionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.URL != nil {
		l = len(*m.URL)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Branch != nil {
		l = len(*m.Branch)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Private != nil {
		n += 2
	}
	return n
}

func (m *GroupBySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if len(m.GroupBy) > 0 {
		for _, s := range m.GroupBy {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Frequency != nil {
		l = len(*m.Frequency)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Interval != nil {
		n += 1 + sovGenerated(uint64(*m.Interval))
	}
	l = len(m.Aggregate)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *GroupDatasetLocationStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupsRoot != nil {
		l = len(*m.GroupsRoot)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GroupRoot != nil {
		l = len(*m.GroupRoot)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GroupDataFolder != nil {
		l = len(*m.GroupDataFolder)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GroupDataIndex != nil {
		l = len(*m.GroupDataIndex)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GroupProfileFolder != nil {
		l = len(*m.GroupProfileFolder)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GroupReportIndex != nil {
		l = len(*m.GroupReportIndex)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GroupFeaturesFile != nil {
		l = len(*m.GroupFeaturesFile)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *HistogramSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.X != nil {
		l = len(*m.X)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Bins != nil {
		n += 1 + sovGenerated(uint64(*m.Bins))
	}
	return n
}

func (m *ImageLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.RegistryConnectionName != nil {
		l = len(*m.RegistryConnectionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *KPI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Value != nil {
		n += 9
	}
	return n
}

func (m *LabelingRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Column)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Operator)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *LabelingSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	l = len(m.ResultColumn)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Positive) > 0 {
		for _, e := range m.Positive {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Negative) > 0 {
		for _, e := range m.Negative {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *LineChartSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.X != nil {
		l = len(*m.X)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Y != nil {
		l = len(*m.Y)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Legend != nil {
		n += 2
	}
	return n
}

func (m *MaterializationSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Online != nil {
		n += 2
	}
	if m.Offline != nil {
		n += 2
	}
	if m.StartDate != nil {
		l = m.StartDate.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.OfflineTTL != nil {
		n += 1 + sovGenerated(uint64(*m.OfflineTTL))
	}
	if m.OnlineTTL != nil {
		n += 1 + sovGenerated(uint64(*m.OnlineTTL))
	}
	if m.Backfill != nil {
		n += 1 + sovGenerated(uint64(*m.Backfill))
	}
	l = m.Schedule.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *MetricSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Column != nil {
		l = len(*m.Column)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Row != nil {
		n += 1 + sovGenerated(uint64(*m.Row))
	}
	if m.Scalar != nil {
		l = len(*m.Scalar)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *OutlierStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.Lower))
	n += 1 + sovGenerated(uint64(m.Upper))
	n += 5
	return n
}

func (m *PageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ParquetFileSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Engine != nil {
		l = len(*m.Engine)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *Recipe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *RecipeInputSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Format != nil {
		l = len(*m.Format)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *RecipeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *RecipeOutputSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateDataset != nil {
		n += 2
	}
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *RecipePartSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecipeName != nil {
		l = len(*m.RecipeName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Dependents) > 0 {
		for _, s := range m.Dependents {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *RecipeRun) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *RecipeRunList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *RecipeRunSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.RecipeName != nil {
		l = len(*m.RecipeName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.LabRef.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Location.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Resources.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.TTL != nil {
		n += 1 + sovGenerated(uint64(*m.TTL))
	}
	if m.ModelClassName != nil {
		l = len(*m.ModelClassName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ModelClassRunName != nil {
		l = len(*m.ModelClassRunName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *RecipeRunStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompletedAt != nil {
		l = m.CompletedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	if m.FailureReason != nil {
		l = len(*m.FailureReason)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FailureMessage != nil {
		l = len(*m.FailureMessage)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.TriggeredBy)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Logs.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *RecipeSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.VersionName != nil {
		l = len(*m.VersionName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.Input.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = m.Output.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Sample.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Resources.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Timeout != nil {
		n += 1 + sovGenerated(uint64(*m.Timeout))
	}
	if m.TTL != nil {
		n += 1 + sovGenerated(uint64(*m.TTL))
	}
	l = m.UnitTestsTemplate.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *RecipeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.ObservedGeneration))
	l = m.LastRun.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *RecipeStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Op)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *RecipeStepParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *RecommendationSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserIDColumn != nil {
		l = len(*m.UserIDColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ItemIDColumn != nil {
		l = len(*m.ItemIDColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.RatingColumn != nil {
		l = len(*m.RatingColumn)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *RelationshipSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Column)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Arity != nil {
		l = len(*m.Arity)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.RelatesTo)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *RowSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *SampleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Rows != nil {
		n += 1 + sovGenerated(uint64(*m.Rows))
	}
	if m.Percent != nil {
		n += 1 + sovGenerated(uint64(*m.Percent))
	}
	if m.Filter != nil {
		l = len(*m.Filter)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *ScatterPlotSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.X != nil {
		l = len(*m.X)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Y != nil {
		l = len(*m.Y)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TimeSeriesSchema.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.RecommendationSchema.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Key) > 0 {
		for _, s := range m.Key {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *SyntheticSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.Rows != nil {
		n += 1 + sovGenerated(uint64(*m.Rows))
	}
	return n
}

func (m *TableSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetName != nil {
		l = len(*m.DatasetName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Filters) > 0 {
		for _, s := range m.Filters {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.GroupBy) > 0 {
		for _, s := range m.GroupBy {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Rows != nil {
		n += 1 + sovGenerated(uint64(*m.Rows))
	}
	if m.ShowIndex != nil {
		n += 2
	}
	if m.Border != nil {
		n += 2
	}
	return n
}

func (m *TimeSeriesSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Freq != nil {
		l = len(*m.Freq)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Interval != nil {
		n += 1 + sovGenerated(uint64(*m.Interval))
	}
	return n
}

func sovGenerated(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenerated(x uint64) (n int) {
	return sovGenerated(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ApprovalReviewStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApprovalReviewStatus{`,
		`Reviewer:` + fmt.Sprintf("%v", this.Reviewer) + `,`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`ApprovedAt:` + strings.Replace(fmt.Sprintf("%v", this.ApprovedAt), "Time", "v1.Time", 1) + `,`,
		`Notes:` + fmt.Sprintf("%v", this.Notes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApprovalSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApprovalSpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`DecisionType:` + valueToStringGenerated(this.DecisionType) + `,`,
		`Reviewers:` + fmt.Sprintf("%v", this.Reviewers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApprovalStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForReviews := "[]ApprovalReviewStatus{"
	for _, f := range this.Reviews {
		repeatedStringForReviews += strings.Replace(strings.Replace(f.String(), "ApprovalReviewStatus", "ApprovalReviewStatus", 1), `&`, ``, 1) + ","
	}
	repeatedStringForReviews += "}"
	s := strings.Join([]string{`&ApprovalStatus{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Reviews:` + repeatedStringForReviews + `,`,
		`}`,
	}, "")
	return s
}
func (this *BarChartSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BarChartSpec{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`X:` + valueToStringGenerated(this.X) + `,`,
		`Y:` + valueToStringGenerated(this.Y) + `,`,
		`Legend:` + valueToStringGenerated(this.Legend) + `,`,
		`Sort:` + valueToStringGenerated(this.Sort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DisplayName:` + valueToStringGenerated(this.DisplayName) + `,`,
		`DataType:` + fmt.Sprintf("%v", this.DataType) + `,`,
		`Format:` + valueToStringGenerated(this.Format) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`Ignore:` + valueToStringGenerated(this.Ignore) + `,`,
		`Target:` + valueToStringGenerated(this.Target) + `,`,
		`Nullable:` + valueToStringGenerated(this.Nullable) + `,`,
		`PK:` + valueToStringGenerated(this.PK) + `,`,
		`FK:` + valueToStringGenerated(this.FK) + `,`,
		`MultipleOf:` + valueToStringGenerated(this.MultipleOf) + `,`,
		`Maximum:` + valueToStringGenerated(this.Maximum) + `,`,
		`ExclusiveMaximum:` + valueToStringGenerated(this.ExclusiveMaximum) + `,`,
		`Minimum:` + valueToStringGenerated(this.Minimum) + `,`,
		`ExclusiveMinimum:` + valueToStringGenerated(this.ExclusiveMinimum) + `,`,
		`MaxLength:` + valueToStringGenerated(this.MaxLength) + `,`,
		`MinLength:` + valueToStringGenerated(this.MinLength) + `,`,
		`Pattern:` + valueToStringGenerated(this.Pattern) + `,`,
		`Required:` + valueToStringGenerated(this.Required) + `,`,
		`Example:` + valueToStringGenerated(this.Example) + `,`,
		`ExternalDocs:` + valueToStringGenerated(this.ExternalDocs) + `,`,
		`Enum:` + fmt.Sprintf("%v", this.Enum) + `,`,
		`MaxItems:` + valueToStringGenerated(this.MaxItems) + `,`,
		`MinItems:` + valueToStringGenerated(this.MinItems) + `,`,
		`UniqueItems:` + valueToStringGenerated(this.UniqueItems) + `,`,
		`PII:` + valueToStringGenerated(this.PII) + `,`,
		`PHI:` + valueToStringGenerated(this.PHI) + `,`,
		`Protected:` + valueToStringGenerated(this.Protected) + `,`,
		`DefaultValueNum:` + valueToStringGenerated(this.DefaultValueNum) + `,`,
		`Log:` + valueToStringGenerated(this.Log) + `,`,
		`Mu:` + valueToStringGenerated(this.Mu) + `,`,
		`Sigma:` + valueToStringGenerated(this.Sigma) + `,`,
		`SkewThreshold:` + valueToStringGenerated(this.SkewThreshold) + `,`,
		`DriftThreshold:` + valueToStringGenerated(this.DriftThreshold) + `,`,
		`Key:` + valueToStringGenerated(this.Key) + `,`,
		`Fold:` + valueToStringGenerated(this.Fold) + `,`,
		`Weight:` + valueToStringGenerated(this.Weight) + `,`,
		`Reserved:` + valueToStringGenerated(this.Reserved) + `,`,
		`Imputation:` + valueToStringGenerated(this.Imputation) + `,`,
		`Scaling:` + valueToStringGenerated(this.Scaling) + `,`,
		`Generated:` + valueToStringGenerated(this.Generated) + `,`,
		`Formula:` + valueToStringGenerated(this.Formula) + `,`,
		`ID:` + valueToStringGenerated(this.ID) + `,`,
		`Step:` + valueToStringGenerated(this.Step) + `,`,
		`Loc:` + fmt.Sprintf("%v", this.Loc) + `,`,
		`DateTimeFormat:` + valueToStringGenerated(this.DateTimeFormat) + `,`,
		`TimeSeries:` + valueToStringGenerated(this.TimeSeries) + `,`,
		`Regressor:` + valueToStringGenerated(this.Regressor) + `,`,
		`LaggedRegressor:` + valueToStringGenerated(this.LaggedRegressor) + `,`,
		`TimeIndex:` + valueToStringGenerated(this.TimeIndex) + `,`,
		`Aggr:` + valueToStringGenerated(this.Aggr) + `,`,
		`Window:` + valueToStringGenerated(this.Window) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnHistogram) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMetrics := "[]Measurement{"
	for _, f := range this.Metrics {
		repeatedStringForMetrics += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForMetrics += "}"
	s := strings.Join([]string{`&ColumnHistogram{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Histogram:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Histogram), "HistogramData", "v1alpha1.HistogramData", 1), `&`, ``, 1) + `,`,
		`Metrics:` + repeatedStringForMetrics + `,`,
		`Drift:` + valueToStringGenerated(this.Drift) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnSpec{`,
		`Spacer:` + valueToStringGenerated(this.Spacer) + `,`,
		`Width:` + valueToStringGenerated(this.Width) + `,`,
		`Content:` + strings.Replace(strings.Replace(this.Content.String(), "ComponentSpec", "ComponentSpec", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ComponentSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ComponentSpec{`,
		`Title:` + valueToStringGenerated(this.Title) + `,`,
		`SubTitle:` + valueToStringGenerated(this.SubTitle) + `,`,
		`Footer:` + valueToStringGenerated(this.Footer) + `,`,
		`ComponentView:` + strings.Replace(strings.Replace(this.ComponentView.String(), "ComponentView", "ComponentView", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ComponentView) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ComponentView{`,
		`Metric:` + strings.Replace(this.Metric.String(), "MetricSpec", "MetricSpec", 1) + `,`,
		`Gauge:` + strings.Replace(this.Gauge.String(), "GaugeSpec", "GaugeSpec", 1) + `,`,
		`Histogram:` + strings.Replace(this.Histogram.String(), "HistogramSpec", "HistogramSpec", 1) + `,`,
		`Table:` + strings.Replace(this.Table.String(), "TableSpec", "TableSpec", 1) + `,`,
		`LineChart:` + strings.Replace(this.LineChart.String(), "LineChartSpec", "LineChartSpec", 1) + `,`,
		`BarChart:` + strings.Replace(this.BarChart.String(), "BarChartSpec", "BarChartSpec", 1) + `,`,
		`ScatterChart:` + strings.Replace(this.ScatterChart.String(), "ScatterPlotSpec", "ScatterPlotSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Correlation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Correlation{`,
		`X:` + fmt.Sprintf("%v", this.X) + `,`,
		`Y:` + fmt.Sprintf("%v", this.Y) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Method:` + fmt.Sprintf("%v", this.Method) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CorrelationSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CorrelationSpec{`,
		`Cutoff:` + valueToStringGenerated(this.Cutoff) + `,`,
		`Method:` + valueToStringGenerated(this.Method) + `,`,
		`Top:` + valueToStringGenerated(this.Top) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CsvFileSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CsvFileSpec{`,
		`Delimiter:` + valueToStringGenerated(this.Delimiter) + `,`,
		`QuoteChar:` + fmt.Sprintf("%v", this.QuoteChar) + `,`,
		`EscapeChar:` + fmt.Sprintf("%v", this.EscapeChar) + `,`,
		`CommentChars:` + valueToStringGenerated(this.CommentChars) + `,`,
		`Header:` + valueToStringGenerated(this.Header) + `,`,
		`SkipRows:` + valueToStringGenerated(this.SkipRows) + `,`,
		`NullValues:` + valueToStringGenerated(this.NullValues) + `,`,
		`Encoding:` + valueToStringGenerated(this.Encoding) + `,`,
		`MaxRows:` + valueToStringGenerated(this.MaxRows) + `,`,
		`Strict:` + valueToStringGenerated(this.Strict) + `,`,
		`Compression:` + valueToStringGenerated(this.Compression) + `,`,
		`HasIndexColumn:` + valueToStringGenerated(this.HasIndexColumn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataInputSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataInputSpec{`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha1.DataLocation", 1) + `,`,
		`Format:` + strings.Replace(strings.Replace(this.Format.String(), "FlatFileFormatSpec", "FlatFileFormatSpec", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataOutputSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataOutputSpec{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha1.DataLocation", 1) + `,`,
		`Format:` + valueToStringGenerated(this.Format) + `,`,
		`Action:` + valueToStringGenerated(this.Action) + `,`,
		`CreateTableIfNotExist:` + valueToStringGenerated(this.CreateTableIfNotExist) + `,`,
		`IncludeFeatures:` + valueToStringGenerated(this.IncludeFeatures) + `,`,
		`IncludeShapValues:` + valueToStringGenerated(this.IncludeShapValues) + `,`,
		`DetectOutliers:` + valueToStringGenerated(this.DetectOutliers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataPipeline) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataPipeline{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "DataPipelineSpec", "DataPipelineSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "DataPipelineStatus", "DataPipelineStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataPipelineList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]DataPipeline{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "DataPipeline", "DataPipeline", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&DataPipelineList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataPipelineRun) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataPipelineRun{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "DataPipelineRunSpec", "DataPipelineRunSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "DataPipelineRunStatus", "DataPipelineRunStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataPipelineRunCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataPipelineRunCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataPipelineRunList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]DataPipelineRun{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "DataPipelineRun", "DataPipelineRun", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&DataPipelineRunList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataPipelineRunSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataPipelineRunSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`DataPipelineName:` + valueToStringGenerated(this.DataPipelineName) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "ResourceSpec", "v1alpha1.ResourceSpec", 1), `&`, ``, 1) + `,`,
		`Priority:` + valueToStringGenerated(this.Priority) + `,`,
		`Paused:` + valueToStringGenerated(this.Paused) + `,`,
		`Aborted:` + valueToStringGenerated(this.Aborted) + `,`,
		`LabRef:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LabRef), "ObjectReference", "v11.ObjectReference", 1), `&`, ``, 1) + `,`,
		`ModelClassName:` + valueToStringGenerated(this.ModelClassName) + `,`,
		`ModelClassRunName:` + valueToStringGenerated(this.ModelClassRunName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataPipelineRunStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&DataPipelineRunStatus{`,
		`RecipeRuns:` + fmt.Sprintf("%v", this.RecipeRuns) + `,`,
		`Output:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Output), "DataLocation", "v1alpha1.DataLocation", 1), `&`, ``, 1) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`CompletedAt:` + strings.Replace(fmt.Sprintf("%v", this.CompletedAt), "Time", "v1.Time", 1) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`FailureReason:` + valueToStringGenerated(this.FailureReason) + `,`,
		`FailureMessage:` + valueToStringGenerated(this.FailureMessage) + `,`,
		`Progress:` + valueToStringGenerated(this.Progress) + `,`,
		`Logs:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Logs), "Logs", "v1alpha1.Logs", 1), `&`, ``, 1) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Time", "v1.Time", 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRecipes := "[]RecipePartSpec{"
	for _, f := range this.Recipes {
		repeatedStringForRecipes += strings.Replace(strings.Replace(f.String(), "RecipePartSpec", "RecipePartSpec", 1), `&`, ``, 1) + ","
	}
	repeatedStringForRecipes += "}"
	keysForDatasetSelector := make([]string, 0, len(this.DatasetSelector))
	for k := range this.DatasetSelector {
		keysForDatasetSelector = append(keysForDatasetSelector, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDatasetSelector)
	mapStringForDatasetSelector := "map[string]string{"
	for _, k := range keysForDatasetSelector {
		mapStringForDatasetSelector += fmt.Sprintf("%v: %v,", k, this.DatasetSelector[k])
	}
	mapStringForDatasetSelector += "}"
	s := strings.Join([]string{`&DataPipelineSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`ModelClassName:` + valueToStringGenerated(this.ModelClassName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`DatasetSelector:` + mapStringForDatasetSelector + `,`,
		`Recipes:` + repeatedStringForRecipes + `,`,
		`Output:` + strings.Replace(strings.Replace(this.Output.String(), "DataOutputSpec", "DataOutputSpec", 1), `&`, ``, 1) + `,`,
		`Schedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Schedule), "RunSchedule", "v1alpha1.RunSchedule", 1), `&`, ``, 1) + `,`,
		`Notification:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Notification), "NotificationSpec", "v1alpha1.NotificationSpec", 1), `&`, ``, 1) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "ResourceSpec", "v1alpha1.ResourceSpec", 1), `&`, ``, 1) + `,`,
		`Priority:` + valueToStringGenerated(this.Priority) + `,`,
		`Paused:` + valueToStringGenerated(this.Paused) + `,`,
		`TTL:` + valueToStringGenerated(this.TTL) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataPipelineStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&DataPipelineStatus{`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Time", "v1.Time", 1) + `,`,
		`Schedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Schedule), "RunScheduleStatus", "v1alpha1.RunScheduleStatus", 1), `&`, ``, 1) + `,`,
		`LastRunName:` + fmt.Sprintf("%v", this.LastRunName) + `,`,
		`RunsCount:` + fmt.Sprintf("%v", this.RunsCount) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataProduct) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataProduct{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "DataProductSpec", "DataProductSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "DataProductStatus", "DataProductStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataProductList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]DataProduct{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "DataProduct", "DataProduct", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&DataProductList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataProductSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataProductSpec{`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`Public:` + valueToStringGenerated(this.Public) + `,`,
		`TenantRef:` + strings.Replace(fmt.Sprintf("%v", this.TenantRef), "ObjectReference", "v11.ObjectReference", 1) + `,`,
		`GitLocation:` + strings.Replace(strings.Replace(this.GitLocation.String(), "GitLocation", "GitLocation", 1), `&`, ``, 1) + `,`,
		`CacheBucketName:` + fmt.Sprintf("%v", this.CacheBucketName) + `,`,
		`DefaultLabName:` + valueToStringGenerated(this.DefaultLabName) + `,`,
		`DefaultServingSiteName:` + valueToStringGenerated(this.DefaultServingSiteName) + `,`,
		`DefaultBucketName:` + valueToStringGenerated(this.DefaultBucketName) + `,`,
		`Task:` + valueToStringGenerated(this.Task) + `,`,
		`SubTask:` + valueToStringGenerated(this.SubTask) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`Notification:` + strings.Replace(fmt.Sprintf("%v", this.Notification), "NotificationSpec", "v1alpha1.NotificationSpec", 1) + `,`,
		`DefaultTrainingResources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.DefaultTrainingResources), "ResourceSpec", "v1alpha1.ResourceSpec", 1), `&`, ``, 1) + `,`,
		`DefaultServingResources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.DefaultServingResources), "ResourceSpec", "v1alpha1.ResourceSpec", 1), `&`, ``, 1) + `,`,
		`DefaultPriority:` + valueToStringGenerated(this.DefaultPriority) + `,`,
		`Color:` + valueToStringGenerated(this.Color) + `,`,
		`Approval:` + strings.Replace(this.Approval.String(), "ApprovalSpec", "ApprovalSpec", 1) + `,`,
		`Permissions:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Permissions), "PermissionsSpec", "v1alpha1.PermissionsSpec", 1), `&`, ``, 1) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataProductStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&DataProductStatus{`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Time", "v1.Time", 1) + `,`,
		`DatasourcesCount:` + fmt.Sprintf("%v", this.DatasourcesCount) + `,`,
		`DatasetsCount:` + fmt.Sprintf("%v", this.DatasetsCount) + `,`,
		`DataPipelinesCount:` + fmt.Sprintf("%v", this.DataPipelinesCount) + `,`,
		`DataPipelineRunsCount:` + fmt.Sprintf("%v", this.DataPipelineRunsCount) + `,`,
		`StudiesCount:` + fmt.Sprintf("%v", this.StudiesCount) + `,`,
		`ModelsCount:` + fmt.Sprintf("%v", this.ModelsCount) + `,`,
		`PredictorsCount:` + fmt.Sprintf("%v", this.PredictorsCount) + `,`,
		`DataAppsCount:` + fmt.Sprintf("%v", this.DataAppsCount) + `,`,
		`PredictionsCount:` + fmt.Sprintf("%v", this.PredictionsCount) + `,`,
		`InfoAlertsCount:` + fmt.Sprintf("%v", this.InfoAlertsCount) + `,`,
		`ErrorsAlertsCount:` + fmt.Sprintf("%v", this.ErrorsAlertsCount) + `,`,
		`ModelClassesCount:` + fmt.Sprintf("%v", this.ModelClassesCount) + `,`,
		`FailureReason:` + valueToStringGenerated(this.FailureReason) + `,`,
		`FailureMessage:` + valueToStringGenerated(this.FailureMessage) + `,`,
		`BaselineVersion:` + valueToStringGenerated(this.BaselineVersion) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataProductVersion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataProductVersion{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "DataProductVersionSpec", "DataProductVersionSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "DataProductVersionStatus", "DataProductVersionStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataProductVersionList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]DataProductVersion{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "DataProductVersion", "DataProductVersion", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&DataProductVersionList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataProductVersionSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataProductVersionSpec{`,
		`ProductRef:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ProductRef), "ObjectReference", "v11.ObjectReference", 1), `&`, ``, 1) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`PrevVersionName:` + valueToStringGenerated(this.PrevVersionName) + `,`,
		`Baseline:` + valueToStringGenerated(this.Baseline) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataProductVersionStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&DataProductVersionStatus{`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Time", "v1.Time", 1) + `,`,
		`FailureReason:` + valueToStringGenerated(this.FailureReason) + `,`,
		`FailureMessage:` + valueToStringGenerated(this.FailureMessage) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSource) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSource{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "DataSourceSpec", "DataSourceSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "DataSourceStatus", "DataSourceStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSourceList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]DataSource{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "DataSource", "DataSource", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&DataSourceList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSourceSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRelationships := "[]RelationshipSpec{"
	for _, f := range this.Relationships {
		repeatedStringForRelationships += strings.Replace(strings.Replace(f.String(), "RelationshipSpec", "RelationshipSpec", 1), `&`, ``, 1) + ","
	}
	repeatedStringForRelationships += "}"
	s := strings.Join([]string{`&DataSourceSpec{`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`VersionName:` + fmt.Sprintf("%v", this.VersionName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`DatasetType:` + valueToStringGenerated(this.DatasetType) + `,`,
		`Schema:` + strings.Replace(strings.Replace(this.Schema.String(), "Schema", "Schema", 1), `&`, ``, 1) + `,`,
		`FlatFile:` + strings.Replace(this.FlatFile.String(), "FlatFileFormatSpec", "FlatFileFormatSpec", 1) + `,`,
		`Labeled:` + valueToStringGenerated(this.Labeled) + `,`,
		`Sample:` + strings.Replace(strings.Replace(this.Sample.String(), "SampleSpec", "SampleSpec", 1), `&`, ``, 1) + `,`,
		`Task:` + fmt.Sprintf("%v", this.Task) + `,`,
		`SubTask:` + valueToStringGenerated(this.SubTask) + `,`,
		`Relationships:` + repeatedStringForRelationships + `,`,
		`Labeling:` + strings.Replace(strings.Replace(this.Labeling.String(), "LabelingSpec", "LabelingSpec", 1), `&`, ``, 1) + `,`,
		`InferredFrom:` + strings.Replace(fmt.Sprintf("%v", this.InferredFrom), "DataLocation", "v1alpha1.DataLocation", 1) + `,`,
		`UnitTestsTemplate:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.UnitTestsTemplate), "TestSuite", "v1alpha1.TestSuite", 1), `&`, ``, 1) + `,`,
		`IngestMethod:` + valueToStringGenerated(this.IngestMethod) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSourceStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&DataSourceStatus{`,
		`Cols:` + fmt.Sprintf("%v", this.Cols) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`LastDatasetCreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.LastDatasetCreatedAt), "Time", "v1.Time", 1) + `,`,
		`LastDatasetName:` + fmt.Sprintf("%v", this.LastDatasetName) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Time", "v1.Time", 1) + `,`,
		`FailureReason:` + valueToStringGenerated(this.FailureReason) + `,`,
		`FailureMessage:` + valueToStringGenerated(this.FailureMessage) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *Dataset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Dataset{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "DatasetSpec", "DatasetSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "DatasetStatus", "DatasetStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DatasetGroupByStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForWorkerResults := "[]WorkerRunResult{"
	for _, f := range this.WorkerResults {
		repeatedStringForWorkerResults += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForWorkerResults += "}"
	s := strings.Join([]string{`&DatasetGroupByStatus{`,
		`DatasetsURI:` + fmt.Sprintf("%v", this.DatasetsURI) + `,`,
		`ProfilesURI:` + fmt.Sprintf("%v", this.ProfilesURI) + `,`,
		`ReportsURI:` + fmt.Sprintf("%v", this.ReportsURI) + `,`,
		`UnitTestsURI:` + fmt.Sprintf("%v", this.UnitTestsURI) + `,`,
		`WorkerResults:` + repeatedStringForWorkerResults + `,`,
		`}`,
	}, "")
	return s
}
func (this *DatasetList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]Dataset{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "Dataset", "Dataset", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&DatasetList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *DatasetSnapshot) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DatasetSnapshot{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "DatasetSnapshotSpec", "DatasetSnapshotSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "DatasetSnapshotStatus", "DatasetSnapshotStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DatasetSnapshotList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]DatasetSnapshot{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "DatasetSnapshot", "DatasetSnapshot", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&DatasetSnapshotList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *DatasetSnapshotSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DatasetSnapshotSpec{`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`DatasetName:` + fmt.Sprintf("%v", this.DatasetName) + `,`,
		`Timeout:` + valueToStringGenerated(this.Timeout) + `,`,
		`Pause:` + valueToStringGenerated(this.Pause) + `,`,
		`Abort:` + valueToStringGenerated(this.Abort) + `,`,
		`ModelClassRunName:` + valueToStringGenerated(this.ModelClassRunName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DatasetSnapshotStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&DatasetSnapshotStatus{`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`DatasetManifestLocation:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.DatasetManifestLocation), "ManifestLocation", "v1alpha1.ManifestLocation", 1), `&`, ``, 1) + `,`,
		`DataSourceManifestLocation:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.DataSourceManifestLocation), "ManifestLocation", "v1alpha1.ManifestLocation", 1), `&`, ``, 1) + `,`,
		`SnapshotVersion:` + fmt.Sprintf("%v", this.SnapshotVersion) + `,`,
		`Statistics:` + strings.Replace(strings.Replace(this.Statistics.String(), "DatasetStatistics", "DatasetStatistics", 1), `&`, ``, 1) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`ReportName:` + fmt.Sprintf("%v", this.ReportName) + `,`,
		`DataLocation:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.DataLocation), "FileLocation", "v1alpha1.FileLocation", 1), `&`, ``, 1) + `,`,
		`ReportLocation:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ReportLocation), "FileLocation", "v1alpha1.FileLocation", 1), `&`, ``, 1) + `,`,
		`ProfileLocation:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ProfileLocation), "FileLocation", "v1alpha1.FileLocation", 1), `&`, ``, 1) + `,`,
		`AnomaliesLocation:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.AnomaliesLocation), "FileLocation", "v1alpha1.FileLocation", 1), `&`, ``, 1) + `,`,
		`SampleLocation:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.SampleLocation), "FileLocation", "v1alpha1.FileLocation", 1), `&`, ``, 1) + `,`,
		`Imbalanced:` + fmt.Sprintf("%v", this.Imbalanced) + `,`,
		`UnitTestResults:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.UnitTestResults), "TestSuiteResult", "v1alpha1.TestSuiteResult", 1), `&`, ``, 1) + `,`,
		`FailureMessage:` + valueToStringGenerated(this.FailureMessage) + `,`,
		`Progress:` + fmt.Sprintf("%v", this.Progress) + `,`,
		`Logs:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Logs), "Logs", "v1alpha1.Logs", 1), `&`, ``, 1) + `,`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Time", "v1.Time", 1) + `,`,
		`CompletedAt:` + strings.Replace(fmt.Sprintf("%v", this.CompletedAt), "Time", "v1.Time", 1) + `,`,
		`LastStudyAt:` + strings.Replace(fmt.Sprintf("%v", this.LastStudyAt), "Time", "v1.Time", 1) + `,`,
		`Images:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Images), "Images", "v1alpha1.Images", 1), `&`, ``, 1) + `,`,
		`FeatureHistogramRef:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.FeatureHistogramRef), "ObjectReference", "v11.ObjectReference", 1), `&`, ``, 1) + `,`,
		`GroupBy:` + strings.Replace(strings.Replace(this.GroupBy.String(), "DatasetGroupByStatus", "DatasetGroupByStatus", 1), `&`, ``, 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *DatasetSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DatasetSpec{`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`DataSourceName:` + fmt.Sprintf("%v", this.DataSourceName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`Run:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Run), "RunSpec", "v1alpha1.RunSpec", 1), `&`, ``, 1) + `,`,
		`Schedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Schedule), "RunSchedule", "v1alpha1.RunSchedule", 1), `&`, ``, 1) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`Task:` + fmt.Sprintf("%v", this.Task) + `,`,
		`SubTask:` + valueToStringGenerated(this.SubTask) + `,`,
		`Type:` + valueToStringGenerated(this.Type) + `,`,
		`Origin:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Origin), "DataLocation", "v1alpha1.DataLocation", 1), `&`, ``, 1) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "ResourceSpec", "v1alpha1.ResourceSpec", 1), `&`, ``, 1) + `,`,
		`UnitTests:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.UnitTests), "TestSuite", "v1alpha1.TestSuite", 1), `&`, ``, 1) + `,`,
		`Report:` + valueToStringGenerated(this.Report) + `,`,
		`UnitTest:` + valueToStringGenerated(this.UnitTest) + `,`,
		`GenerateFeatureHistogram:` + valueToStringGenerated(this.GenerateFeatureHistogram) + `,`,
		`Fast:` + valueToStringGenerated(this.Fast) + `,`,
		`ArtifactBucketName:` + valueToStringGenerated(this.ArtifactBucketName) + `,`,
		`Sample:` + strings.Replace(this.Sample.String(), "SampleSpec", "SampleSpec", 1) + `,`,
		`Synthetic:` + strings.Replace(this.Synthetic.String(), "SyntheticSpec", "SyntheticSpec", 1) + `,`,
		`Correlation:` + strings.Replace(this.Correlation.String(), "CorrelationSpec", "CorrelationSpec", 1) + `,`,
		`LabRef:` + strings.Replace(fmt.Sprintf("%v", this.LabRef), "ObjectReference", "v11.ObjectReference", 1) + `,`,
		`GroupBy:` + strings.Replace(this.GroupBy.String(), "GroupBySpec", "GroupBySpec", 1) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`ModelClassName:` + valueToStringGenerated(this.ModelClassName) + `,`,
		`FeatureGroupName:` + valueToStringGenerated(this.FeatureGroupName) + `,`,
		`Notification:` + strings.Replace(fmt.Sprintf("%v", this.Notification), "NotificationSpec", "v1alpha1.NotificationSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DatasetStatistics) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFeatures := "[]FeatureStatistics{"
	for _, f := range this.Features {
		repeatedStringForFeatures += strings.Replace(strings.Replace(f.String(), "FeatureStatistics", "FeatureStatistics", 1), `&`, ``, 1) + ","
	}
	repeatedStringForFeatures += "}"
	repeatedStringForCorrelationsWithTarget := "[]Correlation{"
	for _, f := range this.CorrelationsWithTarget {
		repeatedStringForCorrelationsWithTarget += strings.Replace(strings.Replace(f.String(), "Correlation", "Correlation", 1), `&`, ``, 1) + ","
	}
	repeatedStringForCorrelationsWithTarget += "}"
	repeatedStringForTopCorrelations := "[]Correlation{"
	for _, f := range this.TopCorrelations {
		repeatedStringForTopCorrelations += strings.Replace(strings.Replace(f.String(), "Correlation", "Correlation", 1), `&`, ``, 1) + ","
	}
	repeatedStringForTopCorrelations += "}"
	s := strings.Join([]string{`&DatasetStatistics{`,
		`Features:` + repeatedStringForFeatures + `,`,
		`Rows:` + fmt.Sprintf("%v", this.Rows) + `,`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`SizeInBytes:` + fmt.Sprintf("%v", this.SizeInBytes) + `,`,
		`CorrelationsWithTarget:` + repeatedStringForCorrelationsWithTarget + `,`,
		`TopCorrelations:` + repeatedStringForTopCorrelations + `,`,
		`}`,
	}, "")
	return s
}
func (this *DatasetStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForActive := "[]RunReference{"
	for _, f := range this.Active {
		repeatedStringForActive += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForActive += "}"
	repeatedStringForAvailableSnapshots := "[]RunReference{"
	for _, f := range this.AvailableSnapshots {
		repeatedStringForAvailableSnapshots += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForAvailableSnapshots += "}"
	repeatedStringForConditions := "[]Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&DatasetStatus{`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`Active:` + repeatedStringForActive + `,`,
		`LastSnapshotVersion:` + fmt.Sprintf("%v", this.LastSnapshotVersion) + `,`,
		`AvailableSnapshots:` + repeatedStringForAvailableSnapshots + `,`,
		`LastSnapshotAt:` + strings.Replace(fmt.Sprintf("%v", this.LastSnapshotAt), "Time", "v1.Time", 1) + `,`,
		`LastFailureMessage:` + valueToStringGenerated(this.LastFailureMessage) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Time", "v1.Time", 1) + `,`,
		`Schedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Schedule), "RunScheduleStatus", "v1alpha1.RunScheduleStatus", 1), `&`, ``, 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *DriftThreshold) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DriftThreshold{`,
		`Metric:` + fmt.Sprintf("%v", this.Metric) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Entity) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Entity{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "EntitySpec", "EntitySpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "EntityStatus", "EntityStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EntityList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]Entity{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "Entity", "Entity", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&EntityList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *EntitySpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EntitySpec{`,
		`TenantRef:` + strings.Replace(fmt.Sprintf("%v", this.TenantRef), "ObjectReference", "v11.ObjectReference", 1) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`JoinKey:` + fmt.Sprintf("%v", this.JoinKey) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EntityStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&EntityStatus{`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Time", "v1.Time", 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExcelNotebookSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExcelNotebookSpec{`,
		`FirstSheetWithData:` + valueToStringGenerated(this.FirstSheetWithData) + `,`,
		`SheetName:` + valueToStringGenerated(this.SheetName) + `,`,
		`SheetIndex:` + valueToStringGenerated(this.SheetIndex) + `,`,
		`ColumnNamesRow:` + valueToStringGenerated(this.ColumnNamesRow) + `,`,
		`Data:` + strings.Replace(strings.Replace(this.Data.String(), "ExcelSheetArea", "ExcelSheetArea", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExcelSheetArea) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExcelSheetArea{`,
		`EntireSheet:` + valueToStringGenerated(this.EntireSheet) + `,`,
		`FromColumn:` + valueToStringGenerated(this.FromColumn) + `,`,
		`ToColumn:` + valueToStringGenerated(this.ToColumn) + `,`,
		`FromRow:` + valueToStringGenerated(this.FromRow) + `,`,
		`ToRow:` + valueToStringGenerated(this.ToRow) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeatureGroup{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "FeatureGroupSpec", "FeatureGroupSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "FeatureGroupStatus", "FeatureGroupStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureGroupList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]FeatureGroup{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "FeatureGroup", "FeatureGroup", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&FeatureGroupList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureGroupSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeatureGroupSpec{`,
		`TenantRef:` + strings.Replace(fmt.Sprintf("%v", this.TenantRef), "ObjectReference", "v11.ObjectReference", 1) + `,`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`ArtifactBucketName:` + valueToStringGenerated(this.ArtifactBucketName) + `,`,
		`IngestType:` + valueToStringGenerated(this.IngestType) + `,`,
		`EntityName:` + fmt.Sprintf("%v", this.EntityName) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`IngestSchedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.IngestSchedule), "RunSchedule", "v1alpha1.RunSchedule", 1), `&`, ``, 1) + `,`,
		`SyncSchedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.SyncSchedule), "RunSchedule", "v1alpha1.RunSchedule", 1), `&`, ``, 1) + `,`,
		`FlatFile:` + strings.Replace(this.FlatFile.String(), "FlatFileFormatSpec", "FlatFileFormatSpec", 1) + `,`,
		`Schema:` + strings.Replace(strings.Replace(this.Schema.String(), "Schema", "Schema", 1), `&`, ``, 1) + `,`,
		`Tests:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Tests), "TestSuite", "v1alpha1.TestSuite", 1), `&`, ``, 1) + `,`,
		`Location:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha1.DataLocation", 1), `&`, ``, 1) + `,`,
		`TimeColumn:` + valueToStringGenerated(this.TimeColumn) + `,`,
		`TimeColumnFormat:` + valueToStringGenerated(this.TimeColumnFormat) + `,`,
		`KeyColumn:` + valueToStringGenerated(this.KeyColumn) + `,`,
		`Materialization:` + strings.Replace(strings.Replace(this.Materialization.String(), "MaterializationSpec", "MaterializationSpec", 1), `&`, ``, 1) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "ResourceSpec", "v1alpha1.ResourceSpec", 1), `&`, ``, 1) + `,`,
		`LabRef:` + strings.Replace(fmt.Sprintf("%v", this.LabRef), "ObjectReference", "v11.ObjectReference", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureGroupStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&FeatureGroupStatus{`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Time", "v1.Time", 1) + `,`,
		`Rows:` + fmt.Sprintf("%v", this.Rows) + `,`,
		`IngestSchedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.IngestSchedule), "RunScheduleStatus", "v1alpha1.RunScheduleStatus", 1), `&`, ``, 1) + `,`,
		`SyncSchedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.SyncSchedule), "RunScheduleStatus", "v1alpha1.RunScheduleStatus", 1), `&`, ``, 1) + `,`,
		`OnlineTable:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.OnlineTable), "DataLocation", "v1alpha1.DataLocation", 1), `&`, ``, 1) + `,`,
		`OnlineTableCreated:` + strings.Replace(fmt.Sprintf("%v", this.OnlineTableCreated), "Time", "v1.Time", 1) + `,`,
		`IngestDatasetName:` + fmt.Sprintf("%v", this.IngestDatasetName) + `,`,
		`FailureReason:` + valueToStringGenerated(this.FailureReason) + `,`,
		`FailureMessage:` + valueToStringGenerated(this.FailureMessage) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureHistogram) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeatureHistogram{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "FeatureHistogramSpec", "FeatureHistogramSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "FeatureHistogramStatus", "FeatureHistogramStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureHistogramList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]FeatureHistogram{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "FeatureHistogram", "FeatureHistogram", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&FeatureHistogramList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureHistogramSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDriftThresholds := "[]DriftThreshold{"
	for _, f := range this.DriftThresholds {
		repeatedStringForDriftThresholds += strings.Replace(strings.Replace(f.String(), "DriftThreshold", "DriftThreshold", 1), `&`, ``, 1) + ","
	}
	repeatedStringForDriftThresholds += "}"
	s := strings.Join([]string{`&FeatureHistogramSpec{`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`VersionName:` + fmt.Sprintf("%v", this.VersionName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`SourceRef:` + strings.Replace(fmt.Sprintf("%v", this.SourceRef), "ObjectReference", "v11.ObjectReference", 1) + `,`,
		`Training:` + valueToStringGenerated(this.Training) + `,`,
		`Live:` + valueToStringGenerated(this.Live) + `,`,
		`Start:` + strings.Replace(fmt.Sprintf("%v", this.Start), "Time", "v1.Time", 1) + `,`,
		`End:` + strings.Replace(fmt.Sprintf("%v", this.End), "Time", "v1.Time", 1) + `,`,
		`BaseRef:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.BaseRef), "ObjectReference", "v11.ObjectReference", 1), `&`, ``, 1) + `,`,
		`DriftThresholds:` + repeatedStringForDriftThresholds + `,`,
		`SyncIntervalSec:` + valueToStringGenerated(this.SyncIntervalSec) + `,`,
		`UnitTests:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.UnitTests), "TestSuite", "v1alpha1.TestSuite", 1), `&`, ``, 1) + `,`,
		`GenUnitTests:` + valueToStringGenerated(this.GenUnitTests) + `,`,
		`FeatureFilter:` + fmt.Sprintf("%v", this.FeatureFilter) + `,`,
		`ReferenceType:` + fmt.Sprintf("%v", this.ReferenceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureHistogramStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForColumns := "[]ColumnHistogram{"
	for _, f := range this.Columns {
		repeatedStringForColumns += strings.Replace(strings.Replace(f.String(), "ColumnHistogram", "ColumnHistogram", 1), `&`, ``, 1) + ","
	}
	repeatedStringForColumns += "}"
	repeatedStringForConditions := "[]Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&FeatureHistogramStatus{`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`Columns:` + repeatedStringForColumns + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Time", "v1.Time", 1) + `,`,
		`Logs:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Logs), "Logs", "v1alpha1.Logs", 1), `&`, ``, 1) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`FailureReason:` + fmt.Sprintf("%v", this.FailureReason) + `,`,
		`FailureMessage:` + fmt.Sprintf("%v", this.FailureMessage) + `,`,
		`UnitTestsResult:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.UnitTestsResult), "TestSuiteResult", "v1alpha1.TestSuiteResult", 1), `&`, ``, 1) + `,`,
		`Total:` + fmt.Sprintf("%v", this.Total) + `,`,
		`Errors:` + fmt.Sprintf("%v", this.Errors) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureStatistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeatureStatistics{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DataType:` + fmt.Sprintf("%v", this.DataType) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Distinct:` + fmt.Sprintf("%v", this.Distinct) + `,`,
		`Missing:` + fmt.Sprintf("%v", this.Missing) + `,`,
		`PercentMissing:` + fmt.Sprintf("%v", this.PercentMissing) + `,`,
		`Mean:` + fmt.Sprintf("%v", this.Mean) + `,`,
		`StdDev:` + fmt.Sprintf("%v", this.StdDev) + `,`,
		`Variance:` + fmt.Sprintf("%v", this.Variance) + `,`,
		`Min:` + fmt.Sprintf("%v", this.Min) + `,`,
		`Max:` + fmt.Sprintf("%v", this.Max) + `,`,
		`Kurtosis:` + fmt.Sprintf("%v", this.Kurtosis) + `,`,
		`Skewness:` + fmt.Sprintf("%v", this.Skewness) + `,`,
		`Sum:` + fmt.Sprintf("%v", this.Sum) + `,`,
		`Mad:` + fmt.Sprintf("%v", this.Mad) + `,`,
		`P25:` + fmt.Sprintf("%v", this.P25) + `,`,
		`P50:` + fmt.Sprintf("%v", this.P50) + `,`,
		`P75:` + fmt.Sprintf("%v", this.P75) + `,`,
		`IQR:` + fmt.Sprintf("%v", this.IQR) + `,`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`Zeros:` + fmt.Sprintf("%v", this.Zeros) + `,`,
		`Invalid:` + fmt.Sprintf("%v", this.Invalid) + `,`,
		`Importance:` + fmt.Sprintf("%v", this.Importance) + `,`,
		`Target:` + fmt.Sprintf("%v", this.Target) + `,`,
		`Ignore:` + fmt.Sprintf("%v", this.Ignore) + `,`,
		`Nullable:` + fmt.Sprintf("%v", this.Nullable) + `,`,
		`HighCardinality:` + fmt.Sprintf("%v", this.HighCardinality) + `,`,
		`HighCorrWithOtherFeatures:` + fmt.Sprintf("%v", this.HighCorrWithOtherFeatures) + `,`,
		`LowCorrWithTarget:` + fmt.Sprintf("%v", this.LowCorrWithTarget) + `,`,
		`HighMissingPct:` + fmt.Sprintf("%v", this.HighMissingPct) + `,`,
		`Skewed:` + fmt.Sprintf("%v", this.Skewed) + `,`,
		`Constant:` + fmt.Sprintf("%v", this.Constant) + `,`,
		`Duplicate:` + fmt.Sprintf("%v", this.Duplicate) + `,`,
		`Reserved:` + fmt.Sprintf("%v", this.Reserved) + `,`,
		`Completeness:` + fmt.Sprintf("%v", this.Completeness) + `,`,
		`DistinctValueCount:` + fmt.Sprintf("%v", this.DistinctValueCount) + `,`,
		`MostFreqValuesRatio:` + fmt.Sprintf("%v", this.MostFreqValuesRatio) + `,`,
		`Histogram:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Histogram), "HistogramData", "v1alpha1.HistogramData", 1), `&`, ``, 1) + `,`,
		`CorrToTarget:` + fmt.Sprintf("%v", this.CorrToTarget) + `,`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Outliers:` + strings.Replace(strings.Replace(this.Outliers.String(), "OutlierStatistics", "OutlierStatistics", 1), `&`, ``, 1) + `,`,
		`Values:` + fmt.Sprintf("%v", this.Values) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlatFileFormatSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlatFileFormatSpec{`,
		`FileType:` + valueToStringGenerated(this.FileType) + `,`,
		`Csv:` + strings.Replace(strings.Replace(this.Csv.String(), "CsvFileSpec", "CsvFileSpec", 1), `&`, ``, 1) + `,`,
		`Excel:` + strings.Replace(strings.Replace(this.Excel.String(), "ExcelNotebookSpec", "ExcelNotebookSpec", 1), `&`, ``, 1) + `,`,
		`Parquet:` + strings.Replace(strings.Replace(this.Parquet.String(), "ParquetFileSpec", "ParquetFileSpec", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GaugeSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GaugeSpec{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Column:` + valueToStringGenerated(this.Column) + `,`,
		`Row:` + valueToStringGenerated(this.Row) + `,`,
		`Scalar:` + valueToStringGenerated(this.Scalar) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GitLocation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GitLocation{`,
		`GitConnectionName:` + valueToStringGenerated(this.GitConnectionName) + `,`,
		`URL:` + valueToStringGenerated(this.URL) + `,`,
		`Branch:` + valueToStringGenerated(this.Branch) + `,`,
		`Private:` + valueToStringGenerated(this.Private) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GroupBySpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GroupBySpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`GroupBy:` + fmt.Sprintf("%v", this.GroupBy) + `,`,
		`Frequency:` + valueToStringGenerated(this.Frequency) + `,`,
		`Interval:` + valueToStringGenerated(this.Interval) + `,`,
		`Aggregate:` + fmt.Sprintf("%v", this.Aggregate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GroupDatasetLocationStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GroupDatasetLocationStatus{`,
		`GroupsRoot:` + valueToStringGenerated(this.GroupsRoot) + `,`,
		`GroupRoot:` + valueToStringGenerated(this.GroupRoot) + `,`,
		`GroupDataFolder:` + valueToStringGenerated(this.GroupDataFolder) + `,`,
		`GroupDataIndex:` + valueToStringGenerated(this.GroupDataIndex) + `,`,
		`GroupProfileFolder:` + valueToStringGenerated(this.GroupProfileFolder) + `,`,
		`GroupReportIndex:` + valueToStringGenerated(this.GroupReportIndex) + `,`,
		`GroupFeaturesFile:` + valueToStringGenerated(this.GroupFeaturesFile) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HistogramSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HistogramSpec{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`X:` + valueToStringGenerated(this.X) + `,`,
		`Bins:` + valueToStringGenerated(this.Bins) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageLocation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageLocation{`,
		`Name:` + valueToStringGenerated(this.Name) + `,`,
		`RegistryConnectionName:` + valueToStringGenerated(this.RegistryConnectionName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KPI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KPI{`,
		`Name:` + valueToStringGenerated(this.Name) + `,`,
		`Value:` + valueToStringGenerated(this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelingRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelingRule{`,
		`Column:` + fmt.Sprintf("%v", this.Column) + `,`,
		`Operator:` + fmt.Sprintf("%v", this.Operator) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelingSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPositive := "[]LabelingRule{"
	for _, f := range this.Positive {
		repeatedStringForPositive += strings.Replace(strings.Replace(f.String(), "LabelingRule", "LabelingRule", 1), `&`, ``, 1) + ","
	}
	repeatedStringForPositive += "}"
	repeatedStringForNegative := "[]LabelingRule{"
	for _, f := range this.Negative {
		repeatedStringForNegative += strings.Replace(strings.Replace(f.String(), "LabelingRule", "LabelingRule", 1), `&`, ``, 1) + ","
	}
	repeatedStringForNegative += "}"
	s := strings.Join([]string{`&LabelingSpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`ResultColumn:` + fmt.Sprintf("%v", this.ResultColumn) + `,`,
		`Positive:` + repeatedStringForPositive + `,`,
		`Negative:` + repeatedStringForNegative + `,`,
		`}`,
	}, "")
	return s
}
func (this *LineChartSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LineChartSpec{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`X:` + valueToStringGenerated(this.X) + `,`,
		`Y:` + valueToStringGenerated(this.Y) + `,`,
		`Legend:` + valueToStringGenerated(this.Legend) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MaterializationSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MaterializationSpec{`,
		`Online:` + valueToStringGenerated(this.Online) + `,`,
		`Offline:` + valueToStringGenerated(this.Offline) + `,`,
		`StartDate:` + strings.Replace(fmt.Sprintf("%v", this.StartDate), "Time", "v1.Time", 1) + `,`,
		`OfflineTTL:` + valueToStringGenerated(this.OfflineTTL) + `,`,
		`OnlineTTL:` + valueToStringGenerated(this.OnlineTTL) + `,`,
		`Backfill:` + valueToStringGenerated(this.Backfill) + `,`,
		`Schedule:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Schedule), "RunSchedule", "v1alpha1.RunSchedule", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricSpec{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Column:` + valueToStringGenerated(this.Column) + `,`,
		`Row:` + valueToStringGenerated(this.Row) + `,`,
		`Scalar:` + valueToStringGenerated(this.Scalar) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OutlierStatistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OutlierStatistics{`,
		`Lower:` + fmt.Sprintf("%v", this.Lower) + `,`,
		`Upper:` + fmt.Sprintf("%v", this.Upper) + `,`,
		`Percent:` + fmt.Sprintf("%v", this.Percent) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PageSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRows := "[]RowSpec{"
	for _, f := range this.Rows {
		repeatedStringForRows += strings.Replace(strings.Replace(f.String(), "RowSpec", "RowSpec", 1), `&`, ``, 1) + ","
	}
	repeatedStringForRows += "}"
	s := strings.Join([]string{`&PageSpec{`,
		`Rows:` + repeatedStringForRows + `,`,
		`}`,
	}, "")
	return s
}
func (this *ParquetFileSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ParquetFileSpec{`,
		`Engine:` + valueToStringGenerated(this.Engine) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Recipe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Recipe{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "RecipeSpec", "RecipeSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "RecipeStatus", "RecipeStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecipeInputSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecipeInputSpec{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha1.DataLocation", 1) + `,`,
		`Format:` + valueToStringGenerated(this.Format) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecipeList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]Recipe{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "Recipe", "Recipe", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&RecipeList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecipeOutputSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecipeOutputSpec{`,
		`CreateDataset:` + valueToStringGenerated(this.CreateDataset) + `,`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha1.DataLocation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecipePartSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecipePartSpec{`,
		`RecipeName:` + valueToStringGenerated(this.RecipeName) + `,`,
		`Dependents:` + fmt.Sprintf("%v", this.Dependents) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecipeRun) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecipeRun{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "RecipeRunSpec", "RecipeRunSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "RecipeRunStatus", "RecipeRunStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecipeRunList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]RecipeRun{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "RecipeRun", "RecipeRun", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&RecipeRunList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecipeRunSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecipeRunSpec{`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`RecipeName:` + valueToStringGenerated(this.RecipeName) + `,`,
		`LabRef:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LabRef), "ObjectReference", "v11.ObjectReference", 1), `&`, ``, 1) + `,`,
		`Location:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Location), "DataLocation", "v1alpha1.DataLocation", 1), `&`, ``, 1) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "ResourceSpec", "v1alpha1.ResourceSpec", 1), `&`, ``, 1) + `,`,
		`TTL:` + valueToStringGenerated(this.TTL) + `,`,
		`ModelClassName:` + valueToStringGenerated(this.ModelClassName) + `,`,
		`ModelClassRunName:` + valueToStringGenerated(this.ModelClassRunName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecipeRunStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&RecipeRunStatus{`,
		`CompletedAt:` + strings.Replace(fmt.Sprintf("%v", this.CompletedAt), "Time", "v1.Time", 1) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`FailureReason:` + valueToStringGenerated(this.FailureReason) + `,`,
		`FailureMessage:` + valueToStringGenerated(this.FailureMessage) + `,`,
		`TriggeredBy:` + fmt.Sprintf("%v", this.TriggeredBy) + `,`,
		`Logs:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Logs), "Logs", "v1alpha1.Logs", 1), `&`, ``, 1) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Time", "v1.Time", 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecipeSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSteps := "[]RecipeStep{"
	for _, f := range this.Steps {
		repeatedStringForSteps += strings.Replace(strings.Replace(f.String(), "RecipeStep", "RecipeStep", 1), `&`, ``, 1) + ","
	}
	repeatedStringForSteps += "}"
	s := strings.Join([]string{`&RecipeSpec{`,
		`Owner:` + valueToStringGenerated(this.Owner) + `,`,
		`VersionName:` + valueToStringGenerated(this.VersionName) + `,`,
		`Description:` + valueToStringGenerated(this.Description) + `,`,
		`Input:` + strings.Replace(strings.Replace(this.Input.String(), "RecipeInputSpec", "RecipeInputSpec", 1), `&`, ``, 1) + `,`,
		`Steps:` + repeatedStringForSteps + `,`,
		`Output:` + strings.Replace(strings.Replace(this.Output.String(), "RecipeOutputSpec", "RecipeOutputSpec", 1), `&`, ``, 1) + `,`,
		`Sample:` + strings.Replace(strings.Replace(this.Sample.String(), "SampleSpec", "SampleSpec", 1), `&`, ``, 1) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "ResourceSpec", "v1alpha1.ResourceSpec", 1), `&`, ``, 1) + `,`,
		`Timeout:` + valueToStringGenerated(this.Timeout) + `,`,
		`TTL:` + valueToStringGenerated(this.TTL) + `,`,
		`UnitTestsTemplate:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.UnitTestsTemplate), "TestSuite", "v1alpha1.TestSuite", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecipeStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&RecipeStatus{`,
		`ObservedGeneration:` + fmt.Sprintf("%v", this.ObservedGeneration) + `,`,
		`LastRun:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LastRun), "LastRunStatus", "v1alpha1.LastRunStatus", 1), `&`, ``, 1) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Time", "v1.Time", 1) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecipeStep) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParameters := "[]*RecipeStepParam{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(f.String(), "RecipeStepParam", "RecipeStepParam", 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&RecipeStep{`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecipeStepParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecipeStepParam{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecommendationSchema) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecommendationSchema{`,
		`UserIDColumn:` + valueToStringGenerated(this.UserIDColumn) + `,`,
		`ItemIDColumn:` + valueToStringGenerated(this.ItemIDColumn) + `,`,
		`RatingColumn:` + valueToStringGenerated(this.RatingColumn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RelationshipSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RelationshipSpec{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Column:` + fmt.Sprintf("%v", this.Column) + `,`,
		`Arity:` + valueToStringGenerated(this.Arity) + `,`,
		`RelatesTo:` + fmt.Sprintf("%v", this.RelatesTo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RowSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCols := "[]ColumnSpec{"
	for _, f := range this.Cols {
		repeatedStringForCols += strings.Replace(strings.Replace(f.String(), "ColumnSpec", "ColumnSpec", 1), `&`, ``, 1) + ","
	}
	repeatedStringForCols += "}"
	s := strings.Join([]string{`&RowSpec{`,
		`Cols:` + repeatedStringForCols + `,`,
		`}`,
	}, "")
	return s
}
func (this *SampleSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SampleSpec{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Rows:` + valueToStringGenerated(this.Rows) + `,`,
		`Percent:` + valueToStringGenerated(this.Percent) + `,`,
		`Filter:` + valueToStringGenerated(this.Filter) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScatterPlotSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScatterPlotSpec{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`X:` + valueToStringGenerated(this.X) + `,`,
		`Y:` + valueToStringGenerated(this.Y) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Schema) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForColumns := "[]Column{"
	for _, f := range this.Columns {
		repeatedStringForColumns += strings.Replace(strings.Replace(f.String(), "Column", "Column", 1), `&`, ``, 1) + ","
	}
	repeatedStringForColumns += "}"
	s := strings.Join([]string{`&Schema{`,
		`TimeSeriesSchema:` + strings.Replace(strings.Replace(this.TimeSeriesSchema.String(), "TimeSeriesSchema", "TimeSeriesSchema", 1), `&`, ``, 1) + `,`,
		`RecommendationSchema:` + strings.Replace(strings.Replace(this.RecommendationSchema.String(), "RecommendationSchema", "RecommendationSchema", 1), `&`, ``, 1) + `,`,
		`Columns:` + repeatedStringForColumns + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyntheticSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SyntheticSpec{`,
		`Enabled:` + valueToStringGenerated(this.Enabled) + `,`,
		`Rows:` + valueToStringGenerated(this.Rows) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TableSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TableSpec{`,
		`DatasetName:` + valueToStringGenerated(this.DatasetName) + `,`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Filters:` + fmt.Sprintf("%v", this.Filters) + `,`,
		`GroupBy:` + fmt.Sprintf("%v", this.GroupBy) + `,`,
		`Rows:` + valueToStringGenerated(this.Rows) + `,`,
		`ShowIndex:` + valueToStringGenerated(this.ShowIndex) + `,`,
		`Border:` + valueToStringGenerated(this.Border) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimeSeriesSchema) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TimeSeriesSchema{`,
		`Type:` + valueToStringGenerated(this.Type) + `,`,
		`Freq:` + valueToStringGenerated(this.Freq) + `,`,
		`Interval:` + valueToStringGenerated(this.Interval) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGenerated(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ApprovalReviewStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalReviewStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalReviewStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reviewer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reviewer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = ApprovalType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovedAt == nil {
				m.ApprovedAt = &v1.Time{}
			}
			if err := m.ApprovedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := DecisionType(dAtA[iNdEx:postIndex])
			m.DecisionType = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reviewers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reviewers = append(m.Reviewers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = ApprovalType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reviews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reviews = append(m.Reviews, ApprovalReviewStatus{})
			if err := m.Reviews[len(m.Reviews)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BarChartSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BarChartSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BarChartSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.X = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Y = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Legend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Legend = &b
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Sort = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DisplayName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataType = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.DataType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.DataDomain(dAtA[iNdEx:postIndex])
			m.Format = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ignore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Ignore = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Target = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Nullable = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PK", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PK = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FK", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FK = &b
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleOf", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultipleOf = &v
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maximum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Maximum = &v2
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMaximum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ExclusiveMaximum = &b
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Minimum = &v2
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ExclusiveMinimum = &b
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxLength = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLength", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinLength = &v
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Pattern = &s
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Required = &b
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Example", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Example = &s
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalDocs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ExternalDocs = &s
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enum = append(m.Enum, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItems", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxItems = &v
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinItems", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinItems = &v
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueItems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UniqueItems = &b
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PII", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PII = &b
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PHI", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PHI = &b
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Protected = &b
		case 32:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValueNum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DefaultValueNum = &v2
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Log = &b
		case 34:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mu", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Mu = &v2
		case 35:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sigma", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Sigma = &v2
		case 36:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkewThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.SkewThreshold = &v2
		case 37:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriftThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DriftThreshold = &v2
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Key = &b
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fold", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Fold = &b
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Weight = &b
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reserved = &b
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imputation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Imputation(dAtA[iNdEx:postIndex])
			m.Imputation = &s
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scaling", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Scaling(dAtA[iNdEx:postIndex])
			m.Scaling = &s
			iNdEx = postIndex
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Generated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Generated = &b
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Formula", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Formula = &s
			iNdEx = postIndex
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ID = &b
		case 47:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Step = &v2
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loc", wireType)
			}
			m.Loc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Loc |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTimeFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DateTimeFormat = &s
			iNdEx = postIndex
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSeries", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TimeSeries = &b
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regressor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Regressor = &b
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaggedRegressor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaggedRegressor = &b
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TimeIndex = &b
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Aggregate(dAtA[iNdEx:postIndex])
			m.Aggr = &s
			iNdEx = postIndex
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Window", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Window = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnHistogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnHistogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnHistogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Histogram", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Histogram.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, v1alpha1.Measurement{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drift", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Drift = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spacer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Spacer = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Width = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Title = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SubTitle = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Footer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Footer = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComponentView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ComponentView.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComponentView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComponentView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComponentView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metric == nil {
				m.Metric = &MetricSpec{}
			}
			if err := m.Metric.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gauge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gauge == nil {
				m.Gauge = &GaugeSpec{}
			}
			if err := m.Gauge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Histogram", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Histogram == nil {
				m.Histogram = &HistogramSpec{}
			}
			if err := m.Histogram.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Table == nil {
				m.Table = &TableSpec{}
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineChart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LineChart == nil {
				m.LineChart = &LineChartSpec{}
			}
			if err := m.LineChart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BarChart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BarChart == nil {
				m.BarChart = &BarChartSpec{}
			}
			if err := m.BarChart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScatterChart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScatterChart == nil {
				m.ScatterChart = &ScatterPlotSpec{}
			}
			if err := m.ScatterChart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Correlation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Correlation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Correlation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Y = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorrelationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorrelationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorrelationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cutoff", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Cutoff = &v2
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Method = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Top", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Top = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CsvFileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CsvFileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CsvFileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delimiter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := Delimiter(dAtA[iNdEx:postIndex])
			m.Delimiter = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteChar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteChar = QuoteChar(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscapeChar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscapeChar = EscapeChar(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommentChars", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CommentChars = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Header = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipRows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipRows = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NullValues = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.FileEncoding(dAtA[iNdEx:postIndex])
			m.Encoding = &s
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxRows = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Strict = &b
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Compression = &s
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasIndexColumn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HasIndexColumn = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataInputSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataInputSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataInputSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha1.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Format.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataOutputSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataOutputSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataOutputSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha1.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := FlatFileType(dAtA[iNdEx:postIndex])
			m.Format = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.UpdateStrategy(dAtA[iNdEx:postIndex])
			m.Action = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTableIfNotExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CreateTableIfNotExist = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeFeatures", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IncludeFeatures = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeShapValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IncludeShapValues = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectOutliers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DetectOutliers = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataPipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataPipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataPipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataPipelineList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataPipelineList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataPipelineList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, DataPipeline{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataPipelineRun) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataPipelineRun: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataPipelineRun: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataPipelineRunCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataPipelineRunCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataPipelineRunCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = DataPipelineRunConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataPipelineRunList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataPipelineRunList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataPipelineRunList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, DataPipelineRun{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataPipelineRunSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataPipelineRunSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataPipelineRunSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPipelineName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DataPipelineName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.PriorityLevel(dAtA[iNdEx:postIndex])
			m.Priority = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Paused = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aborted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Aborted = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LabRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelClassName = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelClassRunName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelClassRunName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataPipelineRunStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataPipelineRunStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataPipelineRunStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeRuns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipeRuns = append(m.RecipeRuns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = DataPipelineRunPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedAt == nil {
				m.CompletedAt = &v1.Time{}
			}
			if err := m.CompletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.StatusError(dAtA[iNdEx:postIndex])
			m.FailureReason = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FailureMessage = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Progress = &v
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Logs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &v1.Time{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, v1.Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelClassName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatasetSelector == nil {
				m.DatasetSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DatasetSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipes = append(m.Recipes, RecipePartSpec{})
			if err := m.Recipes[len(m.Recipes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Notification.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.PriorityLevel(dAtA[iNdEx:postIndex])
			m.Priority = &s
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Paused = &b
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TTL = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataPipelineStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataPipelineStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataPipelineStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &v1.Time{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRunName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastRunName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunsCount", wireType)
			}
			m.RunsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, v1.Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataProduct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProduct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProduct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataProductList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProductList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProductList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, DataProduct{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataProductSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProductSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProductSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Public = &b
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TenantRef == nil {
				m.TenantRef = &v11.ObjectReference{}
			}
			if err := m.TenantRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GitLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheBucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheBucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultLabName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DefaultLabName = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultServingSiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DefaultServingSiteName = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DefaultBucketName = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.MLTask(dAtA[iNdEx:postIndex])
			m.Task = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.MLSubtask(dAtA[iNdEx:postIndex])
			m.SubTask = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Notification == nil {
				m.Notification = &v1alpha1.NotificationSpec{}
			}
			if err := m.Notification.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTrainingResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DefaultTrainingResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultServingResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DefaultServingResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultPriority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.PriorityLevel(dAtA[iNdEx:postIndex])
			m.DefaultPriority = &s
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Color(dAtA[iNdEx:postIndex])
			m.Color = &s
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Approval == nil {
				m.Approval = &ApprovalSpec{}
			}
			if err := m.Approval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataProductStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProductStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProductStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &v1.Time{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasourcesCount", wireType)
			}
			m.DatasourcesCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatasourcesCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetsCount", wireType)
			}
			m.DatasetsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatasetsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPipelinesCount", wireType)
			}
			m.DataPipelinesCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataPipelinesCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPipelineRunsCount", wireType)
			}
			m.DataPipelineRunsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataPipelineRunsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudiesCount", wireType)
			}
			m.StudiesCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StudiesCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelsCount", wireType)
			}
			m.ModelsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictorsCount", wireType)
			}
			m.PredictorsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PredictorsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataAppsCount", wireType)
			}
			m.DataAppsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataAppsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictionsCount", wireType)
			}
			m.PredictionsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PredictionsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoAlertsCount", wireType)
			}
			m.InfoAlertsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfoAlertsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorsAlertsCount", wireType)
			}
			m.ErrorsAlertsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorsAlertsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelClassesCount", wireType)
			}
			m.ModelClassesCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelClassesCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.StatusError(dAtA[iNdEx:postIndex])
			m.FailureReason = &s
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FailureMessage = &s
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaselineVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BaselineVersion = &s
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, v1.Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataProductVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProductVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProductVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataProductVersionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProductVersionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProductVersionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, DataProductVersion{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataProductVersionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProductVersionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProductVersionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProductRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevVersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PrevVersionName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baseline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Baseline = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataProductVersionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProductVersionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProductVersionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &v1.Time{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.StatusError(dAtA[iNdEx:postIndex])
			m.FailureReason = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FailureMessage = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, v1.Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSourceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSourceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSourceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, DataSource{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSourceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSourceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSourceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.DatasetType(dAtA[iNdEx:postIndex])
			m.DatasetType = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlatFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlatFile == nil {
				m.FlatFile = &FlatFileFormatSpec{}
			}
			if err := m.FlatFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labeled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Labeled = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sample", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Sample.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.MLTask(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.MLSubtask(dAtA[iNdEx:postIndex])
			m.SubTask = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relationships", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relationships = append(m.Relationships, RelationshipSpec{})
			if err := m.Relationships[len(m.Relationships)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labeling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Labeling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferredFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InferredFrom == nil {
				m.InferredFrom = &v1alpha1.DataLocation{}
			}
			if err := m.InferredFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTestsTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnitTestsTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.FeatureStoreIngestType(dAtA[iNdEx:postIndex])
			m.IngestMethod = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSourceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSourceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSourceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDatasetCreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastDatasetCreatedAt == nil {
				m.LastDatasetCreatedAt = &v1.Time{}
			}
			if err := m.LastDatasetCreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastDatasetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &v1.Time{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.StatusError(dAtA[iNdEx:postIndex])
			m.FailureReason = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FailureMessage = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, v1.Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dataset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dataset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dataset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatasetGroupByStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatasetGroupByStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatasetGroupByStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetsURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetsURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfilesURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfilesURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportsURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportsURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTestsURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitTestsURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerResults = append(m.WorkerResults, v1alpha1.WorkerRunResult{})
			if err := m.WorkerResults[len(m.WorkerResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatasetList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatasetList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatasetList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Dataset{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatasetSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatasetSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatasetSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatasetSnapshotList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatasetSnapshotList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatasetSnapshotList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, DatasetSnapshot{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatasetSnapshotSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatasetSnapshotSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatasetSnapshotSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pause", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Pause = &b
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Abort = &b
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelClassRunName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelClassRunName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatasetSnapshotStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatasetSnapshotStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatasetSnapshotStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetManifestLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DatasetManifestLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceManifestLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DataSourceManifestLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotVersion", wireType)
			}
			m.SnapshotVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotVersion |= github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Version(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statistics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Statistics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = DatasetSnapshotPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DataLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReportLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProfileLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomaliesLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AnomaliesLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SampleLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imbalanced", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Imbalanced = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTestResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnitTestResults.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FailureMessage = &s
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Logs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &v1.Time{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedAt == nil {
				m.CompletedAt = &v1.Time{}
			}
			if err := m.CompletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastStudyAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastStudyAt == nil {
				m.LastStudyAt = &v1.Time{}
			}
			if err := m.LastStudyAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Images.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureHistogramRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeatureHistogramRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GroupBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, v1.Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatasetSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatasetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatasetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataSourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Run", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Run.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = DatasetRole(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.MLTask(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.MLSubtask(dAtA[iNdEx:postIndex])
			m.SubTask = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.DatasetType(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Origin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnitTests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Report = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UnitTest = &b
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateFeatureHistogram", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.GenerateFeatureHistogram = &b
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Fast = &b
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactBucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ArtifactBucketName = &s
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sample", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sample == nil {
				m.Sample = &SampleSpec{}
			}
			if err := m.Sample.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Synthetic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Synthetic == nil {
				m.Synthetic = &SyntheticSpec{}
			}
			if err := m.Synthetic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Correlation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Correlation == nil {
				m.Correlation = &CorrelationSpec{}
			}
			if err := m.Correlation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabRef == nil {
				m.LabRef = &v11.ObjectReference{}
			}
			if err := m.LabRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupBy == nil {
				m.GroupBy = &GroupBySpec{}
			}
			if err := m.GroupBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelClassName = &s
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureGroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FeatureGroupName = &s
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Notification == nil {
				m.Notification = &v1alpha1.NotificationSpec{}
			}
			if err := m.Notification.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatasetStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatasetStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatasetStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Features = append(m.Features, FeatureStatistics{})
			if err := m.Features[len(m.Features)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			m.Columns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Columns |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeInBytes", wireType)
			}
			m.SizeInBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeInBytes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrelationsWithTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CorrelationsWithTarget = append(m.CorrelationsWithTarget, Correlation{})
			if err := m.CorrelationsWithTarget[len(m.CorrelationsWithTarget)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopCorrelations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopCorrelations = append(m.TopCorrelations, Correlation{})
			if err := m.TopCorrelations[len(m.TopCorrelations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatasetStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatasetStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatasetStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Active = append(m.Active, v1alpha1.RunReference{})
			if err := m.Active[len(m.Active)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSnapshotVersion", wireType)
			}
			m.LastSnapshotVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSnapshotVersion |= github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Version(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableSnapshots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailableSnapshots = append(m.AvailableSnapshots, v1alpha1.RunReference{})
			if err := m.AvailableSnapshots[len(m.AvailableSnapshots)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSnapshotAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSnapshotAt == nil {
				m.LastSnapshotAt = &v1.Time{}
			}
			if err := m.LastSnapshotAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastFailureMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LastFailureMessage = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &v1.Time{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, v1.Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DriftThreshold) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DriftThreshold: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DriftThreshold: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Metric(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntityList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Entity{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntitySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntitySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntitySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TenantRef == nil {
				m.TenantRef = &v11.ObjectReference{}
			}
			if err := m.TenantRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JoinKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntityStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &v1.Time{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, v1.Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExcelNotebookSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExcelNotebookSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExcelNotebookSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstSheetWithData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FirstSheetWithData = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SheetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SheetName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SheetIndex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SheetIndex = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNamesRow", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ColumnNamesRow = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExcelSheetArea) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExcelSheetArea: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExcelSheetArea: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntireSheet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.EntireSheet = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromColumn", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FromColumn = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToColumn", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ToColumn = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromRow", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FromRow = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToRow", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ToRow = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureGroupList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureGroupList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureGroupList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, FeatureGroup{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureGroupSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureGroupSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureGroupSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TenantRef == nil {
				m.TenantRef = &v11.ObjectReference{}
			}
			if err := m.TenantRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactBucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ArtifactBucketName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.FeatureStoreIngestType(dAtA[iNdEx:postIndex])
			m.IngestType = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestSchedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IngestSchedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncSchedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SyncSchedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlatFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlatFile == nil {
				m.FlatFile = &FlatFileFormatSpec{}
			}
			if err := m.FlatFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TimeColumn = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeColumnFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TimeColumnFormat = &s
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.KeyColumn = &s
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Materialization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Materialization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabRef == nil {
				m.LabRef = &v11.ObjectReference{}
			}
			if err := m.LabRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureGroupStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureGroupStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureGroupStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = FeatureGroupPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &v1.Time{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestSchedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IngestSchedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncSchedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SyncSchedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnlineTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineTableCreated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnlineTableCreated == nil {
				m.OnlineTableCreated = &v1.Time{}
			}
			if err := m.OnlineTableCreated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestDatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngestDatasetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.StatusError(dAtA[iNdEx:postIndex])
			m.FailureReason = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FailureMessage = &s
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, v1.Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureHistogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureHistogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureHistogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureHistogramList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureHistogramList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureHistogramList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, FeatureHistogram{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureHistogramSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureHistogramSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureHistogramSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceRef == nil {
				m.SourceRef = &v11.ObjectReference{}
			}
			if err := m.SourceRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Training", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Training = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Live = &b
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &v1.Time{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &v1.Time{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriftThresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriftThresholds = append(m.DriftThresholds, DriftThreshold{})
			if err := m.DriftThresholds[len(m.DriftThresholds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncIntervalSec", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SyncIntervalSec = &v
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnitTests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenUnitTests", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.GenUnitTests = &b
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeatureFilter = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.FeatureFilterType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceType = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.ReferenceDataType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureHistogramStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureHistogramStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureHistogramStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, ColumnHistogram{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &v1.Time{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Logs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = FeatureHistogramPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailureReason = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.StatusError(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailureMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTestsResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnitTestsResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			m.Errors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errors |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, v1.Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataType = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.DataType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Count = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distinct", wireType)
			}
			m.Distinct = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Distinct |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Missing", wireType)
			}
			m.Missing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Missing |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentMissing", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PercentMissing = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mean", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mean = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdDev", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.StdDev = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Variance = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Min = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Max = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kurtosis", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Kurtosis = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skewness", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Skewness = float64(math.Float64frombits(v))
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			m.Sum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mad", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mad = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P25", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P25 = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P50", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P50 = float64(math.Float64frombits(v))
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P75", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P75 = float64(math.Float64frombits(v))
		case 19:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IQR", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.IQR = float64(math.Float64frombits(v))
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zeros", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Zeros = float64(math.Float64frombits(v))
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invalid", wireType)
			}
			m.Invalid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Invalid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Importance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Importance = float64(math.Float64frombits(v))
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Target = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ignore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ignore = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighCardinality", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HighCardinality = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighCorrWithOtherFeatures", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HighCorrWithOtherFeatures = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowCorrWithTarget", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LowCorrWithTarget = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighMissingPct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HighMissingPct = bool(v != 0)
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skewed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Skewed = bool(v != 0)
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constant", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Constant = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duplicate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Duplicate = bool(v != 0)
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reserved = bool(v != 0)
		case 37:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completeness", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Completeness = float64(math.Float64frombits(v))
		case 38:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistinctValueCount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DistinctValueCount = float64(math.Float64frombits(v))
		case 39:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MostFreqValuesRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MostFreqValuesRatio = float64(math.Float64frombits(v))
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Histogram", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Histogram.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrToTarget", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CorrToTarget = float64(math.Float64frombits(v))
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outliers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Outliers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlatFileFormatSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlatFileFormatSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlatFileFormatSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := FlatFileType(dAtA[iNdEx:postIndex])
			m.FileType = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Csv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Excel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Excel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parquet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parquet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GaugeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GaugeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GaugeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Column = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Row", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Row = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scalar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Scalar = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitConnectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GitConnectionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.URL = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Branch = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Private", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Private = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupBySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupBySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupBySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Frequency(dAtA[iNdEx:postIndex])
			m.Frequency = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Interval = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregate = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Aggregate(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupDatasetLocationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupDatasetLocationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupDatasetLocationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupsRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GroupsRoot = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GroupRoot = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupDataFolder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GroupDataFolder = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupDataIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GroupDataIndex = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupProfileFolder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GroupProfileFolder = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupReportIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GroupReportIndex = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupFeaturesFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GroupFeaturesFile = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistogramSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistogramSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistogramSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.X = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bins", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bins = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistryConnectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RegistryConnectionName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Value = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelingRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelingRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelingRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Column = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Op(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultColumn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positive = append(m.Positive, LabelingRule{})
			if err := m.Positive[len(m.Positive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Negative", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Negative = append(m.Negative, LabelingRule{})
			if err := m.Negative[len(m.Negative)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LineChartSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LineChartSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LineChartSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.X = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Y = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Legend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Legend = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaterializationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaterializationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Online = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Offline = &b
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartDate == nil {
				m.StartDate = &v1.Time{}
			}
			if err := m.StartDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfflineTTL", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OfflineTTL = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineTTL", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlineTTL = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backfill", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Backfill = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Column = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Row", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Row = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scalar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Scalar = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutlierStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutlierStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutlierStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			m.Lower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			m.Upper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upper |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Percent = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, RowSpec{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParquetFileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParquetFileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParquetFileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Engine = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Recipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Recipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Recipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecipeInputSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecipeInputSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecipeInputSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha1.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := FlatFileType(dAtA[iNdEx:postIndex])
			m.Format = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecipeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecipeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecipeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Recipe{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecipeOutputSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecipeOutputSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecipeOutputSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDataset", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CreateDataset = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &v1alpha1.DataLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecipePartSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecipePartSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecipePartSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RecipeName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependents", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dependents = append(m.Dependents, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecipeRun) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecipeRun: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecipeRun: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecipeRunList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecipeRunList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecipeRunList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, RecipeRun{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecipeRunSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecipeRunSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecipeRunSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RecipeName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LabRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TTL = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelClassName = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelClassRunName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelClassRunName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecipeRunStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecipeRunStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecipeRunStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedAt == nil {
				m.CompletedAt = &v1.Time{}
			}
			if err := m.CompletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = RecipeRunPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.StatusError(dAtA[iNdEx:postIndex])
			m.FailureReason = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FailureMessage = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggeredBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggeredBy = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.TriggerType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Logs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &v1.Time{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, v1.Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecipeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecipeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecipeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, RecipeStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sample", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Sample.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TTL = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTestsTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnitTestsTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecipeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecipeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecipeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRun", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastRun.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &v1.Time{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, v1.Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecipeStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecipeStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecipeStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = RecipeStepOperation(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &RecipeStepParam{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecipeStepParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecipeStepParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecipeStepParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendationSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendationSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendationSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIDColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UserIDColumn = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIDColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ItemIDColumn = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatingColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RatingColumn = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationshipSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationshipSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationshipSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Column = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.RelationshipArity(dAtA[iNdEx:postIndex])
			m.Arity = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatesTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatesTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, ColumnSpec{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.SamplingType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rows = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Percent = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Filter = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScatterPlotSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScatterPlotSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScatterPlotSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.X = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Y = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSeriesSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeSeriesSchema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendationSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecommendationSchema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyntheticSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyntheticSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyntheticSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rows = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatasetName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rows = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ShowIndex = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Border", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Border = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeSeriesSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeSeriesSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeSeriesSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.TimeSeriesType(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Freq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := github_com_metaprov_modelaapi_pkg_apis_catalog_v1alpha1.Frequency(dAtA[iNdEx:postIndex])
			m.Freq = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Interval = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenerated(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenerated
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenerated
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenerated
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenerated        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenerated          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenerated = fmt.Errorf("proto: unexpected end of group")
)
