/**
*
* Copyright (C) 2017 modela authors
* For license information, see LICENSE.txt
*/
// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "github.com/metaprov/modelaapi/pkg/apis/catalog/v1alpha1";

message AccessSpec {
  // The port number that will be exposed on the Predictor's Pods to serve prediction traffic through the GRPCInferenceService API.
  // The Kubernetes Service created by the Predictor will expose the port and forward GRPC traffic to the backend pods
  // +kubebuilder:validation:Optional
  // +kubebuilder:validation:Minimum=1024
  // +kubebuilder:validation:Maximum=65535
  // +kubebuilder:validation:Optional
  // +kubebuilder:default:=8080
  optional int32 port = 1;

  // The port number that will be exposed on the external address of every node on the cluster, in the case of the
  // Predictor's access type being NodePort. Traffic from the port will be forwarded to the Predictor's backend service
  // +kubebuilder:validation:Minimum=0
  // +kubebuilder:validation:Maximum=65535
  // +kubebuilder:validation:Optional
  optional int32 nodePort = 2;

  // The auto-generated DNS path where the Predictor service can be accessed. If the access type is ClusterIP, it will
  // be a cluster-internal DNS name (i.e. predictor.default-serving-site.svc.cluster.local). In the case of the Ingress
  // access type, it will be determined by the FQDN of the host ServingSite (i.e. predictor.default-serving-site.your-domain.ai).
  // +kubebuilder:validation:MaxLength=256
  // +kubebuilder:validation:Optional
  // +kubebuilder:default:=""
  optional string path = 3;

  // The Kubernetes-native access method which specifies how the Kubernetes Service created by the Predictor will be exposed.
  // See https://modela.ai/docs/docs/serving/production/#access-method for a detailed description of each access type
  // +kubebuilder:default:="cluster-ip"
  // +kubebuilder:validation:Optional
  optional string accessType = 4;

  // Indicates if the prediction service should expose an additional port to serve the Modela prediction API through HTTP.
  // The port one digit above the number specified by the Port field will be exposed to accept HTTP/1.1 traffic
  // +kubebuilder:default:=false
  // +kubebuilder:validation:Optional
  optional bool http = 5;

  // +kubebuilder:default:=none
  // +kubebuilder:validation:Optional
  optional string authMethod = 6;

  // ApiKeySecretRef references a Kubernetes Secret containing an API key that must be passed in prediction requests to the Predictor
  // +kubebuilder:validation:Optional
  optional k8s.io.api.core.v1.SecretReference apikeySecretRef = 7;
}

// AccountPermissions specifies the User Role Classes of an individual Account
message AccountPermissions {
  // The name of the Account receiving the permissions
  optional string accountName = 1;

  // Roles contains a list of User Role Classes that will be bound to the Account
  repeated k8s.io.api.core.v1.LocalObjectReference roles = 2;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:path=algorithms,singular=algorithm,shortName="alg",categories={catalog,modela,all}
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Framework",type="string",JSONPath=".spec.frameworkName",description="ML Framework name"
// +kubebuilder:printcolumn:name="Docs",type="string",JSONPath=".spec.url",description=""
// +kubebuilder:printcolumn:name="Task",type="string",JSONPath=".spec.task",description="ML task name"
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// Algorithm define the metadata about a machine learning algorithm.
message Algorithm {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional AlgorithmSpec spec = 2;
}

// +kubebuilder:object:root=true
// AlgorithmList contains a list of Algorithm
message AlgorithmList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Algorithm items = 2;
}

// AlgorithmSpec describes the attributes of an machine learning algorithm
message AlgorithmSpec {
  // FrameworkName is a reference to library
  // +kubebuilder:validation:Required
  // +required
  optional string frameworkName = 1;

  // Description is the description of the algorithm
  // +kubebuilder:default:=""
  // +kubebuilder:validation:Optional
  optional string description = 2;

  // URL is a url to the html page describing the algorithm
  // +kubebuilder:default:=""
  // +kubebuilder:validation:Optional
  optional string url = 3;

  // Task is the machine learning task (binary classification / regression)
  // +kubebuilder:validation:Optional
  repeated string tasks = 4;

  // Sparse indicate if this algorithm can deal with sparse data
  // +kubebuilder:default:=false
  // +kubebuilder:validation:Optional
  optional bool sparse = 5;

  // IntegerParameters is the list of integer hyper parameter ranges.
  // +kubebuilder:validation:Optional
  repeated ParameterRange ranges = 6;
}

// Cloud represent a cloud provider metadata. A cloud contains regions,datacenter,machine classes
message Cloud {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional CloudSpec spec = 2;

  // +optional
  optional CloudStatus status = 3;
}

// +kubebuilder:object:root=true
// CloudList contains a list of Cloud
message CloudList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Cloud items = 2;
}

// CloudSpec define the attribute of a single cloud provider (E.g. AWS)
message CloudSpec {
  // DefaultRegionName is the default region.
  // +kubebuilder:validation:Optional
  optional string defaultRegionName = 1;

  // DefaultMachineClassName is the default machine class. Used when allocating new machine on this provider
  // +kubebuilder:validation:Optional
  optional string defaultMachineClassName = 2;

  // DefaultGpuClassName is the default gpu class. Used when allocating new gpu on this provider
  // +kubebuilder:validation:Optional
  optional string defaultGpuClassName = 3;

  // MachineClasses defines the types of machines in this provider
  // +kubebuilder:validation:Optional
  repeated MachineClass machineClasses = 4;

  // GPUClasses define the type of GPUs offered by this provider
  // +kubebuilder:validation:Optional
  repeated GpuClass gpuClasses = 5;

  // Regions define the type of regions offered by this provider
  // +kubebuilder:validation:Optional
  repeated Region regions = 6;
}

// CloudStatus defines the observed state of Cloud.
message CloudStatus {
  // Machine cost is the costs of
  repeated MachineClassCost machineCosts = 1;

  // CostSpot is the spot cost of the machine class
  repeated GpuClassCost gpuCosts = 2;
}

// CompilerSpec is used when there is a specification for model compilation
message CompilerSpec {
  // Enable set the enable to
  // +kubebuilder:default:=false
  // +kubebuilder:validation:Optional
  optional bool enable = 1;

  // Set one or more targets
  // Enable set the enable to
  // +kubebuilder:default:="none"
  // +kubebuilder:validation:Optional
  optional string compiler = 2;

  // Set one or more targets for the compiler
  repeated string targets = 3;
}

message ConfusionMatrix {
  repeated ConfusionMatrixRow rows = 1;
}

message ConfusionMatrixRow {
  optional string t = 1;

  // True Label
  optional string p = 2;

  // Predicated Label
  optional int32 count = 3;

  optional double pct = 4;
}

// ContainerLog describes the location of logs for a single Job
message ContainerLog {
  // The name of the Job
  optional string job = 1;

  // The container name
  optional string container = 2;

  // The path to the log in the bucket
  optional string key = 3;

  // The bucket the log was stored in
  optional string bucket = 4;
}

// CronSchedule specifies the schedule for a Job to be executed
message CronSchedule {
  // Enabled indicates if the schedule is enabled. When enabled, a CronJob will be created which when triggered
  // will initiate the regeneration of the resource that specifies the schedule
  // +kubebuilder:default:=false
  // +kubebuilder:validation:Optional
  optional bool enabled = 1;

  // The cron string for the schedule, applicable if the trigger type is Cron.
  // See https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm for more information
  // +kubebuilder:validation:Optional
  optional string cron = 2;

  // The type of schedule, which can be a frequency interval or a cron expression
  // +kubebuilder:validation:Optional
  optional string type = 3;

  // The number of historical run records that the resource will maintain
  // +kubebuilder:default:=10
  // +kubebuilder:validation:Optional
  optional int32 maxRecords = 4;
}

message CurvePoint {
  optional double x = 1;

  optional double y = 2;
}

// Datacenter contains the attribute of a specific data center
message DataCenter {
  // Name is the name of the datacenter
  optional string name = 1;

  // Code is the code of the datacenter
  optional string code = 2;
}

// DataLocation describes the external location of data that will be accessed by Modela, and additional
// information on how to query the data if the location is a non flat-file source.
message DataLocation {
  // The type of location where the data resides, which can either be an object inside an object storage system (i.e. Minio), a SQL location
  // like a table or a view, a data stream (i.e. Kafka, currently unsupported), or a web location (currently unsupported)
  // +kubebuilder:default:="object"
  // +kubebuilder:validation:Optional
  optional string type = 1;

  // In the case of the type of location being a database, ConnectionName specifies the name of the ConnectionName resource
  // that exists in the same tenant as the resource specifying the DataLocation. Modela will attempt to connect
  // to the database using the credentials specified in the ConnectionName, and will execute the query specified by the SQL field
  // +kubebuilder:default:=""
  // +kubebuilder:validation:Optional
  optional string connectionName = 2;

  // In the case of the location type being an object storage system, BucketName is the name of the VirtualBucket resource
  // that exists in the same tenant as the resource specifying the DataLocation. Modela will connect to the external
  // object storage system, and will access the file from the path specified by the Path field
  // +kubebuilder:default:=""
  // +kubebuilder:validation:Optional
  optional string bucketName = 3;

  // The path to a flat-file inside an object storage system. When using the Modela API to upload files (through the
  // FileService API), Modela will upload the data to a predetermined path based on the Tenant, Data Product,
  // Data Product Version, and resource type of the resource in relation to the file being uploaded.
  // The path does not need to adhere to this format; you may also specify an arbitrary path
  // +kubebuilder:default:=""
  // +kubebuilder:validation:Optional
  optional string path = 4;

  // The name of a table inside a database, if applicable
  // +kubebuilder:default:=""
  // +kubebuilder:validation:Optional
  optional string table = 5;

  // The name of a database inside the database system specified by the ConnectionName field
  // +kubebuilder:default:=""
  // +kubebuilder:validation:Optional
  optional string database = 6;

  // The SQL statement which will be executed to query data from the table specified by Table
  // +kubebuilder:default:=""
  // +kubebuilder:validation:Optional
  optional string sql = 7;

  // The name of the streaming topic (currently unsupported)
  // +kubebuilder:default:=""
  // +kubebuilder:validation:Optional
  optional string topic = 8;

  // In the case of the location type being WebApi, URL specifies the external location (HTTP or Git) that will be queried
  // and then stored as flat-file by the resource which specifies the DataLocation
  // +kubebuilder:default:=""
  // +kubebuilder:validation:Optional
  optional string url = 9;

  // In the case of the location type being Dataset or PublicDataset, ResourceRef references another resource that
  // containing data that will be used as a data source
  // +kubebuilder:validation:Optional
  optional k8s.io.api.core.v1.ObjectReference resourceRef = 10;
}

message DataTestCase {
  // If false, this test case is disabled
  // +kubebuilder:validation:Optional
  optional bool enabled = 1;

  // The name of the test case, will be generate if empty by the combination of assertion, entity ref, column name and metric
  optional string name = 2;

  // The assertion type
  optional string assertThat = 3;

  // Reference to an entity.
  // +kubebuilder:validation:Optional
  optional k8s.io.api.core.v1.ObjectReference entityRef = 4;

  // Reference to another entity which is a ref.
  // +kubebuilder:validation:Optional
  optional k8s.io.api.core.v1.ObjectReference compareToRef = 5;

  // If unit test is column test, this is the name of the column
  // +kubebuilder:validation:Optional
  optional string column = 6;

  // The test type
  // The type of the data test
  optional string type = 7;

  // The metric that is used for the test
  // +kubebuilder:validation:Optional
  optional string metric = 8;

  // The expected numerical value
  // +kubebuilder:validation:Optional
  optional double expectedValue = 9;

  // The expected value
  // +kubebuilder:validation:Optional
  optional string expectedCategory = 10;

  // For range based tests.
  // +kubebuilder:validation:Format=float
  // +kubebuilder:validation:Optional
  optional double lower = 11;

  // +kubebuilder:validation:Format=float
  // +kubebuilder:validation:Optional
  optional double upper = 12;

  // Expected set of values,if the assertion
  // +kubebuilder:validation:Optional
  repeated string expectedSet = 13;

  // +kubebuilder:validation:Optional
  optional bool lowerInclusive = 14;

  // +kubebuilder:validation:Optional
  optional bool upperInclusive = 15;

  // Indicates if this validation rule was automatically generated by the system
  // +kubebuilder:validation:Optional
  optional bool generated = 16;

  // The test case tags, used for filtering.
  // Optional Test Tags
  repeated string tags = 17;

  // For test that involve two columns (e.g. correlation)
  // +kubebuilder:validation:Optional
  optional string column2 = 18;

  // Reference to an entity.
  // +kubebuilder:validation:Optional
  optional k8s.io.api.core.v1.ObjectReference entityRef2 = 19;

  // If unit test is column test, this is the name of the column
  // +kubebuilder:validation:Optional
  repeated string columns = 20;

  // Filter the filter for this unit test.
  // +kubebuilder:validation:Optional
  optional string featureFilter = 21;

  // Sql statement to filter the data for this unit test
  // +kubebuilder:validation:Optional
  optional string dataFilter = 22;

  // Set the reference type for this unit test
  // +kubebuilder:validation:Optional
  optional string referenceType = 23;

  // The length of the past if we are comparing to moving avg
  // +kubebuilder:validation:Optional
  optional int32 periods = 24;
}

// Result for a specific case
message DataTestCaseResult {
  // The test case name for this result.
  optional string name = 1;

  // Actual observation
  // +kubebuilder:validation:Optional
  optional Measurement actual = 2;

  // A failure occur on assertion failure
  // +kubebuilder:validation:Optional
  optional bool failure = 3;

  // An error occur if the system cannot execute the test case (e.g. connection error).
  // +kubebuilder:validation:Optional
  optional bool error = 4;

  // An optional
  // +kubebuilder:validation:Optional
  optional string failureMsg = 5;
}

// FileLocation denotes the location of a flat-file, which is the name of a VirtualBucket and the path within it
message FileLocation {
  optional string bucketName = 1;

  optional string path = 2;
}

// GithubEvents specify repo and the events to listen in order ot fire the pipeline
message GithubEvents {
  // The GitHub connections used to loginto git
  optional string gitConnectionName = 1;

  // Repository is the name of the github repository
  optional string repository = 2;

  // Branch is the name of the github branch.
  // By default, the trigger listen to all branch
  optional string branch = 3;

  // Blobname regex is a regular expression on the blob name that changed
  optional string blobNameRegex = 4;

  // Events is the name of the github events.
  repeated string events = 5;
}

// GpuClass define the specific for a machine type of a cloud provider
message GpuClass {
  // Code the the code of the gpu class within the data provider
  optional string code = 1;

  optional string regionName = 2;

  // Vcpu is the number of cores
  // +kubebuilder:validation:Minimum=0
  optional int32 vcpu = 3;

  // Gpumem is the amount of memory on the gpu
  optional k8s.io.apimachinery.pkg.api.resource.Quantity gpumem = 4;
}

// GpuClassCost contain the current cost of a gpu class in a region
message GpuClassCost {
  // Code is the machine class code
  optional string code = 1;

  optional string region = 2;

  // CostPerMinute is the cost per minute in dollar of the machine class
  optional k8s.io.apimachinery.pkg.api.resource.Quantity costPerMinute = 3;

  // CostSpot is the spot cost of the machine class
  optional k8s.io.apimachinery.pkg.api.resource.Quantity costSpot = 4;
}

// HistogramData contains the data to construct a histogram image
message HistogramData {
  // The bins if the histogram describes continous variables
  repeated double bins = 1;

  // The name of the categories, one per bin if this is a categorical histogram
  repeated string categories = 2;

  // The set of values per bin
  repeated double counts = 3;

  // The number of missing values
  // +kubebuilder:validation:Minimum=0
  optional int32 missing = 4;

  // The number of invalid values
  // +kubebuilder:validation:Minimum=0
  optional int32 invalid = 5;
}

// Images describes the Docker images used internally to perform workloads
message Images {
  // The image used during training
  // +kubebuilder:validation:Optional
  optional string trainerImage = 1;

  // The image used for data operations
  // +kubebuilder:validation:Optional
  optional string dataImage = 2;

  // The image used to deploy models
  // +kubebuilder:validation:Optional
  optional string publisherImage = 3;
}

// LastRunStatus describes the status of a single run for a run-based resource (such as a pipeline)
message LastRunStatus {
  // The name of the run
  optional string name = 1;

  // The status of the last run
  // +kubebuilder:validation:Optional
  optional string status = 2;

  // The time at which the run concluded
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time completedAt = 3;

  // The duration of the run in seconds
  // +kubebuilder:validation:Optional
  optional int32 duration = 4;

  // In the case of failure, the resource controller which created the run will set this field with a failure reason
  optional string failureReason = 5;

  // In the case of failure, the resource controller which created the run will set this field with a failure message
  optional string failureMessage = 6;
}

message Lib {
  optional string frameworks = 1;

  optional string version = 2;
}

// Logs describes the location of logs produced by workloads associated with a resource
message Logs {
  // The name of the Virtual Bucket resource where the logs are stored
  // +kubebuilder:validation:Optional
  optional string bucket = 1;

  // The collection of logs for each container of the workload
  // +kubebuilder:validation:Optional
  repeated ContainerLog containers = 2;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:path=mlframeworks,singular=mlframework,categories={catalog,modela,all}
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="URL",type="string",JSONPath=".spec.url"
// +kubebuilder:printcolumn:name="Version",type="string",JSONPath=".spec.version"
// +kubebuilder:printcolumn:name="Description",type="string",JSONPath=".spec.description"
// MLFramework define the metadata about a machine learning framework
message MLFramework {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional MLFrameworkSpec spec = 2;
}

// +kubebuilder:object:root=true
// MLFrameworkList contains a list of MLFramework
message MLFrameworkList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated MLFramework items = 2;
}

// MLFramework is the spec for a specific version of machine learning framework (e.g. tensorflow)
message MLFrameworkSpec {
  // URL for the home page of the mlframework
  // +kubebuilder:validation:Optional
  optional string url = 1;

  // Comments of the framework
  // +kubebuilder:default =""
  // +kubebuilder:validation:Optional
  optional string description = 2;

  // The current version of the mlframework
  // +kubebuilder:default =""
  // +kubebuilder:validation:Optional
  optional string version = 3;

  // Lang is the framework lang
  // +kubebuilder:validation:Optional
  optional string lang = 4;
}

// MachineClass define the specific for a machine type of cloud provider
message MachineClass {
  // Code the the code of the machine class within the data provider
  optional string code = 1;

  // +optional
  optional string regionName = 2;

  // Mem is the amount of memory on this machine
  // +optional
  optional k8s.io.apimachinery.pkg.api.resource.Quantity mem = 3;

  // Vcpu is the number of virtual cpus on this machine
  // +kubebuilder:validation:Minimum=0
  // +optional
  optional int32 vcpu = 4;

  // Storage is the amount of storage on this machine class
  // +optional
  optional string storage = 5;
}

// MachineClassCost contain the current cost of a machine class in a region
message MachineClassCost {
  // Code is the machine class code
  optional string code = 1;

  // Region is the code of the region
  optional string region = 2;

  // CostPerMinute is the cost per minute in dollar of the machine class
  optional k8s.io.apimachinery.pkg.api.resource.Quantity costPerMinute = 3;

  // CostSpot is the spot cost of the machine class
  optional k8s.io.apimachinery.pkg.api.resource.Quantity costSpot = 4;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:path=managedimages,singular=managedimage,categories={catalog,modela,all}
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="URL",type="string",JSONPath=".spec.url"
// +kubebuilder:printcolumn:name="Version",type="string",JSONPath=".spec.version"
// +kubebuilder:printcolumn:name="Description",type="string",JSONPath=".spec.description"
// Managed Images define the metadata about a docker image used during training or serving
message ManagedImage {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ManagedImageSpec spec = 2;
}

// +kubebuilder:object:root=true
// ManagedImageList is a list of pretrained models
message ManagedImageList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ManagedImage items = 2;
}

// ManagedImageSpec is the desired state of the pretrained model
message ManagedImageSpec {
  // +kubebuilder:validation:Optional
  optional string description = 1;

  // The image registry, by default use docker.io
  // +kubebuilder:default ="docker.io"
  // +kubebuilder:validation:Optional
  optional string registry = 2;

  // The image repository. This is a required field
  // +kubebuilder:validation:Required
  optional string repository = 3;

  // The image tag. by default this is latest
  // +kubebuilder:default ="latest"
  // +kubebuilder:validation:Optional
  optional string tag = 4;

  // The environment variables to use when the image start
  // +kubebuilder:validation:Optional
  repeated k8s.io.api.core.v1.EnvVar env = 5;

  // Is this a gpu image
  // +kubebuilder:default:=false
  // +kubebuilder:validation:Optional
  optional bool gpu = 6;

  // If true this is an active image that should be used for new training.
  // +kubebuilder:default:=false
  // +kubebuilder:validation:Optional
  optional bool active = 7;

  // Preload the image to the cluster.
  // +kubebuilder:default:=false
  // +kubebuilder:validation:Optional
  optional bool preload = 8;

  // Preload the image to the cluster.
  // +kubebuilder:validation:Optional
  optional k8s.io.api.core.v1.ObjectReference connectionRef = 9;

  // The base image for this image.
  // +kubebuilder:default =""
  // +kubebuilder:validation:Optional
  optional string base = 10;

  // The base image for this image.
  // +kubebuilder:default =""
  // +kubebuilder:validation:Optional
  optional string role = 11;

  // The organization maintaining this image
  // +kubebuilder:default ="metaprov"
  // +kubebuilder:validation:Optional
  // Who maintain this image.
  optional string mantainedBy = 12;

  // The Image home page in the registry
  // +kubebuilder:default =""
  // +kubebuilder:validation:Optional
  optional string uri = 13;

  // List of ml frameworks supported by the data container
  // +kubebuilder:validation:Optional
  repeated string frameworks = 14;

  // Libs is the list of python library supported by the data container
  // +kubebuilder:validation:Optional
  repeated Lib libs = 15;

  // OS is the name of the os
  // +kubebuilder:validation:Optional
  optional string os = 16;

  // OSVersion is the version of the os
  // +kubebuilder:validation:Optional
  optional string osVersion = 17;

  // If true this is an active image that should be used for new training.
  // +kubebuilder:default:=false
  // +kubebuilder:validation:Optional
  optional bool private = 18;
}

// Measurement is a value for a specific metric
message Measurement {
  // +kubebuilder:validation:Optional
  optional k8s.io.api.core.v1.ObjectReference entity = 1;

  // +kubebuilder:validation:Optional
  optional string column = 2;

  // The metric type name (e.g. F1 / Accuracy)
  // +kubebuilder:validation:Optional
  optional string metric = 3;

  // The value of the metric for quantitive observations
  // +kubebuilder:validation:Optional
  optional double value = 4;

  // Metric standard diviation for quantative observations.
  // +kubebuilder:validation:Optional
  optional double stddev = 5;

  // If the metric refer to a bool unit, store the bool value
  // +kubebuilder:validation:Optional
  optional bool boolQty = 6;

  // If the metric refer to categorical measure,store the category.
  // +kubebuilder:validation:Optional
  optional string category = 7;

  // Capture a set of values.
  // +kubebuilder:validation:Optional
  repeated string valueSet = 8;

  // The Time when the observation was taken
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time timePoint = 9;

  // The measurment task type (e.g. train, test, cv, feature)
  // +kubebuilder:validation:Optional
  optional string taskType = 10;

  // The name of the algorithm that generated this measurment
  // +kubebuilder:validation:Optional
  optional string algorithm = 11;
}

// ModelDeploymentSpec describes how a single model should be deployed with a Predictor, and
// how prediction traffic will be routed to the model
message ModelDeploymentSpec {
  // The reference to a Model resource which has been packaged
  // +kubebuilder:validation:Required
  // +required
  optional k8s.io.api.core.v1.ObjectReference modelRef = 1;

  // the port of the model service.
  // +kubebuilder:default:=8080
  // +kubebuilder:validation:Optional
  optional int32 port = 2;

  // The minimum percentage (0 through 100) of traffic that will be served by the model
  // +kubebuilder:validation:Maximum=100
  // +kubebuilder:validation:Minimum=0
  // +kubebuilder:default:=100
  // +kubebuilder:validation:Optional
  optional int32 traffic = 3;

  // Role denotes the role of the model, which can be either live or shadow.
  // When a model is deployed as a live model, prediction requests will be served by the model. The chance that the
  // prediction request will be forwarded to the model is determined by Traffic.
  // When a model is deployed as a shadow model, the model will still receive and log prediction requests and results
  // but will not have the result sent back the Predictor
  // +kubebuilder:default:=live
  // +kubebuilder:validation:Optional
  optional string role = 4;

  // The URL of the model server image; applicable when rolling back a model
  optional string imageName = 5;

  // The reference to the account which approved the model, if applicable
  // +kubebuilder:validation:Optional
  optional k8s.io.api.core.v1.ObjectReference approvedBy = 6;
}

// NotificationSpec defines the notification configuration for an Alert resource
message NotificationSpec {
  // TTL defines the time-to-live for Alerts, in seconds, after which they will be deleted
  // +kubebuilder:default:=3600
  // +kubebuilder:validation:Optional
  optional int32 ttl = 1;

  // NotifierName specifies the name of a single Notifier resource which the Alert will be forwarded to
  // +kubebuilder:validation:Optional
  optional string notifierName = 2;

  // Selector defines a map of labels that will be matched to find multiple Notifier resource to forward alerts to
  // +kubebuilder:validation:Optional
  map<string, string> selector = 3;
}

message ObjectiveSpec {
  // The objective metric
  optional string metric = 1;

  // The goal of the objective.
  // +kubebuilder:default:=maximize
  optional string goal = 2;
}

message PRCurve {
  repeated CurvePoint values = 1;
}

// ParameterRange defines the limits for a single hyperparameter
message ParameterRange {
  // Name is the name of the hyperparameter
  // +kubebuilder:validation:Optional
  optional string name = 1;

  // Type is the datatype of the parameter
  // +kubebuilder:validation:Optional
  optional string type = 2;

  // Low is the minimum value of the hyperparameter
  // +kubebuilder:validation:Optional
  optional double low = 3;

  // High is the maximum value of the hyperparameter
  // +kubebuilder:validation:Optional
  optional double high = 4;

  // Step for discrete variable.
  // +kubebuilder:validation:Optional
  optional int32 step = 5;

  // Log indicates if the scale is logarithmic
  // +kubebuilder:validation:Optional
  optional bool log = 6;

  // Set of choices for categorical variable
  // +kubebuilder:validation:Optional
  repeated string choices = 7;

  // DefaultValue is the default value of the parameter
  // +kubebuilder:validation:Optional
  optional double defaultValue = 8;

  // Default Choice for categorical variable.
  // +kubebuilder:validation:Optional
  optional string defaultChoice = 9;

  // If true this parameter is condition on another parameter value
  // +kubebuilder:validation:Optional
  optional bool conditional = 10;

  // Parent parameter name
  // +kubebuilder:validation:Optional
  optional string parent = 11;

  // The parent value in order for this parameter to be active.
  // +kubebuilder:validation:Optional
  optional string parentValueCat = 12;

  // The parent value in order for this parameter to be active.
  // +kubebuilder:validation:Optional
  optional int32 parentValueInteger = 13;

  // The parent value in order for this parameter to be active.
  // +kubebuilder:validation:Optional
  optional double parentValueFloat = 14;
}

// PermissionsSpec defines the permissions for one or more accounts
message PermissionsSpec {
  repeated AccountPermissions accounts = 1;
}

// Pretrained model contain the metadata about a pretrained model
// +kubebuilder:object:root=true
message PretrainedModel {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PretrainedModelSpec spec = 2;
}

// +kubebuilder:object:root=true
// PretrainedModelList is a list of pretrained models
message PretrainedModelList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated PretrainedModel items = 2;
}

// PretrainedModelSpec is the desired state of the pretrained model
message PretrainedModelSpec {
  // Image is the docker image of the pretrained model
  optional string image = 1;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:path=publicdatasets,singular=publicdataset,categories={catalog,modela,all}
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Task",type="string",JSONPath=".spec.task",description="ML task name"
// +kubebuilder:printcolumn:name="URL",type="string",JSONPath=".spec.url",description="",priority=1
// +kubebuilder:printcolumn:name="Rows",type="number",JSONPath=".spec.rows",description=""
// +kubebuilder:printcolumn:name="Columns",type="number",JSONPath=".spec.columns",description=""
// +kubebuilder:printcolumn:name="Target",type="string",JSONPath=".spec.targetColumn",description=""
// +kubebuilder:printcolumn:name="Imbalanced",type="string",JSONPath=".spec.imbalanced",description="",priority=1
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// PublicDataset represent the metadata about a public dataset
message PublicDataset {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PublicDatasetSpec spec = 2;
}

// +kubebuilder:object:root=true
// PublicDatasetList contains a list of PublicDataset
message PublicDatasetList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated PublicDataset items = 2;
}

message PublicDatasetSpec {
  optional string url = 1;

  // Entity description
  // +kubebuilder:default =""
  // +kubebuilder:validation:Optional
  optional string description = 2;

  // Task is the machine learning task of the public dataset
  optional string task = 3;

  // The open ml id of the dataset
  // +kubebuilder:validation:Optional
  // +kubebuilder:default =""
  optional string openMLID = 4;

  // The URL to the actual data file or folder
  // +kubebuilder:validation:Optional
  // +kubebuilder:default =""
  optional string dataUrl = 5;

  // Entity citation
  // +kubebuilder:validation:Optional
  // +kubebuilder:default =""
  optional string citation = 6;

  // Number of rows in the dataset
  // +kubebuilder:validation:Optional
  // +kubebuilder:default := 0
  optional int32 rows = 7;

  // Number of columns in the dataset
  // +kubebuilder:validation:Optional
  // +kubebuilder:default := 0
  optional int32 columns = 8;

  // +kubebuilder:validation:Optional
  // The size of the dataset in bytes
  // +kubebuilder:default := 0
  optional int32 fileSize = 9;

  // The target column name
  // +kubebuilder:default =""
  optional string targetColumn = 10;

  // The target column name
  // +kubebuilder:default =""
  optional string industry = 11;

  // +kubebuilder:default = false
  optional bool imbalanced = 12;

  // URI of the datasource CR for this public dataset
  // +kubebuilder:default =""
  optional string datasourceCR = 13;

  // URI of the dataset CR for this public dataset
  // +kubebuilder:default =""
  optional string datasetCR = 14;

  // URI of the study CR for this public dataset
  // +kubebuilder:default =""
  optional string studyCR = 15;

  // URI of the data product CR
  // +kubebuilder:default =""
  optional string dataProductCR = 16;
}

// Region defines a region within the data provider
message Region {
  // Code is the code of the region
  optional string code = 1;

  // The default datacenter for a region
  // +optional
  optional string defaultDatacenterName = 2;

  // Location is the location code The location of the region
  optional string location = 3;

  // BillingCode is the billing code of the region
  optional string billingCode = 4;

  // Datacenters if the list of datacenters
  repeated DataCenter datacenters = 5;
}

// Store resource consumption for a task
message ResourceConsumption {
  optional uint64 cpu = 1;

  optional uint64 memory = 2;

  optional uint64 gpu = 3;
}

// ResourceSpec specifies the resources that will be allocated to a workload
message ResourceSpec {
  // WorkloadName references the name of a Workload Class resource that will be used to determine the resource
  // requirements of the workload. If specified, WorkloadName will take precedence over custom requirements
  // +kubebuilder:validation:Optional
  optional string workloadName = 1;

  // Custom indicates if the custom requirements specified by Requirements will be used
  // +kubebuilder:default:=false
  // +kubebuilder:validation:Optional
  optional bool custom = 2;

  // Requirements specifies the custom resource requirements for the workload
  // +kubebuilder:validation:Optional
  optional k8s.io.api.core.v1.ResourceRequirements requirements = 3;
}

message RocAucCurve {
  repeated CurvePoint values = 1;
}

message RunRecord {
  // ID specifies the unique ID or resource name for the run
  optional string id = 1;

  // FailureMessage contains the failure produced by the run, if applicable
  optional string failureMessage = 2;

  // ResourceVersion specifies the version of the resource relevant to the run at the time of completion
  optional int32 resourceVersion = 3;

  // StartedAt specifies the time at which the run started
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 4;

  // CompletedAt specifies the time at which the run was completed
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time completedAt = 5;

  // Logs contains the logs for all workloads produced by the run
  repeated ContainerLog logs = 6;
}

// RunReference defines a generic reference to any type of run
message RunReference {
  // Name specifies the name of the resource
  optional string name = 1;

  // Version specifies the version of the run
  optional uint32 version = 2;
}

// RunSchedule specifies the schedule for a run to be executed
message RunSchedule {
  // Enabled indicates if the schedule is enabled. When enabled, a CronJob will be created which when triggered
  // will initiate the creation of a run for the resource that specifies the schedule
  // +kubebuilder:default:=false
  // +kubebuilder:validation:Optional
  optional bool enabled = 1;

  // The cron string for the schedule, applicable if the trigger type is Cron.
  // See https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm for more information
  // +kubebuilder:validation:Optional
  optional string cron = 2;

  // The type of schedule, which can be a frequency interval or a cron expression
  // +kubebuilder:validation:Optional
  optional string type = 3;
}

message RunScheduleStatus {
  // Active contains a collection of references to currently active runs
  // +optional
  repeated RunReference active = 1;

  // LastScheduleTime specifies when was the last time a run was successfully scheduled
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 2;

  // LastSuccessfulTime specifies when was the last time a run successfully completed
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 3;
}

// RunSpec specifies the configuration for all runs created by the resource
message RunSpec {
  // Timeout specifies the deadline in seconds for a run to complete, after which it will be aborted.
  // If empty, runs will not have a deadline
  // +kubebuilder:validation:Optional
  optional int32 timeout = 1;

  // MaxPreviousRuns specifies the amount of previous runs to maintain, sorted by their run version.
  // When a new run is created, any runs with a version below that of the latest version minus
  // MaxPreviousRuns will be garbage collected. Runs which are still in progress will not be affected
  // +kubebuilder:default:=1
  // +kubebuilder:validation:Optional
  optional int32 maxPreviousRuns = 2;
}

message RunStatusOld {
  // Last time the job started
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastRunAt = 1;

  // The unique ID of the last run created by the schedule.
  // +kubebuilder:validation:Optional
  optional string lastRunId = 2;

  // The unique ID of the currently active run
  // +kubebuilder:validation:Optional
  optional string activeRunId = 3;

  // The logs of the currently active run
  // +kubebuilder:validation:Optional
  repeated ContainerLog activeRunLogs = 4;

  // RunRecords contains the collection of previously recorded runs
  // +kubebuilder:validation:Optional
  repeated RunRecord runRecords = 5;
}

// SnapshotReference defines a reference to a specific snapshot for a Dataset
message SnapshotReference {
  // Dataset specifies the name of the dataset which the snapshot belongs to
  optional string dataset = 1;

  // Version specifies the version of the snapshot to use. If empty, the latest available snapshot will be used
  optional uint32 version = 2;
}

// StudyRunReference defines a reference to a specific run for a Study
message StudyRunReference {
  // Study specifies the name of the study which the run belongs to
  optional string study = 1;

  // Version specifies the version of the run to use. If empty, the latest available run will be used
  optional uint32 version = 2;
}

message TestSuite {
  // If false, this test case is disabled
  // +kubebuilder:validation:Optional
  optional bool enabled = 1;

  // +kubebuilder:validation:Optional
  repeated DataTestCase tests = 2;
}

message TestSuiteResult {
  // A reference to the object under test. Best practice is to have one suite for an object
  // +kubebuilder:validation:Optional
  optional k8s.io.api.core.v1.ObjectReference entityRef = 1;

  // Total number of failures. A failure is an unplanned error, e.g. cannot connect to a dataset
  // +kubebuilder:validation:Optional
  optional int32 failures = 2;

  // Total number of assertion errors.
  // +kubebuilder:validation:Optional
  optional int32 errors = 3;

  // Start time of running the suite
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 4;

  // Stop time of running the suite.
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time completedAt = 5;

  // The result of executing the test suite. The result contain one result object per test case.
  // +kubebuilder:validation:Optional
  repeated DataTestCaseResult tests = 6;
}

message WorkerRunResult {
  // Worker ID
  // +kubebuilder:validation:Optional
  optional int32 id = 1;

  // URI
  // +kubebuilder:validation:Optional
  optional string uri = 2;

  // +kubebuilder:validation:Optional
  optional string task = 3;

  // +kubebuilder:validation:Optional
  optional string error = 4;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:path=workloadclasses,singular=workloadclass,categories={catalog,modela,all}
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// WorkloadClass define a template for a job.
message WorkloadClass {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional WorkloadClassSpec spec = 2;
}

// +kubebuilder:object:root=true
// TrainerList contains a list of Trainer
message WorkloadClassList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated WorkloadClass items = 2;
}

// WorkloadClassSpec defines the specification of  a workload class.
message WorkloadClassSpec {
  optional ResourceSpec resourcesTemplate = 1;
}

