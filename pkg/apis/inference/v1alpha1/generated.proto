/**
*
* Copyright (C) 2017 modeld authors
* For license information, see LICENSE.txt
*/
// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.metaprov.modeldapi.pkg.apis.inference.v1alpha1;

import "github.com/metaprov/modeldapi/pkg/apis/catalog/v1alpha1/generated.proto";
import "github.com/metaprov/modeldapi/pkg/apis/data/v1alpha1/generated.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

message BotChannelSpec {
  // the connection to the messaging provider
  // Required,
  optional string connectionName = 1;

  // The name of the notifier that will be used by the prediction bot.
  // Required
  optional string notifierName = 2;
}

// Look for prediction in a bucket key.
// Request for prediction will be placed in the key.
// Result will be placed in the output bucket
message BucketChannelSpec {
  // the connection to the cloud provider
  // Required,
  optional string connectionName = 1;

  // Required,
  optional string databaseConnectionName = 2;

  // The location of the input or the output
  // Required,
  optional string inputKey = 3;

  // In seconds, the interval.
  optional int32 scanInterval = 4;
}

message ChannelStatus {
  optional string name = 1;

  optional string error = 2;
}

// Curtain represent a Curtain API object
// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type==\"Ready\")].status",description=""
// +kubebuilder:printcolumn:name="Serving Site",type="string",JSONPath=".spec.servingsiteRef.name"
// +kubebuilder:printcolumn:name="Dataset",type="string",JSONPath=".spec.datasetRef.name"
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:path=curtains,singular=curtain,categories={inference,modeld,all}
message Curtain {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional CurtainSpec spec = 2;

  // +optional
  optional CurtainStatus status = 3;
}

// CurtainCondition describes the state of a wizard of oz at a certain point.
message CurtainCondition {
  // Type of account condition.
  optional string type = 1;

  // Status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // Last time the condition transitioned from one status to another.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // The reason for the condition's last transition.
  optional string reason = 4;

  // A human readable message indicating details about the transition.
  optional string message = 5;
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// CurtainList represent a list of Curtain resources
message CurtainList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Curtain items = 2;
}

// CurtainSpec define the desired state of a Curtain
message CurtainSpec {
  // User provided description
  // +kubebuilder:default =""
  // +optional
  optional string description = 1;

  // User provided description
  // +optional
  optional string versionName = 2;

  // The product of the resource
  // +optional
  optional string servingsiteName = 3;

  // The dataset that store the wizard answers
  // +optional
  optional string datasetName = 4;

  // The wizards him self. This is a reference to one or more wizards objects.
  repeated string wizards = 5;

  // Question to ask the wizard
  // +kubebuilder:validation:MaxLength=256
  optional string question = 6;

  // The owner account name
  // +optional
  optional string owner = 7;
}

// CurtainStatus contain the observed state of the Curtain object.
message CurtainStatus {
  // +optional
  repeated CurtainCondition conditions = 1;
}

message CurtainTemplateSpec {
  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional CurtainSpec spec = 2;
}

// Specification for drift detection
message DriftCheckSpec {
  // The crdn schedule to run the drift detection
  optional string cronExpr = 1;

  // The drift threshold.
  // +optional
  optional double treshold = 2;

  // The notifier to invoke in case of
  optional string notifierName = 3;

  // Tested dataset
  optional string testDataset = 4;
}

// The desired state of the model.
message ModelDeploymentSpec {
  // The model serving the prediction
  optional string modelName = 1;

  // number of replicas of the current model
  // Default: 1
  // +optional
  // +kubebuilder:validation:Maximum=10
  // +kubebuilder:validation:Minimum=0
  optional int32 replicas = 2;

  // Does the current model pods needs autoscaling. If yes we will use HPA.
  // Default is false
  // +optional
  optional bool autoscale = 3;

  // How much traffic to the current model
  // Default: 100.
  // +optional
  // +kubebuilder:validation:Maximum=100
  // +kubebuilder:validation:Minimum=0
  optional int32 weight = 4;

  // Denotes if this deployment is canary. This must be false for the prod deployment.
  // Default: false
  // +optional
  optional bool canary = 5;

  // Denotes if the model is a shadow. This must be false for the prod deployment.
  // Default: false
  // +optional
  optional bool shadow = 6;

  // Filter donotes a selection on the model
  // +optional
  optional string filter = 7;

  // If the deployment is canary, the metric define how to evaluate the canary.
  // Default: none
  // +optional
  repeated string canaryMetrics = 8;
}

message ModelDeploymentStatus {
  // The model image name
  optional string imageName = 1;

  // The deployment name that serves this model
  optional string deploymentName = 2;

  // The service name that serves this model
  optional string serviceName = 3;

  // the name of the horizonal pod autoscaler, if autoscaling is true
  optional string hpaName = 4;

  // P95 latency
  optional double current95 = 5;

  // P95 latency
  optional double current99 = 6;

  // Last current prediction
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastPrediction = 7;

  optional int32 dailyPredictionAvg = 8;
}

// The specific of a prediction channel
message PredictionChannel {
  // Define a prediction via table
  // +optional
  optional TableChannelSpec table = 1;

  // Define a prediction via a bot
  // +optional
  optional BotChannelSpec bot = 2;

  // Define a prediction via a bot
  // +optional
  optional BucketChannelSpec bucket = 3;

  // Define a streaming spec for the predictor
  // +optional
  optional StreamingChannelSpec streaming = 4;
}

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type==\"Ready\")].status"
// +kubebuilder:printcolumn:name="Predictor",type="string",JSONPath=".spec.predictorName"
// +kubebuilder:printcolumn:name="Bucket",type="string",JSONPath=".spec.datasetName"
// +kubebuilder:printcolumn:name="File",type="string",JSONPath=".spec.datasetName"
// +kubebuilder:printcolumn:name="Labeled",type="string",JSONPath=".spec.datasetName"
// +kubebuilder:printcolumn:name="Score",type="string",JSONPath=".status.score"
// +kubebuilder:printcolumn:name="Status",type="string",JSONPath=".status.phase"
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:path=predictionpipelines,singular=predictionpipeline,categories={inference,modeld}
// PredictionTemplate represents a prediction object
message PredictionPipeline {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PredictionPipelineSpec spec = 2;

  optional PredictionPipelineStatus status = 3;
}

// PredictionPipelineCondition describes the state of PredictionTemplate
message PredictionPipelineCondition {
  // Type of  condition.
  optional string type = 1;

  // Status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // Last time the condition transitioned from one status to another.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // The reason for the condition's last transition.
  optional string reason = 4;

  // A human readable message indicating details about the transition.
  optional string message = 5;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PredictionPipelineList is a list of PredictionPipeline
message PredictionPipelineList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated PredictionPipeline items = 2;
}

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type==\"Ready\")].status"
// +kubebuilder:printcolumn:name="Predictor",type="string",JSONPath=".spec.predictorName"
// +kubebuilder:printcolumn:name="Bucket",type="string",JSONPath=".spec.datasetName"
// +kubebuilder:printcolumn:name="File",type="string",JSONPath=".spec.datasetName"
// +kubebuilder:printcolumn:name="Labeled",type="string",JSONPath=".spec.datasetName"
// +kubebuilder:printcolumn:name="Score",type="string",JSONPath=".status.score"
// +kubebuilder:printcolumn:name="Status",type="string",JSONPath=".status.phase"
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:path=predictionpipelineruns,singular=predictionpipelinerun,categories={inference,modeld}
// PredictionPipelineRun represents a single run of the Prediction Pipeline
message PredictionPipelineRun {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PredictionPipelineRunSpec spec = 2;

  optional PredictionPipelineRunStatus status = 3;
}

// PredictionPipelineCondition describes the state of PredictionTemplate
message PredictionPipelineRunCondition {
  // Type of  condition.
  optional string type = 1;

  // Status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // Last time the condition transitioned from one status to another.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // The reason for the condition's last transition.
  optional string reason = 4;

  // A human readable message indicating details about the transition.
  optional string message = 5;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PredictionPipelineRunList is a list of PredictionPipelineRun
message PredictionPipelineRunList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated PredictionPipelineRun items = 2;
}

// PredictionPipelineRunSpec represent the desired state of PredictionPipelineRun
message PredictionPipelineRunSpec {
  // PredictorName refer to the predictor which would predict the dataset of this prediction.
  // +kubebuilder:validation:MaxLength=63
  // +kubebuilder:validation:MinLength=1
  optional string predictorName = 1;

  // Labeled , true if this is labeled prediction request.
  // Used usually for unit testing
  optional bool labeled = 2;

  // The objective metric used to score
  optional string objective = 3;

  // In where we are using a dataset name. This can be dataset name
  // +optional
  optional string datasetName = 4;

  // DataLocation of the input if using direct input file
  optional github.com.metaprov.modeldapi.pkg.apis.data.v1alpha1.DataLocation input = 5;

  // The key in the bucket for storing all the prediction output
  // +optional
  optional github.com.metaprov.modeldapi.pkg.apis.data.v1alpha1.DataLocation output = 6;

  // Owner of the run
  // +optional
  optional string owner = 7;
}

// PredictionPipelineRunStatus is the observed state of a PredictionTemplate
message PredictionPipelineRunStatus {
  // PredictionPipelineRun score based on the objective.
  // +optional
  optional double score = 2;

  // The phase of the prediction
  // +optional
  optional string phase = 3;

  // StartTime is the times that this prediction job started
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 4;

  // CompletionTime is the time that this prediction job finished
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 5;

  // +optional
  repeated PredictionPipelineRunCondition conditions = 6;
}

// PredictionPipelineSpec represent the desired state of PredictionPipeline
message PredictionPipelineSpec {
  // PredictorName refer to the predictor which would predict the dataset of this prediction.
  // +kubebuilder:validation:MaxLength=63
  // +kubebuilder:validation:MinLength=1
  optional string predictorName = 1;

  // Labeled , true if this is labeled prediction request.
  // Used usally for unit testing
  optional bool labeled = 2;

  // The objective metric used to score
  optional string objective = 3;

  // In where we are using a dataset name. This can be dataset name
  // +optional
  optional string datasetName = 4;

  // DataLocation of the input if using direct input file
  optional github.com.metaprov.modeldapi.pkg.apis.data.v1alpha1.DataLocation input = 5;

  // The key in the bucket for storing all the prediction output
  // +optional
  optional github.com.metaprov.modeldapi.pkg.apis.data.v1alpha1.DataLocation output = 6;

  // The owner account name
  // +optional
  optional string owner = 7;
}

// PredictionPipelineStatus is the observed state of a PredictionTemplate
message PredictionPipelineStatus {
  // PredictionPipeline score based on the objective.
  // +optional
  optional double score = 2;

  // The phase of the prediction
  // +optional
  optional string phase = 3;

  // StartTime is the times that this prediction job started
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 4;

  // CompletionTime is the time that this prediction job finished
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 5;

  // +optional
  repeated PredictionPipelineCondition conditions = 6;
}

// +k8s:openapi-gen=true
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type==\"Ready\")].status",description=""
// +kubebuilder:printcolumn:name="Port",type="integer",JSONPath=".spec.port",description=""
// +kubebuilder:printcolumn:name="Production",type="string",JSONPath=".spec.prod.modelName",description=""
// +kubebuilder:printcolumn:name="Weight",type="string",JSONPath=".spec.prod.weight",description=""
// +kubebuilder:printcolumn:name="Access",type="string",JSONPath=".spec.accessType",description=""
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp",description=""
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:path=predictors,singular=predictor,categories={inference,modeld}
// PredictorName represent an PredictorName API object
message Predictor {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PredictorSpec spec = 2;

  // +optional
  optional PredictorStatus status = 3;
}

// PredictorCondition describes the state of a prediction at a certain point.
message PredictorCondition {
  // Type of account condition.
  optional string type = 1;

  // Status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // Last time the condition transitioned from one status to another.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // The reason for the condition's last transition.
  optional string reason = 4;

  // A human readable message indicating details about the transition.
  optional string message = 5;
}

message PredictorHealth {
  optional int32 totalPredictions = 1;

  optional int32 totalRequests = 2;

  optional int32 totalP95Requests = 3;

  optional int32 medianResponseTime = 4;

  // Last 7 days predictions
  repeated int32 lastDailyPredictions = 5;
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// PredictorList represent a list of predictors
message PredictorList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Predictor items = 2;
}

// PredictorSpec define the desired state of the predictor
message PredictorSpec {
  // The account name of the owner of this predictor
  // +optional
  optional string ownerName = 1;

  // User provided description
  // +kubebuilder:validation:MaxLength=256
  // +kubebuilder:default =""
  // +optional
  optional string description = 2;

  // The product that this predictor serve.
  optional k8s.io.api.core.v1.ObjectReference productRef = 3;

  // The serving site that owns the
  // +optional
  optional k8s.io.api.core.v1.ObjectReference servingsiteRef = 4;

  // Service port specify the predictor port.
  // Default: 8080
  // +optional
  optional int32 port = 5;

  // This is the path relative to the ingress path
  // +kubebuilder:validation:MaxLength=256
  // +kubebuilder:validation:MinLength=1
  // Default: /predict
  // +optional
  optional string path = 6;

  // The access method specified how external clients will access the predictor
  // Default: ClusterPort
  // +optional
  optional string accessType = 7;

  // A template for the predictor pod. The system will create the deployment based on this template.
  // +optional
  optional k8s.io.api.core.v1.PodTemplate template = 8;

  // Production model deployment
  // +optional
  repeated ModelDeploymentSpec models = 9;

  // How much do we increment the warm up traffic
  // +optional
  optional DriftCheckSpec driftCheck = 12;

  // Denotes the progressive spec
  // What metric to use when comparing the candidate to the current
  // +optional
  optional ProgressiveSpec progressive = 13;

  // The key in the bucket for storing all the predictor artifacts.
  // +kubebuilder:validation:MaxLength=512
  // +kubebuilder:validation:MinLength=1
  // +optional
  optional string artifactsFolder = 14;

  // set of input channel, the predictor will watch those channels for predictions
  // +optional
  repeated PredictionChannel inputChannels = 15;

  // set of output channels, the predictor will
  // +optional
  repeated PredictionChannel outputChannels = 16;

  // The owner account name
  // +optional
  optional string owner = 17;
}

// PredictorStatus contain the current state of the Predictor resource
message PredictorStatus {
  // Model one status
  // +optional
  repeated ModelDeploymentStatus modelStatus = 1;

  repeated PredictorCondition conditions = 2;

  // When was the last check attempt
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp monitorLastAttemptAt = 3;

  // What was the last score
  optional double monitorLastScore = 4;

  // What was the last latency
  optional double monitorLastLatency = 5;

  // The Health of the predictor
  optional PredictorHealth health = 6;

  // The channels
  repeated ChannelStatus statuses = 7;
}

message ProgressiveSpec {
  // How long in seconds does the warm up period started
  // This is used only during progressive deployment
  // +optional
  // +kubebuilder:validation:Maximum=100
  // +kubebuilder:validation:Minimum=0
  optional int32 warmup = 1;

  // How much do we increment the warm up traffic
  // +kubebuilder:validation:Maximum=10
  // +kubebuilder:validation:Minimum=1
  // Default : 10
  // +optional
  optional int32 trafficIncrement = 2;

  // What metric to use when comparing the candidate to the current
  // +optional
  repeated string canaryMetrics = 3;
}

message StreamingChannelSpec {
  // StorageConnection name to the streaming provider
  optional string connectionName = 1;

  // the streaming topic (input or output)
  optional string inputKey = 2;
}

// A prediction table describes a dataset and a table that will be used to enter unseen data, and get prediction
message TableChannelSpec {
  // connection to the database provider
  optional string connectionName = 1;

  // Options, this is the datasource containing the table schema
  optional string datasourceName = 2;

  // The table name. Optional
  // Default to the predictor name
  optional string tableName = 3;

  // In seconds, the interval.
  optional int32 scanInterval = 4;
}

