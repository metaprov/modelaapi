/**
*
* Copyright (C) 2017 modela authors
* For license information, see LICENSE.txt
*/
// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.metaprov.modelaapi.pkg.apis.llm.v1alpha1;

import "github.com/metaprov/modelaapi/pkg/apis/catalog/v1alpha1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "github.com/metaprov/modelaapi/pkg/apis/llm/v1alpha1";

// CodeSplitterSpec splits code documents by their AST
message CodeSplitterSpec {
  // The language of the document(s). When set to `infer`, the language of the document
  // will be inferred using the name and extension of the original file. Documents that
  // cannot be parsed using the specified language will be skipped
  // +kubebuilder:validation:Required
  optional string language = 1;

  // The number of code lines in each chunk. When unspecified, default to 40
  optional int32 chunkLines = 2;

  // The amount of code lines that will be captured on each side of the node. When unspecified, default to 15
  optional int32 chunkLinesOverlap = 3;

  // The maximum amount of characters in each chunk. When unspecified, default to 1500
  optional int32 maxChars = 4;
}

message DatabaseReaderSpec {
  // The type of database reader
  optional string type = 1;

  // The name of the connection to the database
  optional string connectionName = 2;

  // The query to execute on the database
  optional string query = 3;

  // Reader-specific options
  map<string, string> options = 4;
}

// DocumentSpec defines the specification of a single document
message DocumentSpec {
  // The unique name of the document
  optional string name = 1;

  // Description specifies an optional description for the document
  optional string description = 2;

  // Metadata contains user-specified metadata about the document
  map<string, string> metadata = 3;

  // RefreshPeriod specifies the time, in seconds, at which the document must be refreshed
  // If unspecified or zero, the document will be refreshed on each sync.
  // When set to -1, the document will only refresh once
  optional int32 refreshPeriod = 4;

  // NodeParser specifies document-specific options for breaking up the document into nodes
  optional NodeParserSpec nodeParser = 5;

  // EmbeddingModel specifies a document-specific embedding model
  optional ModelSpec embeddingModel = 6;

  // File specifies the configuration to read text from a file
  optional FileReaderSpec file = 7;

  // Database specifies the configuration to read text from a database query
  optional DatabaseReaderSpec database = 8;

  // Web specifies the configuration to read text from an external web-based source
  optional WebReaderSpec web = 9;
}

message DocumentStatus {
  // The unique name of the document
  // +kubebuilder:validation:Required
  // +required
  optional string name = 1;

  // The unique ID of the document (generated internally)
  optional string uid = 2;

  // The number of nodes created for the document
  optional int32 nodes = 3;

  // The time at which the document was last refreshed
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastRefreshAt = 4;
}

message FileReaderSpec {
  // The type of file reader
  optional string type = 1;

  // The location of the file
  optional github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.FileLocation location = 2;

  // Reader-specific options
  map<string, string> options = 3;
}

// +kubebuilder:subresource:status
// +kubebuilder:resource:path=knowledgebases,singular=knowledgebase,shortName=kb,categories={llm,modela}
// +kubebuilder:object:root=true
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Owner",type="string",JSONPath=".spec.owner",priority=1
// +kubebuilder:printcolumn:name="Last Sync",type="date",JSONPath=".status.lastSyncAt",description=""
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
// KnowledgeBase represents a collection of documents that can be queried with retrieval-augmented generation
message KnowledgeBase {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional KnowledgeBaseSpec spec = 2;

  optional KnowledgeBaseStatus status = 3;
}

// +kubebuilder:object:root=true
// KnowledgeBaseList contains a list of KnowledgeBases
message KnowledgeBaseList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated KnowledgeBase items = 2;
}

message KnowledgeBaseSpec {
  // Owner specifies the name of the Account which the object belongs to
  // +kubebuilder:default:="no-one"
  // +kubebuilder:validation:Optional
  optional string owner = 1;

  // The user-provided description of the Knowledge Base
  // +kubebuilder:default:=""
  // +kubebuilder:validation:MaxLength=512
  // +kubebuilder:validation:Optional
  optional string description = 2;

  // RefreshSchedule specifies the schedule for Modela to refresh all documents specified by the Knowledge Base
  optional github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.RunSchedule refreshSchedule = 3;

  // MetadataDatabase specifies the location of a database table used to store document metadata and statuses.
  // When specified, any document metadata specified by Documents will be cleared and migrated to the table
  optional github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.DatabaseLocation metadataDatabase = 4;

  // VectorStoreConnectionName specifies the name of a Connection resource that provides a vector database
  optional string vectorStoreConnectionName = 5;

  // DocumentStoreConnectionName specifies the name of a Connection resource to use as a document store
  optional string documentStoreConnectionName = 6;

  // EmbeddingModel specifies the embedding model to use when ingesting documents
  optional ModelSpec embeddingModel = 7;

  // Documents specifies the collection of documents included in the Knowledge Base
  repeated DocumentSpec documents = 8;

  // NodeParser specifies the default node parser for all documents.
  // The node parser defines how to split up documents into individual chunks of text
  optional NodeParserSpec nodeParser = 9;
}

message KnowledgeBaseStatus {
  // ObservedGeneration specifies the last generation that was reconciled
  // +kubebuilder:validation:Optional
  optional int64 observedGeneration = 1;

  // LastRefreshAt specifies the time at which the last refresh job was executed
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastRefreshAt = 2;

  // Logs contains the location of the logs produced by the last refresh job
  repeated github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.ContainerLog logs = 3;

  // Documents contains the collection of statuses for each document defined by the Knowledge Base.
  // In the case that a metadata database is defined, the collection will be empty
  repeated DocumentStatus documents = 4;

  // The last time the object was updated
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time updatedAt = 5;

  // +kubebuilder:validation:Optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 6;
}

// ModelSpec specifies the configuration for an LLM
message ModelSpec {
  // ConnectionName specifies the name of a connection to a foundational model provider
  optional string connectionName = 1;

  // Model specifies the vendor-specific model type
  optional string model = 2;
}

// NodeParserSpec defines how to break up a document into individual chunks of text
message NodeParserSpec {
  // Indicate if previous/next relationships should be included between nodes. When unspecified, default to true
  optional bool includeOrderRelationship = 1;

  // Indicate if metadata should be included in the nodes. When unspecified, default to true
  optional bool includeMetadata = 2;

  // The type of node parser. When a specification for a text or sentence window node parser is provided, this field
  // may be omitted. When not provided, the defaults for the type of node parser will be used
  optional string type = 3;

  // The specification for the text splitter to use as a node parser
  optional TextSplitterSpec text = 4;

  // The specification for the sentence window node parser
  optional SentenceWindowNodeParserSpec sentence = 5;
}

// SentenceSplitterSpec splits text documents with a preference for complete sentences
message SentenceSplitterSpec {
  // The chunk size, in tokens, for each chunk. When unspecified, default to 1024
  optional int32 chunkSize = 1;

  // The amount of tokens that will be captured on each side of the node. When unspecified, default to 200
  optional int32 chunkOverlap = 2;

  // The separator character for words. When unspecified, default to the space character
  optional string wordSeparator = 3;

  // The separator character for paragraphs. When unspecified, default to newline
  optional string paragraphSeparator = 4;

  // The function to split documents into sentences. When unspecified, default to the Punkt tokenizer
  optional SentenceTokenizerSpec splitter = 5;
}

// SentenceTokenizerSpec specifies a function to split text into sentences
message SentenceTokenizerSpec {
  optional string type = 1;

  // The separator character or regex pattern, required when the tokenizer type is `regex` or `separator`
  optional string separator = 2;
}

message SentenceWindowNodeParserSpec {
  // The function to split documents into sentences. When unspecified, default to the Punkt tokenizer
  optional SentenceTokenizerSpec splitter = 1;

  // The number of sentences to capture on each side of the node. When unspecified, default to 3
  optional int32 windowSize = 2;
}

// TextSplitterSpec defines how to split a document into sentences using a text splitter
message TextSplitterSpec {
  // The type of text splitter. When a specification for a text splitter is provided, this field
  // may be omitted. When not provided, the defaults for the type of text splitter will be used
  optional string type = 1;

  // Sentence splits the document by sentence
  optional SentenceSplitterSpec sentence = 2;

  // Token splits the document by tokens
  optional TokenSplitterSpec token = 3;

  // Code splits code documents
  optional CodeSplitterSpec code = 4;
}

// TokenSplitterSpec splits text documents by their tokens
message TokenSplitterSpec {
  // The chunk size, in tokens, for each chunk. When unspecified, default to 1024
  optional int32 chunkSize = 1;

  // The amount of tokens that will be captured on each side of the node. When unspecified, default to 200
  optional int32 chunkOverlap = 2;

  // The separator character for words. When unspecified, default to the space character
  optional string wordSeparator = 3;
}

message WebReaderSpec {
  // The type of web reader
  optional string type = 1;

  // The name of the connection that provides authorization details to the reader, if applicable
  optional string connectionName = 2;

  // Reader-specific options
  map<string, string> options = 3;
}

