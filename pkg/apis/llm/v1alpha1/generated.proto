/**
*
* Copyright (C) 2017 modela authors
* For license information, see LICENSE.txt
*/
// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.metaprov.modelaapi.pkg.apis.llm.v1alpha1;

import "github.com/metaprov/modelaapi/pkg/apis/catalog/v1alpha1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "github.com/metaprov/modelaapi/pkg/apis/llm/v1alpha1";

// CodeSplitterSpec splits code documents by their syntax trees
message CodeSplitterSpec {
  // The language of the document(s). When set to `infer`, the language of the document
  // will be inferred using the extension of the original file. Documents that
  // cannot be parsed using the specified language will be skipped
  // +kubebuilder:validation:Required
  optional string language = 1;

  // The number of code lines in each chunk. When unspecified, default to 40
  optional int32 chunkLines = 2;

  // The amount of code lines that will be captured on each side of the node. When unspecified, default to 15
  optional int32 chunkLinesOverlap = 3;

  // The maximum amount of characters in each chunk. When unspecified, default to 1500
  optional int32 maxChars = 4;
}

// ConcreteNodeParserSpec defines how to break up a document into individual chunks of text
message ConcreteNodeParserSpec {
  // Indicate if previous/next relationships should be included between nodes. When unspecified, default to true
  optional bool includeOrderRelationship = 1;

  // Indicate if metadata should be included in the nodes. When unspecified, default to true
  optional bool includeMetadata = 2;

  // The type of node parser. When a specification for a text or sentence window node parser is provided, this field
  // may be omitted. When not provided, the defaults for the specified node parser type will be used.
  // When unspecified, default to sentence window
  optional string type = 3;

  // The specification for the text splitter to use as a node parser
  optional TextSplitterSpec text = 4;

  // The specification for the sentence window node parser
  optional SentenceWindowNodeParserSpec sentence = 5;
}

message DatabaseReaderSpec {
  // The type of database reader
  optional string type = 1;

  // The name of the connection to the database
  optional string connectionName = 2;

  // The query to execute on the database
  optional string query = 3;

  // Reader-specific options
  map<string, string> options = 4;
}

// DocumentSpec defines the specification of a single document
message DocumentSpec {
  // The unique name of the document
  optional string name = 1;

  // Description specifies an optional description for the document
  optional string description = 2;

  // Metadata contains user-specified metadata about the document
  map<string, string> metadata = 3;

  // RefreshPeriod specifies the period, in seconds, at which the document must be refreshed
  // If unspecified or zero, the document will be refreshed on each sync.
  // When set to -1, the document will only refresh once
  optional int32 refreshPeriod = 4;

  // NodeParser specifies document-specific options for breaking up the document into nodes
  optional NodeParserSpec nodeParser = 5;

  // EmbeddingModel specifies a document-specific embedding model
  optional ModelSpec embeddingModel = 6;

  // File specifies the configuration to read text from an external file
  optional FileLocationReaderSpec file = 7;

  // Database specifies the configuration to read text from a database query
  optional DatabaseReaderSpec database = 8;

  // Web specifies the configuration to read text from an external web-based source
  optional WebReaderSpec web = 9;

  // Repository specifies the configuration to read many files from a repository,
  optional RepositoryReaderSpec repository = 10;
}

message DocumentStatus {
  // The unique name of the document
  // +kubebuilder:validation:Required
  // +required
  optional string name = 1;

  // The number of nodes created for the document
  optional int32 nodes = 2;

  // The last error that occurred while processing the document
  optional string lastError = 3;

  // Indicates if the document is manually flagged for refresh
  optional bool flagged = 4;

  // The time at which the document was last refreshed
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastRefreshAt = 5;
}

message ExtensionFilter {
  // File extensions to include
  repeated string include = 1;

  // File extensions to exclude. All extensions excluding the collection will be matched
  repeated string exclude = 2;
}

message FileLocationReaderSpec {
  optional FileReaderSpec fileReaderSpec = 4;

  // The location of the file
  optional github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.FileLocation location = 2;

  // The URL to download the file
  optional string url = 3;
}

message FileReaderSpec {
  // The type of file reader
  optional string type = 1;

  // Reader-specific options
  map<string, string> options = 4;
}

// FilteredNodeParser specifies a node parser and optional filters
message FilteredNodeParser {
  // Filter documents by their file extension
  optional ExtensionFilter extension = 1;

  // Filter documents by their length
  optional LengthFilter length = 2;

  // Filter documents by their name
  optional NameFilter name = 3;

  // Filter documents by their metadata
  map<string, string> metadata = 4;

  // The node parser definition
  optional ConcreteNodeParserSpec parser = 5;
}

// +kubebuilder:subresource:status
// +kubebuilder:resource:path=knowledgebases,singular=knowledgebase,shortName=kb,categories={llm,modela}
// +kubebuilder:object:root=true
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Owner",type="string",JSONPath=".spec.owner",priority=1
// +kubebuilder:printcolumn:name="Last Sync",type="date",JSONPath=".status.lastSyncAt",description=""
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
// KnowledgeBase represents a collection of documents that can be queried with retrieval-augmented generation
message KnowledgeBase {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional KnowledgeBaseSpec spec = 2;

  optional KnowledgeBaseStatus status = 3;
}

// +kubebuilder:object:root=true
// KnowledgeBaseList contains a list of KnowledgeBases
message KnowledgeBaseList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated KnowledgeBase items = 2;
}

message KnowledgeBaseSpec {
  // Owner specifies the name of the Account which the object belongs to
  // +kubebuilder:default:="no-one"
  // +kubebuilder:validation:Optional
  optional string owner = 1;

  // The user-provided description of the Knowledge Base
  // +kubebuilder:default:=""
  // +kubebuilder:validation:MaxLength=512
  // +kubebuilder:validation:Optional
  optional string description = 2;

  // RefreshSchedule specifies the schedule for Modela to refresh all documents specified by the Knowledge Base
  optional github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.RunSchedule refreshSchedule = 3;

  // The name of the Virtual Bucket where artifacts generated by the Knowledge Base will be stored.
  // If empty, default to the Data Product's default artifact bucket
  // +kubebuilder:validation:Optional
  optional string artifactBucketName = 4;

  // The name of the Lab under which Jobs created by the Knowledge Base will be executed.
  // If empty, default to the Data Product's default Lab
  // +kubebuilder:validation:Optional
  optional string labName = 5;

  // Resources specifies the resource requirements that will be allocated for refresh jobs
  // +kubebuilder:validation:Optional
  optional github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.ResourceSpec resources = 6;

  // MetadataDatabase specifies a connection to a database used to store document metadata and statuses.
  // When specified, any document metadata specified by Documents will be cleared and migrated to the table
  optional string metadataDatabaseConnectionName = 7;

  // VectorStoreConnectionName specifies the name of a Connection resource that provides a vector database
  optional string vectorStoreConnectionName = 8;

  // DocumentStoreConnectionName specifies the name of a Connection resource to use as a document store
  optional string documentStoreConnectionName = 9;

  // EmbeddingModel specifies the embedding model to use when ingesting documents
  optional ModelSpec embeddingModel = 10;

  // Documents specifies the collection of documents included in the Knowledge Base
  repeated DocumentSpec documents = 11;

  // NodeParser specifies the default node parser for all documents.
  // The node parser defines how to split up documents into individual chunks of text
  optional NodeParserSpec nodeParser = 12;
}

message KnowledgeBaseStatus {
  // ObservedGeneration specifies the last generation that was reconciled
  // +kubebuilder:validation:Optional
  optional int64 observedGeneration = 1;

  // LastRefreshAt specifies the time at which the last refresh job was executed
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastRefreshAt = 2;

  // LastCompletionAt specifies the time at which the last refresh job was completed
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastCompletionAt = 3;

  // Logs contains the location of the logs produced by the last refresh job
  // +kubebuilder:validation:Optional
  repeated github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.ContainerLog logs = 4;

  // Documents contains the collection of statuses for each document defined by the Knowledge Base.
  // In the case that a metadata database is defined, the collection will be empty
  repeated DocumentStatus documents = 5;

  // The last time the object was updated
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time updatedAt = 6;

  // +kubebuilder:validation:Optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 7;
}

message LengthFilter {
  // Match if the document length is greater than the specified value
  optional uint32 greaterThan = 1;

  // Match if the document length is less than the specified value
  optional uint32 lessThan = 2;
}

// MixedNodeParserSpec defines a node parser that changes based on the document being parsed
message MixedNodeParserSpec {
  // The collection of filtered node parsers, with each containing one or more filters and a parser definition.
  // Each parser is matched sequentially in the order that they are listed
  repeated FilteredNodeParser parsers = 1;

  // The node parser to use for documents that are not matched to any of the parsers specified in Parsers
  optional ConcreteNodeParserSpec fallback = 2;
}

// ModelSpec specifies the configuration for an LLM
message ModelSpec {
  // ConnectionName specifies the name of a connection to a foundational model provider
  optional string connectionName = 1;

  // Model specifies the vendor-specific model type
  optional string model = 2;
}

message NameFilter {
  // Match documents whose name contains the specified string
  optional string contains = 1;

  // Match documents whose name equals the specified string
  optional string equals = 2;
}

// NodeParserSpec defines how to break up a document into individual chunks of text.
// A dynamic node parser may also specify a mixed parser, which can changes between multiple
// concrete node parsers depending on the document being processed
message NodeParserSpec {
  optional ConcreteNodeParserSpec concreteNodeParserSpec = 7;

  // The specification for a mixed node parser, which will change depending on the document being processed
  optional MixedNodeParserSpec mixed = 6;
}

message RepositoryFileReader {
  // The file extension supported by the reader. Only one of Extension or Extensions may be specified
  optional string extension = 1;

  // The collection of extensions supported by the reader
  // +kubebuilder:validation:Optional
  repeated string extensions = 2;

  // The file reader to use for the specified extensions
  optional FileReaderSpec reader = 3;
}

message RepositoryReaderSpec {
  // The type of repository reader
  optional string type = 1;

  // The name of the connection that provides authorization details for the repository
  optional string connectionName = 2;

  // The collection of supported file extensions to read. File extensions supported by Modela will
  // automatically be read by their supported reader, if not already defined in Readers
  repeated string extensions = 3;

  // The readers to use for individual file extensions
  // +kubebuilder:validation:Optional
  repeated RepositoryFileReader readers = 4;

  // Reader-specific options
  map<string, string> options = 5;
}

// SentenceSplitterSpec splits text documents with a preference for complete sentences
message SentenceSplitterSpec {
  // The chunk size, in tokens, for each chunk. When unspecified, default to 1024
  optional int32 chunkSize = 1;

  // The amount of tokens that will be captured on each side of the node. When unspecified, default to 200
  optional int32 chunkOverlap = 2;

  // The separator character for words. When unspecified, default to the space character
  optional string wordSeparator = 3;

  // The separator character for paragraphs. When unspecified, default to newline
  optional string paragraphSeparator = 4;

  // The function to split documents into sentences. When unspecified, default to the Punkt tokenizer
  optional SentenceTokenizerSpec splitter = 5;
}

// SentenceTokenizerSpec defines a function to split text into sentences
message SentenceTokenizerSpec {
  optional string type = 1;

  // The separator character or regex pattern, required when the tokenizer type is `regex` or `separator`
  optional string separator = 2;
}

message SentenceWindowNodeParserSpec {
  // The function to split documents into sentences. When unspecified, default to the Punkt tokenizer
  optional SentenceTokenizerSpec splitter = 1;

  // The number of sentences to capture on each side of the node. When unspecified, default to 3
  optional int32 windowSize = 2;
}

// TextSplitterSpec defines how to split a document into sentences using a text splitter
message TextSplitterSpec {
  // The type of text splitter. When a specification for a text splitter is provided, this field
  // may be omitted. When not provided, the defaults for the specified text splitter type will be used.
  // When unspecified, default to the sentence splitter
  optional string type = 1;

  // Sentence splits the document by sentence
  optional SentenceSplitterSpec sentence = 2;

  // Token splits the document by tokens
  optional TokenSplitterSpec token = 3;

  // Code splits code documents
  optional CodeSplitterSpec code = 4;
}

// TokenSplitterSpec splits text documents by their tokens
message TokenSplitterSpec {
  // The chunk size, in tokens, for each chunk. When unspecified, default to 1024
  optional int32 chunkSize = 1;

  // The amount of tokens that will be captured on each side of the node. When unspecified, default to 200
  optional int32 chunkOverlap = 2;

  // The separator character for words. When unspecified, default to the space character
  optional string wordSeparator = 3;
}

message WebReaderSpec {
  // The type of web reader
  optional string type = 1;

  // The name of the connection that provides authorization details to the reader, if applicable
  optional string connectionName = 2;

  // Reader-specific options
  map<string, string> options = 3;
}

