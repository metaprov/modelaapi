package v1alpha1

type DataType string

const (
	TextDataType          DataType = "text"
	IntegerColumnDataType DataType = "integer"
	FloatColumnDataType   DataType = "float"
)

type Granularity string

const (
	// DocumentGranularity extracts a single data point for all document objects generated by a reader.
	// A reader is defined for every document within a Knowledge Base, and may produce many individual documents
	DocumentGranularity Granularity = "document"
	// NodeGranularity extracts a data point for every individual document object generated by a reader
	NodeGranularity Granularity = "node"
)

// Embedding defines the configuration for an embedding column
type Embedding struct {
	// The list of text columns to include when generating the embedding
	Columns []string `json:"columns,omitempty" protobuf:"bytes,1,opt,name=columns"`
	// The embedding model to use to generate the embedding
	Model *ModelSpec `json:"model,omitempty" protobuf:"bytes,2,opt,name=model"`
}

// Column defines the schema for a single column in a table managed by a SQL index
type Column struct {
	// The name of the column
	Name string `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
	// The data type of the column
	Type DataType `json:"type,omitempty" protobuf:"bytes,2,opt,name=type"`
	// The description of the column, which the LLM will use to extract the value of the column from documents
	Description string `json:"description,omitempty" protobuf:"bytes,3,opt,name=description"`
	// The metadata key of the document being processed which will be used as a value for the column
	MetadataKey *string `json:"metadataKey,omitempty" protobuf:"bytes,4,opt,name=metadataKey"`
}

// Schema defines the schema of a table managed by a SQL index
type Schema struct {
	// The description of the table
	Description string `json:"description,omitempty" protobuf:"bytes,1,opt,name=description"`
	// The columns of the table
	Columns []Column `json:"columns,omitempty" protobuf:"bytes,2,opt,name=columns"`
}

// SQLIndexSpec defines the configuration for a SQL index. A SQL index can ingest unstructured documents by
// extracting data points that can be inserted into a SQL database
type SQLIndexSpec struct {
	// The LLM to use when extracting data points from documents
	Model *ModelSpec `json:"model,omitempty" protobuf:"bytes,1,opt,name=model"`
	// The name of the connection the SQL database
	DatabaseConnectionName string `json:"databaseConnectionName,omitempty" protobuf:"bytes,2,opt,name=databaseConnectionName"`
	// The name of the table. If the table does not exist, a table schema must be provided in Schema
	TableName *string `json:"tableName,omitempty" protobuf:"bytes,3,opt,name=tableName"`
	// The name of the required column specifying the document which the data point belongs to.
	// If unspecified, default to `ref_doc_id`. The column will automatically be appended to created tables
	RefDocColumn *string `json:"refDocColumn,omitempty" protobuf:"bytes,4,opt,name=refDocColumn"`
	// The schema of the table managed by the index. If present, the schema will be validated against the database table
	Schema *Schema `json:"schema,omitempty" protobuf:"bytes,5,opt,name=schema"`
	// Granularity defines the scale at which data points are extracted from documents produced by readers.
	// For example, the `node` granularity will extract a data point for each page in a PDF file, whilst the
	// `document` granularity will extract a single data point for the entire file. If unspecified, default to document
	Granularity *Granularity `json:"granularity,omitempty" protobuf:"bytes,6,opt,name=granularity"`
}
