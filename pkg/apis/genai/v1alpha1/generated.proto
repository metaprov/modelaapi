/**
*
* Copyright (C) 2017 modela authors
* For license information, see LICENSE.txt
*/
// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.metaprov.modelaapi.pkg.apis.genai.v1alpha1;

import "github.com/metaprov/modelaapi/pkg/apis/catalog/v1alpha1/generated.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "github.com/metaprov/modelaapi/pkg/apis/genai/v1alpha1";

// +k8s:openapi-gen=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:path=apikeygroups,singular=apikeygroup,shortName=akg,categories={genai,modela}
// +kubebuilder:object:root=true
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Owner",type="string",JSONPath=".spec.owner",priority=1
// +kubebuilder:printcolumn:name="Last Sync",type="date",JSONPath=".status.lastSyncAt",description=""
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
// APIKeyGroup represents a collection of physical API keys that can be used to access an LLM server
message APIKeyGroup {
  // +k8s:openapi-gen=false
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional APIKeyGroupSpec spec = 2;

  optional APIKeyGroupStatus status = 3;
}

// +kubebuilder:object:root=true
// APIKeyGroupList contains a list of APIKeyGroups
message APIKeyGroupList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated APIKeyGroup items = 2;
}

message APIKeyGroupSpec {
  // Owner specifies the name of the Account which the object belongs to
  // +kubebuilder:default:="no-one"
  // +kubebuilder:validation:Optional
  optional string owner = 1;

  // The user-provided description of the LLMServer
  // +kubebuilder:default:=""
  // +kubebuilder:validation:MaxLength=512
  // +kubebuilder:validation:Optional
  optional string description = 2;

  // The configuration for the storage of API key metadata
  optional APIKeyGroupStorageSpec storage = 3;

  // The collection of LLM servers that can be authorized through the API key group.
  // If empty, all LLM server resources (and their respective model servers) which allow the key group may be accessed
  repeated string allowedServerNames = 4;

  // The collection of endpoint names that can be authorized through the API key group.
  // If empty, endpoints will not be restricted by their name
  repeated string allowedEndpointNames = 5;

  // The collection of API keys belonging to the group
  repeated APIKeySpec apiKeys = 6;
}

message APIKeyGroupStatus {
  // ObservedGeneration specifies the last generation that was reconciled
  // +kubebuilder:validation:Optional
  optional int64 observedGeneration = 1;

  // The name of the connection which metadata for the API keys associated with the group are being stored
  optional string storageConnectionName = 2;

  // The collection of statuses for all API keys associated with the group
  repeated APIKeyStatus apiKeys = 3;

  // The last time the object was updated
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time updatedAt = 4;

  // +kubebuilder:validation:Optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 5;
}

message APIKeyGroupStorageSpec {
  // The type of storage medium. If unspecified, default to database
  optional string type = 1;

  // The name of the connection to the storage medium, applicable if using a database.
  // If unspecified, default to the database specified by the tenant of the group
  optional string connectionName = 2;
}

// APIKeyMetrics contains the metrics for a single API key
message APIKeyMetrics {
  // The usage metrics for the current quota period
  optional Quota quota = 1;

  // The total amount of tokens served through the key
  optional int64 totalTokens = 2;

  // The total amount of requests served through the key
  optional int64 totalRequests = 3;

  // The total cost (in USD) served through the key
  optional float totalCost = 4;

  // The aggregation period (daily, weekly, monthly, etc.) over which averages will be calculated (default to daily).
  // Prometheus must be enabled for usage metrics to be aggregated
  optional string aggregationPeriod = 5;

  // The average amount of tokens served through the key
  optional int64 averageTokens = 6;

  // The average amount of requests served through the key
  optional int64 averageRequests = 7;

  // The average cost (in USD) for requests served through the key
  optional float averageCost = 8;
}

// APIKeyQuota defines usage limits for a single API key
message APIKeyQuota {
  optional Quota quota = 1;

  // The schedule at which the quota will reset
  optional github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.RunSchedule resetSchedule = 2;
}

// APIKeySpec defines the configuration for a single API key
message APIKeySpec {
  // The unique name of the API key
  // +kubebuilder:validation:Required
  // +required
  optional string name = 1;

  // The collection of LLM servers that can be authorized through the API.
  // If empty, all LLM server resources (and their respective model servers) which allow the key group may be accessed
  repeated string allowedServerNames = 2;

  // The collection of endpoint names that can be authorized through the API key.
  // If empty, endpoints will not be restricted by their name
  repeated string allowedEndpointNames = 3;

  // The quota for the API key, which restricts the amount of resources it can consume
  optional APIKeyQuota quota = 4;
}

// APIKeyStatus contains the status of a single API key
message APIKeyStatus {
  // The unique name of the API key
  optional string name = 1;

  // The date at which the API key was created
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time creationDate = 2;

  // The date at which the API key was last used
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUsedDate = 3;

  // The date at which a physical key string was last generated for the API key
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time generatedDate = 4;

  // The time at which the quota limits for the API key were reached
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time quotaExceededDate = 5;

  // The time at which the quota for the key was last reset
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time quotaResetDate = 6;

  // The metrics collected for the API key
  optional APIKeyMetrics metrics = 7;
}

// AutoVectorRetrieverSpec defines a vector retriever which automatically configures the request to a vector index
// (top K, metadata filters, query embedding) through an LLM
message AutoVectorRetrieverSpec {
  // Indicates if automatic query generation is enabled
  optional bool enabled = 1;

  // The LLM to use when generating queries. If unspecified, use the default provided by model server
  optional ModelSpec model = 2;

  // The maximum top K allowed. The top K set by the LLM will be clamped to this value
  optional int64 maxTopK = 3;

  // The collection of metadata key info, which the LLM will use to infer metadata filters
  repeated MetadataKeyInfo metadataInfo = 4;
}

message BooleanSpec {
  // The method to use for determining the final boolean value extracted from all nodes. If unspecified, default to mean
  optional string extractionMode = 1;

  // The default boolean value, if one could not be extracted from the nodes. If unspecified, the column will be left null
  optional bool default = 2;
}

// CodeSplitterSpec splits code documents by their syntax trees
message CodeSplitterSpec {
  // The language of the document(s). When set to `infer`, the language of the document
  // will be inferred using the extension of the original file. Documents that
  // cannot be parsed using the specified language will be skipped
  // +kubebuilder:validation:Required
  optional string language = 1;

  // The number of code lines in each chunk. When unspecified, default to 40
  optional int32 chunkLines = 2;

  // The amount of code lines that will be captured on each side of the node. When unspecified, default to 15
  optional int32 chunkLinesOverlap = 3;

  // The maximum amount of characters in each chunk. When unspecified, default to 1500
  optional int32 maxChars = 4;
}

message CohereRerankSpec {
  // The connection to Cohere
  optional string connectionName = 1;

  // The top number of nodes to return. If unspecified, default to 2
  optional int64 topN = 2;
}

// Column defines the schema for a single column in a table managed by a SQL index
message Column {
  // The name of the column
  optional string name = 1;

  // The data type of the column. When a specification for a data type is provided, this field may be omitted.
  // When not provided, the defaults for the data type will be used
  optional string type = 2;

  // The specification for an integer column
  optional IntegerSpec integer = 3;

  // The specification for a float column
  optional FloatSpec float = 4;

  // The specification for a text column
  optional TextSpec text = 5;

  // The specification for a boolean column
  optional BooleanSpec boolean = 6;

  // The description of the column, which the LLM will use to extract the value of the column from documents
  optional string description = 7;

  // The metadata key of the document being processed which will be used as a value for the column
  optional string metadataKey = 8;
}

message DatabaseReaderSpec {
  // The type of database reader
  optional string type = 1;

  // The name of the connection to the database
  optional string connectionName = 2;

  // The query to execute on the database
  optional string query = 3;

  // Reader-specific options
  map<string, string> options = 4;
}

// DocumentSpec defines the specification of a single document
message DocumentSpec {
  // The unique name of the document
  optional string name = 1;

  // Description specifies an optional description for the document
  optional string description = 2;

  // Metadata contains user-specified metadata about the document
  map<string, string> metadata = 3;

  // RefreshPeriod specifies the period, in seconds, at which the document must be refreshed
  // If unspecified or zero, the document will be refreshed on each sync.
  // When set to -1, the document will only refresh once
  optional int32 refreshPeriod = 4;

  // Indexes specifies the collection of indexes that the document will be added to.
  // If empty, the document will be added to all indexes defined by the Knowledge Base
  repeated string indexes = 5;

  // NodeParser specifies the name of the document-specific node parser to use
  optional string nodeParser = 6;

  // EmbeddingModel specifies a document-specific embedding model
  optional ModelSpec embeddingModel = 7;

  // File specifies the configuration to read text from an external file
  optional FileLocationReaderSpec file = 8;

  // Database specifies the configuration to read text from a database query
  optional DatabaseReaderSpec database = 9;

  // Web specifies the configuration to read text from an external web-based source
  optional WebReaderSpec web = 10;

  // Repository specifies the configuration to read many files from a repository,
  optional RepositoryReaderSpec repository = 11;
}

message DocumentStatus {
  // The unique name of the document
  // +kubebuilder:validation:Required
  // +required
  optional string name = 1;

  // The number of nodes created for the document
  optional int32 nodes = 2;

  // The last error that occurred while processing the document
  optional string lastError = 3;

  // Indicates if the document is manually flagged for refresh
  optional bool flagged = 4;

  // The time at which the document was last refreshed
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastRefreshAt = 5;
}

// DocumentSummaryIndexSpec specifies the configuration for a document summary index
message DocumentSummaryIndexSpec {
  // The response synthesizer to use when summarizing documents
  optional ResponseSynthesizerSpec responseSynthesizer = 1;

  // The configuration to optionally embed summarized documents
  optional VectorIndexSpec embedding = 2;
}

// DocumentSummaryRetrieverSpec defines a retriever for a document summary index
message DocumentSummaryRetrieverSpec {
  // The reference to the vector store index
  optional IndexReference index = 1;

  // The embedding or large language model to use. If unspecified, use the default provided by model server
  optional ModelSpec model = 2;

  // The top K nodes to retrieve. If unspecified, default to 1
  optional int64 topK = 3;

  // The retriever mode. If unspecified, default to embedding
  optional string mode = 4;
}

message EmbeddingRecencyPostProcessorSpec {
  // The embedding model to use
  optional ModelSpec embeddingModel = 1;

  // The similarity cutoff. If unspecified, default to 0.7
  optional float similarityCutoff = 2;
}

// EmbeddingSpec defines the configuration for an embedding column
message EmbeddingSpec {
  // The list of text columns to include when generating the embedding
  repeated string columns = 1;

  // The embedding model to use to generate the embedding
  optional ModelSpec model = 2;
}

// EndpointMetrics contains the metrics for a single model endpoint (collected by Prometheus)
message EndpointMetrics {
  // 50% latency for requests served by the endpoint
  // +kubebuilder:validation:Optional
  optional double p50 = 4;

  // 95% latency for requests served by the endpoint
  // +kubebuilder:validation:Optional
  optional double p95 = 5;

  // 99% latency for requests served by the endpoint
  // +kubebuilder:validation:Optional
  optional double p99 = 6;

  // The total number of requests served by the endpoint
  optional int32 totalRequests = 8;

  // The total number of tokens served by the endpoint
  optional int32 totalTokens = 9;

  // The total approximate cost (in USD) of tokens served by the endpoint
  optional float totalCost = 10;
}

// EndpointSpec specifies the serving configuration for a single large language model endpoint
message EndpointSpec {
  // The unique name of the model
  // +kubebuilder:validation:Required
  // +required
  optional string name = 1;

  // The name of the query engine used to augment requests to the LLMServer.
  // If unspecified, no augmentation will be performed
  optional string queryEngine = 2;

  // The path suffix where the model will be served.
  // If unspecified, the default suffix for the LLMServer provider will be used
  optional string path = 3;

  // The collection of path suffixes where the model will be served
  repeated string paths = 4;

  // The API format standard that will be served for the model.
  // If unspecified, default to the OpenAI API format
  optional string format = 5;

  // The default LLMServer to use for all internal and consumer-facing completion requests
  optional ModelSpec model = 6;
}

// EndpointStatus describes the current state of a single model served by the LLMServer proxy
message EndpointStatus {
  // The unique name of the model
  // +kubebuilder:validation:Required
  // +required
  optional string name = 1;

  // The details of the last failure that occurred while deploying the model
  // +kubebuilder:validation:Optional
  optional string failureMessage = 4;

  // The metrics collected for the model
  optional EndpointMetrics metrics = 5;
}

message ExtensionFilter {
  // File extensions to include
  repeated string include = 1;

  // File extensions to exclude. All extensions excluding the collection will be matched
  repeated string exclude = 2;
}

message FileLocationReaderSpec {
  optional FileReaderSpec fileReaderSpec = 4;

  // The location of the file
  optional github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.FileLocation location = 2;

  // The URL to download the file
  optional string url = 3;
}

message FileReaderSpec {
  // The type of file reader
  // +kubebuilder:default:="default"
  optional string type = 1;

  // Reader-specific options
  map<string, string> options = 4;
}

// FilteredNodeParser specifies a node parser and optional filters
message FilteredNodeParser {
  // Filter documents by their file extension
  optional ExtensionFilter extension = 1;

  // Filter documents by their length
  optional LengthFilter length = 2;

  // Filter documents by their name
  optional NameFilter name = 3;

  // Filter documents by their metadata
  map<string, string> metadata = 4;

  // The name of the node parser to use
  optional string nodeParser = 5;
}

message FixedRecencyPostProcessorSpec {
  // The top most recent nodes to return. If unspecified, default to 1
  optional int64 topK = 1;
}

message FloatSpec {
  // The method to use for determining the final number extracted from all nodes. If unspecified, default to mean
  optional string extractionMode = 1;

  // The rounding mode to use when determining the final number. If unspecified, rounding will not be applied
  optional string roundingMode = 2;

  // The maximum precision of the extracted float. If unspecified, default to 3
  optional int32 precision = 3;

  // The default number, if one could not be extracted from the nodes. If unspecified, the column will be left null
  optional int32 default = 4;
}

// FusionRetrieverSpec defines a retriever which can combine the results from multiple concrete retrievers
message FusionRetrieverSpec {
  // The collection of retriever names
  repeated string retrievers = 1;

  // The embedding or large language model to use when generating questions.
  // If unspecified, use the default provided by model server
  optional ModelSpec model = 2;

  // The number of queries to generate for the input query. If unspecified, default to 4
  optional int64 queries = 3;

  // The top K nodes to retrieve. If unspecified, default to 1
  optional int64 topK = 4;

  // The fusion retriever mode. If unspecified, default to simple
  optional string mode = 5;

  // The default score for nodes which were retrieved without a score. If unspecified, default to 1
  optional float defaultScore = 6;
}

// HierarchicalSplitterSpec defines how to split text documents into a recursive hierarchy of nodes
message HierarchicalSplitterSpec {
  // Indicates if hierarchical splitting is enabled
  optional bool enabled = 1;

  // The chunk sizes for each level in the hierarchy. When unspecified, default to 2048, 512, and 128
  repeated int64 chunkSizes = 4;
}

// IndexReference defines a reference to a single index within a Knowledge Base
message IndexReference {
  // The name of the Knowledge Base
  optional string knowledgeBaseName = 1;

  // The name of the index. If unspecified, default to the first index defined by the Knowledge Base
  optional string index = 2;
}

// IndexSpec specifies the configuration for a document index
message IndexSpec {
  // Name specifies the name of the index
  // +kubebuilder:validation:Required
  // +required
  optional string name = 1;

  // Vector stores documents with vector embeddings
  optional VectorIndexSpec vector = 2;

  // DocumentSummary stores documents by their summaries
  optional DocumentSummaryIndexSpec documentSummary = 3;

  // Tree builds tree-structured index, where each node is a summary of the children nodes
  optional TreeIndexSpec tree = 4;

  // KeywordTable indexes documents by their keywords
  optional KeywordTableIndexSpec keywordTable = 5;

  // SQL indexes structured data points extracted from documents
  optional SQLIndexSpec sql = 6;

  // List builds an index which nodes are stored in a sequenced list
  optional ListIndexSpec list = 7;
}

message IndexStatus {
  // The unique name of the index
  // +kubebuilder:validation:Required
  // +required
  optional string name = 1;

  // The number of documents ingested in the index
  optional int32 documents = 2;
}

message IntegerSpec {
  // The method to use for determining the final number extracted from all nodes. If unspecified, default to mean
  optional string extractionMode = 1;

  // The rounding mode to use when determining the final number. If unspecified, default to `round`
  optional string roundingMode = 2;

  // The default number, if one could not be extracted from the nodes. If unspecified, the column will be left null
  optional int32 default = 3;
}

message KeywordPostProcessorSpec {
  // The collection of keywords that must be present in the node content
  repeated string include = 1;

  // The collection of keywords which must not be present in the node content. Matching nodes will be excluded
  repeated string exclude = 2;
}

// KeywordTableIndexSpec specifies the configuration for a keyword table index
message KeywordTableIndexSpec {
  // The index mode, which determines how keywords are extracted from nodes
  optional string mode = 1;

  // The LLM to use when extracting keywords from nodes, required if the index is configured with the LLM mode
  optional ModelSpec model = 2;

  // The maximum of number of keywords that can be extracted from each node. If unspecified, default to 10
  optional int64 maxKeywordsPerNode = 3;
}

message KeywordTableRetrieverSpec {
  // The reference to the tree index
  optional IndexReference index = 1;

  // The large language model to use, if using the LLM mode. If unspecified, use the default provided by model server
  optional ModelSpec model = 2;

  // The retriever mode. If unspecified, default to RAKE
  optional string mode = 3;

  // The maximum number of keywords to consider per query. If unspecified, default to 10
  optional int64 keywordsPerQuery = 4;

  // The maximum number of chunks to retrieve per query. If unspecified, default to 10
  optional int64 chunksPerQuery = 5;
}

// +k8s:openapi-gen=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:path=knowledgebases,singular=knowledgebase,shortName=kb,categories={genai,modela}
// +kubebuilder:object:root=true
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Owner",type="string",JSONPath=".spec.owner",priority=1
// +kubebuilder:printcolumn:name="Last Sync",type="date",JSONPath=".status.lastSyncAt",description=""
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
// KnowledgeBase represents a collection of documents that are stored in one or more indexes
message KnowledgeBase {
  // +k8s:openapi-gen=false
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional KnowledgeBaseSpec spec = 2;

  optional KnowledgeBaseStatus status = 3;
}

// +kubebuilder:object:root=true
// KnowledgeBaseList contains a list of KnowledgeBases
message KnowledgeBaseList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated KnowledgeBase items = 2;
}

// +k8s:openapi-gen=true
message KnowledgeBaseSpec {
  // Owner specifies the name of the Account which the object belongs to
  // +kubebuilder:default:="no-one"
  // +kubebuilder:validation:Optional
  optional string owner = 1;

  // The user-provided description of the Knowledge Base
  // +kubebuilder:default:=""
  // +kubebuilder:validation:MaxLength=512
  // +kubebuilder:validation:Optional
  optional string description = 2;

  // RefreshSchedule specifies the schedule for Modela to refresh all documents specified by the Knowledge Base
  optional github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.RunSchedule refreshSchedule = 3;

  // The name of the Virtual Bucket where artifacts generated by the Knowledge Base will be stored.
  // If empty, default to the Data Product's default artifact bucket
  // +kubebuilder:validation:Optional
  optional string artifactBucketName = 4;

  // The name of the Lab under which Jobs created by the Knowledge Base will be executed.
  // If empty, default to the Data Product's default Lab
  // +kubebuilder:validation:Optional
  optional string labName = 5;

  // Resources specifies the resource requirements that will be allocated for refresh jobs
  // +kubebuilder:validation:Optional
  optional github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.ResourceSpec resources = 6;

  // MetadataDatabaseConnectionName specifies a connection to a database used to store document metadata and statuses.
  // When specified, any document metadata specified by Documents will be cleared and migrated to the table
  optional string metadataDatabaseConnectionName = 7;

  // DocumentStoreConnectionName specifies the name of a Connection resource to use as a document store
  optional string documentStoreConnectionName = 9;

  // Indexes specifies the collection of indexes that the documents will be added to
  repeated IndexSpec indexes = 10;

  // Documents specifies the collection of documents included in the Knowledge Base
  repeated DocumentSpec documents = 11;

  // NodeParser defines the collection of node parsers available to documents prior to indexing.
  // The node parsers define how to split up documents into individual chunks of text.
  // If empty, the default node parser will be used
  repeated NodeParserSpec nodeParsers = 12;

  // DefaultNodeParser specifies the name of the default node parser to use.
  // If unspecified, the first node parser defined in NodeParsers will be used
  optional string defaultNodeParser = 13;
}

message KnowledgeBaseStatus {
  // ObservedGeneration specifies the last generation that was reconciled
  // +kubebuilder:validation:Optional
  optional int64 observedGeneration = 1;

  // LastRefreshAt specifies the time at which the last refresh job was executed
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastRefreshAt = 2;

  // LastCompletionAt specifies the time at which the last refresh job was completed
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastCompletionAt = 3;

  // Logs contains the location of the logs produced by the last refresh job
  // +kubebuilder:validation:Optional
  repeated github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.ContainerLog logs = 4;

  // Documents contains the collection of statuses for each document defined by the Knowledge Base.
  // In the case that a metadata database is defined, the collection will be empty
  repeated DocumentStatus documents = 5;

  // Indexes contains the collection of statuses for each index defined by the Knowledge Base
  repeated IndexStatus indexes = 6;

  // The last time the object was updated
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time updatedAt = 7;

  // +kubebuilder:validation:Optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 8;
}

// KnowledgeGraphQueryEngine augments a query with information from a knowledge graph
message KnowledgeGraphQueryEngine {
}

message LLMRerankSpec {
  // The top number of nodes to return. If unspecified, default to 10
  optional int64 topN = 1;

  // The LLM to use for re-ranking. If unspecified, use the default provided by the parent specification
  optional ModelSpec model = 2;

  // Indicates if the RankGPT technique for re-ranking will be used
  optional bool rankGPT = 3;
}

// +kubebuilder:subresource:status
// +kubebuilder:resource:path=llmservers,singular=llmserver,shortName=llms,categories={llm,modela}
// +kubebuilder:object:root=true
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Owner",type="string",JSONPath=".spec.owner",priority=1
// +kubebuilder:printcolumn:name="Last Sync",type="date",JSONPath=".status.lastSyncAt",description=""
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
// LLMServer represents a deployment of a proxy server to one or more LLMs
message LLMServer {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional LLMServerSpec spec = 2;

  optional LLMStatus status = 3;
}

message LLMServerAccessSpec {
  // The port number that will be exposed by the Kubernetes Service to serve requests
  // +kubebuilder:validation:Optional
  // +kubebuilder:validation:Minimum=1024
  // +kubebuilder:validation:Maximum=65535
  // +kubebuilder:validation:Optional
  // +kubebuilder:default:=8080
  optional int32 port = 1;

  // The port number that will be exposed on the external address of every node on the cluster, in the case of the
  // AccessType being equal to NodePort. Traffic from the port will be forwarded to the LLMServer deployment
  // +kubebuilder:validation:Minimum=0
  // +kubebuilder:validation:Maximum=65535
  // +kubebuilder:validation:Optional
  optional int32 nodePort = 2;

  // The Kubernetes-native access method which specifies how the Kubernetes Service created by the Predictor will be exposed.
  // See https://modela.ai/docs/docs/serving/production/#access-method for a detailed description of each access type
  // +kubebuilder:default:="cluster-ip"
  // +kubebuilder:validation:Optional
  optional string accessType = 4;
}

// LLMServerAuthorizationSpec defines the configuration to authorize incoming requests to the LLMServer
message LLMServerAuthorizationSpec {
  // Indicates if models served by the LLMServer can be accessed without authorization (not recommended)
  optional bool insecure = 1;

  // The collection of API key groups whose API keys may be used to authorize requests to models
  // served by the LLMServer. AllowedKeyGroups acts as a whitelist, only allowing API keys belonging to a group
  // within the collection to be used. If empty, all API key groups will be allowed to authorize requests to the LLMServer
  repeated string allowedKeyGroups = 2;

  // The collection of API key names that may be used to authenticate requests to models served by the LLMServer.
  // AllowedKeyNames acts as a whitelist, only allowing API keys with names within the collection to be used.
  // If empty, API keys will not be restricted by their names
  repeated string allowedKeyNames = 3;
}

// +kubebuilder:object:root=true
// LLMServerList contains a list of LLMServer objects
message LLMServerList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated LLMServer items = 2;
}

// LLMServerSpec specifies the configuration of the LLM server
message LLMServerSpec {
  // Owner specifies the name of the Account which the object belongs to
  // +kubebuilder:default:="no-one"
  // +kubebuilder:validation:Optional
  optional string owner = 1;

  // The user-provided description of the LLM Server
  // +kubebuilder:default:=""
  // +kubebuilder:validation:MaxLength=512
  // +kubebuilder:validation:Optional
  optional string description = 2;

  // The name of the Serving Site under which the LLM Server proxy deployment will be created.
  // If empty, default to the Data Product's default Serving Site
  // +kubebuilder:validation:Optional
  optional string servingSiteName = 3;

  // The resource requirements that will be allocated to the proxy deployment
  // +kubebuilder:validation:Optional
  optional github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.ResourceSpec resources = 4;

  // The model endpoints served by the proxy
  repeated EndpointSpec endpoints = 6;

  // The query engines available to the models
  repeated QueryEngineSpec queryEngines = 7;

  // The collection of retrievers available to the query engines
  repeated RetrieverSpec retrievers = 8;

  // The specification for the LLM Server service to be exposed and accessed externally
  optional LLMServerAccessSpec access = 9;

  // The security configuration for the LLMServer, which determines how incoming requests are authorized
  optional LLMServerAuthorizationSpec authorization = 10;

  // The configuration for Alerts generated by the proxy
  optional github.com.metaprov.modelaapi.pkg.apis.catalog.v1alpha1.NotificationSpec notification = 11;
}

message LLMStatus {
  // ObservedGeneration specifies the last generation that was reconciled
  // +kubebuilder:validation:Optional
  optional int64 observedGeneration = 1;

  // Endpoints contains the collection of statuses for each model served by the proxy server
  repeated EndpointStatus endpoints = 2;

  // Endpoint contains the URL where the proxy server is exposed. An endpoint will only be exposed
  // in the case that the server is bound to an Ingress resource
  optional string endpoint = 3;

  // DeployedAt specifies the time that the LLMServer proxy deployment was created
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time deployedAt = 4;

  // The reference to the Kubernetes Deployment that manages the pods for the prediction proxy
  // +kubebuilder:validation:Optional
  optional k8s.io.api.core.v1.ObjectReference deploymentRef = 5;

  // The reference to the Kubernetes Service which exposes the prediction proxy
  // +kubebuilder:validation:Optional
  optional k8s.io.api.core.v1.ObjectReference serviceRef = 6;

  // The details of the failure that occurred while deploying the prediction proxy
  // +kubebuilder:validation:Optional
  optional string failureMessage = 7;

  // The last time the object was updated
  // +kubebuilder:validation:Optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time updatedAt = 8;

  // +kubebuilder:validation:Optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 9;
}

message LengthFilter {
  // Match if the document length is greater than the specified value
  optional uint32 greaterThan = 1;

  // Match if the document length is less than the specified value
  optional uint32 lessThan = 2;
}

// ListIndexSpec specifies the configuration of a list index
message ListIndexSpec {
}

// ListRetrieverSpec defines a retriever from a list index
message ListRetrieverSpec {
  // The reference to the tree index
  optional IndexReference index = 1;

  // The large language or embedding model to use, if applicable. If unspecified, use the default provided by model server
  optional ModelSpec model = 2;

  // The top K nodes to retrieve when using the embedding or LLM mode. If unspecified, default to 1
  optional int64 topK = 3;

  // The retriever mode. If unspecified, default to simple
  optional string mode = 4;
}

message LongContextReorderSpec {
}

message MetadataKeyInfo {
  // The name of the key
  optional string name = 1;

  // The key type (integer, string, float, etc.)
  optional string type = 2;

  // The key description
  optional string description = 3;
}

// MixedNodeParserSpec defines a node parser that changes based on the document being parsed
message MixedNodeParserSpec {
  // The collection of filtered node parsers, with each containing one or more filters and a parser definition.
  // Each parser is matched sequentially in the order that they are listed
  repeated FilteredNodeParser parsers = 1;

  // The node parser to use for documents that are not matched to any of the parsers specified in Parsers
  optional string fallbackNodeParser = 2;
}

// ModelSpec specifies the configuration for a language or embedding model
message ModelSpec {
  // ConnectionName specifies the name of a connection to a foundational model provider
  optional string connectionName = 1;

  // Model specifies the vendor-specific model type. If unspecified, use the model provided by the
  // `model` option of the connection, or choose the default model for the vendor
  optional string model = 2;
}

message NameFilter {
  // Match documents whose name contains the specified string
  optional string contains = 1;

  // Match documents whose name equals the specified string
  optional string equals = 2;
}

// NodeParserSpec defines how to break up a document into individual chunks of text
message NodeParserSpec {
  // The unique name of the node parser
  // +kubebuilder:validation:Required
  // +required
  optional string name = 1;

  // Indicate if previous/next relationships should be included between nodes. When unspecified, default to true
  optional bool includeOrderRelationship = 2;

  // Indicate if metadata should be included in the nodes. When unspecified, default to true
  optional bool includeMetadata = 3;

  // The type of node parser. When a specification for a text or sentence window node parser is provided, this field
  // may be omitted. When not provided, the defaults for the specified node parser type will be used.
  // When unspecified, default to sentence window
  optional string type = 4;

  // The specification for the text splitter to use as a node parser
  optional TextSplitterSpec text = 5;

  // The specification for the sentence window node parser
  optional SentenceWindowNodeParserSpec sentence = 6;

  // The specification for a mixed node parser, which will change depending on the document being processed
  optional MixedNodeParserSpec mixed = 7;
}

// NodePostProcessor defines a node post-processor, which mutates the nodes retrieved
// by a query engine prior to synthesizing a response
message NodePostProcessor {
  // Exclude nodes below a similarity threshold
  optional SimilarityPostProcessorSpec similarity = 1;

  // Exclude nodes based on keywords present in their content
  optional KeywordPostProcessorSpec keyword = 2;

  // Re-order nodes by their score, placing the most relevant nodes at the beginning of the context
  optional LongContextReorderSpec reorder = 3;

  // Optimize the content of nodes by extracting the most relevant sentences
  optional SentenceEmbeddingOptimizerSpec embeddingOptimizer = 4;

  // Rerank the nodes through an LLM
  optional LLMRerankSpec llmRerank = 5;

  // Rerank the nodes through a specialized Cohere model
  optional CohereRerankSpec cohereRerank = 6;

  // Choose the top K nodes sorted by date
  optional FixedRecencyPostProcessorSpec fixedRecency = 7;

  // Sort by date and remove similar nodes that are older than newer ones
  optional EmbeddingRecencyPostProcessorSpec embeddingRecency = 8;

  // Choose the top K nodes after applying a time-weighted rerank (by creation date or last access)
  optional TimeWeightedRecencyPostProcessorSpec timeWeightedRecency = 9;
}

// QueryEngineSpec defines a query engine, which is used to retrieve context for a query
// and synthesize a response. A query engine may also route queries to other query engines
message QueryEngineSpec {
  // The unique name of the query engine
  // +kubebuilder:validation:Required
  // +required
  optional string name = 1;

  // Retriever augments a query with context from a retriever
  optional RetrieverQueryEngineSpec retriever = 2;

  // Router chooses one or more query engine(s) to route requests to
  optional RouterQueryEngineSpec router = 3;

  // SubQuestion routes sub-questions generated for a query to one or more query engine(s)
  optional SubQuestionQueryEngineSpec subQuestion = 4;
}

message QueryEngineToolSpec {
  // The name of the query engine
  optional string queryEngine = 1;

  // The name of the query engine
  optional string name = 2;

  // The description of the query engine
  optional string description = 3;
}

message Quota {
  // The maximum amount of tokens
  optional int64 tokens = 1;

  // The maximum amount of requests
  optional int64 requests = 2;

  // The maximum approximate cost (in USD)
  optional float cost = 3;
}

message RepositoryFileReader {
  // The file extension supported by the reader. Only one of Extension or Extensions may be specified
  optional string extension = 1;

  // The collection of extensions supported by the reader
  // +kubebuilder:validation:Optional
  repeated string extensions = 2;

  // The file reader to use for the specified extensions
  optional FileReaderSpec reader = 3;
}

message RepositoryReaderSpec {
  // The type of repository reader
  optional string type = 1;

  // The name of the connection that provides authorization details for the repository
  optional string connectionName = 2;

  // The collection of supported file extensions to read. File extensions supported by Modela will
  // automatically be read by their supported reader, if not already mapped to a reader in Readers.
  // Unsupported extensions will be read as plain-text
  repeated string extensions = 3;

  // The readers to use for individual file extensions
  // +kubebuilder:validation:Optional
  repeated RepositoryFileReader readers = 4;

  // Reader-specific options
  map<string, string> options = 5;
}

// ResponseSynthesizerSpec defines the configuration for a response synthesizer, which
// takes in a set of text chunks and formulates a response
message ResponseSynthesizerSpec {
  // The method to use when synthesizing responses. If unspecified, default to `refine`
  optional string mode = 1;

  // The LLM to use when synthesizing responses. If unspecified, use the default provided by the parent specification
  optional ModelSpec model = 2;

  // Indicates if answer filtering is enabled. Compatible only with refine and compact response modes
  optional bool answerFiltering = 3;
}

// RetrieverQueryEngineSpec augments a query with a retriever
message RetrieverQueryEngineSpec {
  // The response synthesizer to use when generating responses
  optional ResponseSynthesizerSpec responseSynthesizer = 1;

  // The name of the retriever to use when retrieving context
  optional string retriever = 2;

  // The collection of node postprocessors
  repeated NodePostProcessor nodePostProcessors = 3;
}

// RetrieverSpec defines a retriever, which collects text chunks relevant to a query.
// A retriever may also route queries to other retrievers
message RetrieverSpec {
  // The unique name of the retriever
  // +kubebuilder:validation:Required
  // +required
  optional string name = 1;

  // Vector retrieves nodes from a vector index
  optional VectorRetrieverSpec vector = 2;

  // DocumentSummary retrieves nodes from a document summary index
  optional DocumentSummaryRetrieverSpec documentSummary = 3;

  // Tree retrieves nodes from a tree index
  optional TreeRetrieverSpec tree = 4;

  // KeywordTable retrieves nodes from a keyword table index
  optional KeywordTableRetrieverSpec keywordTable = 5;

  // List retrievers nodes from a list index
  optional ListRetrieverSpec list = 6;

  // Router chooses one or more retriever(s) to route requests to
  optional RouterRetrieverSpec router = 7;

  // Fusion combines the results of one or more retriever(s)
  optional FusionRetrieverSpec fusion = 8;
}

message RetrieverToolSpec {
  // The name of the retriever
  optional string retriever = 1;

  // The name of the retriever
  optional string name = 2;

  // The description of the retriever
  optional string description = 3;
}

// RouterQueryEngineSpec routes requests to one or more query engines
message RouterQueryEngineSpec {
  // The query engines to route requests to
  repeated QueryEngineToolSpec tools = 1;

  // The selector to use when choosing query engine(s)
  optional SelectorSpec selector = 2;
}

message RouterRetrieverSpec {
  // The query engines to route requests to
  repeated RetrieverToolSpec tools = 1;

  // The selector to use when choosing retriever(s)
  optional SelectorSpec selector = 2;
}

// SQLIndexSpec defines the configuration for a SQL index. A SQL index can ingest unstructured documents by
// extracting data points that can be inserted into a SQL database
message SQLIndexSpec {
  // The LLMServer to use when extracting data points from documents
  optional ModelSpec model = 1;

  // The name of the connection the SQL database
  optional string databaseConnectionName = 2;

  // The name of the table. If the table does not exist, a table schema must be provided in Schema
  optional string tableName = 3;

  // The name of the required column specifying the document which the data point belongs to.
  // If unspecified, default to `ref_doc_id`. The column will automatically be appended to created tables
  optional string refDocColumn = 4;

  // The schema of the table managed by the index. If present, the schema will be validated against the database table
  optional Schema schema = 5;

  // Granularity defines the scale at which data points are extracted from documents produced by readers.
  // For example, the `node` granularity will extract a data point for each page in a PDF file, whilst the
  // `document` granularity will extract a single data point for the entire file. If unspecified, default to `document`
  optional string granularity = 6;
}

// Schema defines the schema of a table managed by a SQL index
message Schema {
  // The description of the table
  optional string description = 1;

  // The columns of the table
  repeated Column columns = 2;
}

message SelectorSpec {
  // The selection mode. If unspecified, default to `genai`
  optional string mode = 1;

  // The LLM or embedding model that will be used to determine the selections.
  // If unspecified, use the default LLM provided by the model server
  optional ModelSpec model = 2;

  // Indicates if multiple options may be selected
  optional bool multi = 3;
}

message SentenceEmbeddingOptimizerSpec {
  // The embedding model to use
  optional ModelSpec embeddingModel = 1;

  // The percentile cutoff, determining how many top K sentences are selected. If unspecified, the percentile cutoff will be disabled
  optional float similarityCutoff = 2;

  // The threshold cutoff for similarity. If unspecified, the threshold cutoff will be disabled
  optional float thresholdCutoff = 3;
}

// SentenceSplitterSpec splits text documents with a preference for complete sentences
message SentenceSplitterSpec {
  // The chunk size, in tokens, for each chunk. When unspecified, default to 1024
  optional int32 chunkSize = 1;

  // The amount of tokens that will be captured on each side of the node. When unspecified, default to 200
  optional int32 chunkOverlap = 2;

  // The separator character for words. When unspecified, default to the space character
  optional string wordSeparator = 3;

  // The separator character for paragraphs. When unspecified, default to newline
  optional string paragraphSeparator = 4;

  // The function to split documents into sentences. When unspecified, default to the Punkt tokenizer
  optional SentenceTokenizerSpec splitter = 5;

  // The configuration for hierarchical splitting. When unspecified, hierarchical splitting is disabled
  optional HierarchicalSplitterSpec hierarchical = 6;
}

// SentenceTokenizerSpec defines a function to split text into sentences
message SentenceTokenizerSpec {
  optional string type = 1;

  // The separator character or regex pattern, required when the tokenizer type is `regex` or `separator`
  optional string separator = 2;
}

message SentenceWindowNodeParserSpec {
  // The function to split documents into sentences. When unspecified, default to the Punkt tokenizer
  optional SentenceTokenizerSpec splitter = 1;

  // The number of sentences to capture on each side of the node. When unspecified, default to 3
  optional int32 windowSize = 2;
}

message SimilarityPostProcessorSpec {
  // The threshold cutoff for similarity
  optional float cutoff = 3;
}

// SubQuestionQueryEngineSpec breaks down a query into sub-questions that can be routed to other query engines
message SubQuestionQueryEngineSpec {
  // The query engines to route requests to
  repeated QueryEngineToolSpec tools = 1;

  // The response synthesizer to use when generating responses
  optional ResponseSynthesizerSpec responseSynthesizer = 2;

  // The model to use when generating questions
  optional ModelSpec model = 3;
}

message TextSpec {
  // The method to use for determining the final text extracted from all nodes. If unspecified, default to concatenation
  optional string extractionMode = 1;

  // The prompt to use when summarizing text. The prompt must include the literal `{texts}`, which will be
  // filled in with all the generated texts. The prompt may also include the literal `{description}`, which will
  // be filled in with the description of the field
  optional string summarizationPrompt = 2;

  // The string to use for concatenation. If unspecified, default to `, `
  optional string concatenationString = 3;

  // The default text value, if one could not be extracted from the nodes. If unspecified, the column will be left null
  optional int32 default = 5;
}

// TextSplitterSpec defines how to split a document into sentences using a text splitter
message TextSplitterSpec {
  // The type of text splitter. When a specification for a text splitter is provided, this field
  // may be omitted. When not provided, the defaults for the specified text splitter type will be used.
  // When unspecified, default to the sentence splitter
  optional string type = 1;

  // Sentence splits the document by sentence
  optional SentenceSplitterSpec sentence = 2;

  // Token splits the document by tokens
  optional TokenSplitterSpec token = 3;

  // Code splits code documents
  optional CodeSplitterSpec code = 4;
}

message TimeWeightedRecencyPostProcessorSpec {
  // The top most recent nodes to return. If unspecified, default to 1
  optional int64 topN = 1;

  // The rate at which the time similarity of a node decays. If unspecified, default 0.1
  optional float timeDecay = 2;

  // Indicates if the time of last access will be weighted instead of the time of creation.
  // Documents that have not been queried will be favored when enabled
  optional bool lastAccess = 3;
}

// TokenSplitterSpec splits text documents by their tokens
message TokenSplitterSpec {
  // The chunk size, in tokens, for each chunk. When unspecified, default to 1024
  optional int32 chunkSize = 1;

  // The amount of tokens that will be captured on each side of the node. When unspecified, default to 200
  optional int32 chunkOverlap = 2;

  // The separator character for words. When unspecified, default to the space character
  optional string wordSeparator = 3;

  // The configuration for hierarchical splitting. When unspecified, hierarchical splitting is disabled
  optional HierarchicalSplitterSpec hierarchical = 4;
}

// TreeIndexSpec specifies the configuration for a tree index
message TreeIndexSpec {
  // The LLM to use when summarizing and inserting nodes
  optional ModelSpec model = 1;

  // The number of children each node should have. If unspecified, default to 10
  optional int64 children = 2;
}

// TreeRetrieverSpec defines a retriever from a tree index
message TreeRetrieverSpec {
  // The reference to the tree index
  optional IndexReference index = 1;

  // The large language model to use, if applicable. If unspecified, use the default provided by model server
  optional ModelSpec model = 2;

  // The retriever mode. If unspecified, default to select leaf
  optional string mode = 3;

  // The number of child nodes to consider traversing at each level of the tree, if applicable
  optional int64 childBranchFactor = 4;
}

// VectorIndexSpec specifies the configuration for a vector store index
message VectorIndexSpec {
  // DatabaseConnectionName specifies the name of a Connection resource that provides a vector database
  optional string databaseConnectionName = 1;

  // EmbeddingModel specifies the embedding model to use when ingesting documents
  optional ModelSpec embeddingModel = 2;
}

// VectorRetrieverSpec defines a retriever for a vector index
message VectorRetrieverSpec {
  // The reference to the vector store index
  optional IndexReference index = 1;

  // The embedding model to use
  optional ModelSpec embeddingModel = 2;

  // The top K nodes to retrieve. If unspecified, default to 10
  optional int64 topK = 3;

  // Metadata key-value pairs that must be matched on retrieved nodes
  map<string, string> matchMetadata = 4;

  // Indicates if auto-merging of parent and child nodes will be enabled. Auto-merging should only be enabled
  // on indexes that were constructed using a hierarchical node parser. If unspecified, default to false
  optional bool autoMerging = 5;

  // The specification to automatically configure queries to the vector index
  optional AutoVectorRetrieverSpec auto = 6;
}

message WebReaderSpec {
  // The type of web reader
  optional string type = 1;

  // The name of the connection that provides authorization details to the reader, if applicable
  optional string connectionName = 2;

  // Reader-specific options
  map<string, string> options = 3;
}

